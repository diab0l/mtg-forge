import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Random;
import java.util.Vector;

import javax.swing.JOptionPane;

import forge.error.ErrorViewer;
import forge.properties.ForgeProps;
import forge.properties.NewConstants;


public class CardFactory implements NewConstants {
    // String cardname is the key, Card is the value
    private Map<String, Card> map       = new HashMap<String, Card>();
    @SuppressWarnings("unused")
    // random
    private Random            random    = new Random();
    private CardList          allCards  = new CardList();
    
    private HashSet<String>   removedCardList;
    private Card              blankCard = new Card();                 //new code
                                                                       
    public CardFactory(String filename) {
        this(new File(filename));
    }
    
    public CardFactory(File file) {
        SpellAbility spell = new SpellAbility(SpellAbility.Spell, blankCard) {
            //neither computer nor human play can play this card
            @Override
            public boolean canPlay() {
                return false;
            }
            
            @Override
            public void resolve() {}
        };
        blankCard.addSpellAbility(spell);
        spell.setManaCost("1");
        blankCard.setName("Removed Card");
        
        //owner and controller will be wrong sometimes
        //but I don't think it will matter
        //theoretically blankCard will go to the wrong graveyard
        blankCard.setOwner(Constant.Player.Human);
        blankCard.setController(Constant.Player.Human);
        
        removedCardList = new HashSet<String>(FileUtil.readFile(ForgeProps.getFile(REMOVED)));
        

        try {
            readCards(file);
            
            // initialize CardList allCards
            Iterator<String> it = map.keySet().iterator();
            Card c;
            while(it.hasNext()) {
                c = getCard(it.next().toString(), Constant.Player.Human);
                allCards.add(c);
                //System.out.println("cardName: " + c.getName());
                
            }
        } catch(Exception ex) {
            ErrorViewer.showError(ex);
        }
    }// constructor
    
    public CardList getAllCards() {
        return new CardList(allCards.toArray());
    }// getAllCards()
    
    private void readCards(File file) {
        map.clear();
        
        ReadCard read = new ReadCard(ForgeProps.getFile(CARDS));
        try {
            read.run();
            // javax.swing.SwingUtilities.invokeAndWait(read);
        } catch(Exception ex) {
            ErrorViewer.showError(ex);
            throw new RuntimeException("CardFactory : readCards() thread error - " + ex.getMessage());
        }
        
        ArrayList<Card> simpleList = read.getCards();
        Card s;
        Iterator<Card> it = simpleList.iterator();
        while(it.hasNext()) {
            s = it.next();
            map.put(s.getName(), s);
            //System.out.println("cardName: " + s.getName());
        }
    }// readCard()
    
    final public Card copyCard(Card in) {
        Card out = getCard(in.getName(), in.getOwner());
        out.setUniqueNumber(in.getUniqueNumber());
        return out;
    }
    
    /*
    final public Card getCard(String cardName, String owner) {
        cardName = AllZone.NameChanger.getOriginalName(cardName);
        return getCard2(cardName, owner);
    }
    */

    //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //this is the new getCard() method, you have to remove the old getCard()
    final public Card getCard(String cardName, String owner) {
        if(removedCardList.contains(cardName) || cardName.equals(blankCard.getName())) return blankCard;
        
        return getCard2(cardName, owner);
    }
    
    //self-targeted power and/or toughness pumping abilities
    //-1 means "PTPump" is not found
    //any other int means that "PTPump" was found in the Card keyword
    private final int shouldPTPumpCard(Card c)
    {
      ArrayList<String> a = c.getKeyword();
      for(int i = 0; i < a.size(); i++)
        if(a.get(i).toString().startsWith("PTPump"))
          return i;

      return -1;
    }
    //same thing, for "KPump" - self-targeted keyword adding abilities
    private final int shouldKPumpCard(Card c)
    {
      ArrayList<String> a = c.getKeyword();
      for (int i = 0; i < a.size(); i++)
        if(a.get(i).toString().startsWith("KPump"))
          return i;

      return -1;
    }
    //same thing, for "PTKPump" - self-targeted power and/or toughness pumping
    //plus keyword adding abilities
    private final int shouldPTKPumpCard(Card c)
    {
      ArrayList<String> a = c.getKeyword();
      for (int i = 0; i < a.size(); i++)
        if(a.get(i).toString().startsWith("PTKPump"))
          return i;

      return -1;
    }
    
    //"TgtKPump" - targeted keyword adding abilities
    private final int shouldTgtKPumpCard(Card c)
    {
      ArrayList<String> a = c.getKeyword();
      for (int i = 0; i < a.size(); i++)
        if(a.get(i).toString().startsWith("TgtKPump"))
          return i;

      return -1;
    }

	// Check for self-regenerate ability
	private final int shouldRegenerateMe(Card c) {
		ArrayList<String> a = c.getKeyword();
		for (int i = 0; i < a.size(); i++)
			if (a.get(i).toString().startsWith("RegenerateMe"))
				return i;

		return -1;
	}

	// Check for Cycling ability
	private final int shouldCycle(Card c) {
		ArrayList<String> a = c.getKeyword();
		for (int i = 0; i < a.size(); i++)
			if (a.get(i).toString().startsWith("Cycling"))
				return i;

		return -1;
	}
	
	private final int shouldSporeSaproling(Card c) {
		ArrayList<String> a = c.getKeyword();
		for (int i = 0; i < a.size(); i++)
			if (a.get(i).toString().startsWith("Remove three spore counters"))
				return i;
		
		return -1;
	}
	
    private final int shouldSpDamageTgt(Card c) {
         ArrayList<String> a = c.getKeyword();
         for (int i = 0; i < a.size(); i++)
         {
            if (a.get(i).toString().startsWith("spDamageTgt"))
               return i;
         }
         return -1;
    }
	
	private final int shouldSpDamageCP(Card c) {
	      ArrayList<String> a = c.getKeyword();
	      for (int i = 0; i < a.size(); i++)
	      {
	         if (a.get(i).toString().startsWith("spDamageCP"))
	            return i;
	      }
	      return -1;
	}
	
	private final int shouldSpDamageP(Card c) {
	      ArrayList<String> a = c.getKeyword();
	      for (int i = 0; i < a.size(); i++)
	      {
	         if (a.get(i).toString().startsWith("spDamageP"))
	            return i;
	      }
	      return -1;
	}
	
	private final int shouldRebelSearch(Card c) {
		ArrayList<String> a = c.getKeyword();
		for (int i = 0; i < a.size(); i++)
			if (a.get(i).toString().startsWith("SearchRebel"))
				return i;
		return -1;
	}
	
	private final int shouldMercSearch(Card c) {
		ArrayList<String> a = c.getKeyword();
		for (int i = 0; i < a.size(); i++)
			if (a.get(i).toString().startsWith("SearchMerc"))
				return i;
		return -1;	
	}
	
	private final int shouldMorph(Card c) {
		ArrayList<String> a = c.getKeyword();
		for (int i = 0; i < a.size(); i++)
			if (a.get(i).toString().startsWith("Morph"))
				return i;

		return -1;
	}

	private final int shouldDevour(Card c) {
		ArrayList<String> a = c.getKeyword();
		for (int i = 0; i < a.size(); i++)
			if (a.get(i).toString().startsWith("Devour"))
				return i;

		return -1;
	}
	
    private final int shouldSpellbomb(Card c) {
        ArrayList<String> a = c.getKeyword();
        for (int i = 0; i < a.size(); i++)
           if (a.get(i).toString().startsWith("1, Sacrifice"))//
              if(a.get(i).equals("1, Sacrifice "+c.getName()+": Draw a card."))
            	  return i;
        return -1;
     }
    
    private final int shouldModular(Card c) {
        ArrayList<String> a = c.getKeyword();
        for (int i = 0; i < a.size(); i++)
        {
           if (a.get(i).toString().startsWith("Modular"))
              return i;
        }
        return -1;
  }
	
	private final int shouldUntap(Card c) {
		ArrayList<String> a = c.getKeyword();
		for (int i = 0; i < a.size(); i++)
			if (a.get(i).toString().startsWith("Untap"))
				return i;
		
		return -1;
	}	
	
	private final int shouldFlashback(Card c) {
		ArrayList<String> a = c.getKeyword();
		for (int i = 0; i < a.size(); i++)
			if (a.get(i).toString().startsWith("Flashback"))
				return i;
		
		return -1;
	}
	
	private final int shouldAbDamageCP(Card c) {
	      ArrayList<String> a = c.getKeyword();
	      for (int i = 0; i < a.size(); i++)
	      {
	         if (a.get(i).toString().startsWith("abDamageCP"))
	            return i;
	      }
	      return -1;
	}
	
	private final int shouldAbTgtPTPumpCard(Card c)
    {
       ArrayList<String> a = c.getKeyword();
       for (int i = 0; i < a.size(); i++)
          if (a.get(i).toString().startsWith("abTgtPTPump"))
             return i;
       
       return -1;
    }
	
	private final int shouldSpPumpTgt(Card c){
       ArrayList<String> a = c.getKeyword();
       for (int i = 0; i < a.size(); i++)
          if (a.get(i).toString().startsWith("spPumpTgt"))
             return i;
       
       return -1;
   }
	
	private final int shouldSpDestroyTgt(Card c){
	       ArrayList<String> a = c.getKeyword();
	       for (int i = 0; i < a.size(); i++)
	          if (a.get(i).toString().startsWith("spDestroyTgt:"))
	             return i;
	       
	       return -1;
	}
	
	private final int shouldSpDrawCards(Card c){
	       ArrayList<String> a = c.getKeyword();
	       for (int i = 0; i < a.size(); i++)
	          if (a.get(i).toString().startsWith("spDrawCards"))
	             return i;
	       
	       return -1;
	}
	
   // spLoseLifeGainLife
   private final int shouldSpLoseLifeGainLife(Card c){
          ArrayList<String> a = c.getKeyword();
          for (int i = 0; i < a.size(); i++)
             if (a.get(i).toString().startsWith("spLoseLifeGainLife"))
                return i;
          
          return -1;
   }
    
    private final int shouldManaAbility(Card c){
        ArrayList<String> a = c.getIntrinsicKeyword();
        for (int i = 0; i < a.size(); i++)
           if (a.get(i).toString().contains(": add "))
              return i;
       
        return -1;
    }
	
	
	final private Card getCard2(final String cardName, final String owner)
  {
    //o should be Card object
    Object o = map.get(cardName);
    if(o == null)
      throw new RuntimeException("CardFactory : getCard() invalid card name - " +cardName);

    final Card card = copyStats(o);
    card.setOwner(owner);
    card.setController(owner);
    //may have to change the spell
    //this is so permanents like creatures and artifacts have a "default" spell
    if(! card.isLand())
      card.addSpellAbility(new Spell_Permanent(card));
    
  //look for "Comes into play tapped." in the "no text" line
    //of card.txt and add the appropriate code to make that happen
    if(card.getKeyword().contains("Comes into play tapped."))
    {
      card.addComesIntoPlayCommand(new Command()
      {
		private static final long serialVersionUID = 203335252453049234L;

		public void execute()
        {
          card.tap();
        }
      });
    }//if "Comes into play tapped."

  //Creatures with simple, self-targeted mana-activated keyword adding abilities
    //-1 means not found
    while(shouldKPumpCard(card) != -1)
    {
      int n = shouldKPumpCard(card);
      if(n != -1)
      {
        String parse = card.getKeyword().get(n).toString();
        card.removeIntrinsicKeyword(parse);

        String k[] = parse.split(":");

        final String manaCost = k[0].substring(6);
        final String keyword = k[1];

        final Command untilEOT = new Command()
        {
			private static final long serialVersionUID = -2904643243256352517L;

		public void execute()
          {
            if(AllZone.GameAction.isCardInPlay(card))
            {
              card.removeIntrinsicKeyword(keyword);
            }
          }
        };

        SpellAbility ability = new Ability_Activated(card, manaCost)
        {
			private static final long serialVersionUID = -630655617339584299L;
			
			public boolean canPlayAI()
	        {
	             //in case if a lifelink pump, allow multiple pumps
	             if (CardFactoryUtil.AI_doesCreatureAttack(card) &&
	                !card.getKeyword().contains(keyword))
	             {
	                Random r = new Random();
	                  if (r.nextFloat() <= Math.pow(.6667, card.getAbilityUsed()))
	                     return true;
	                  else
	                     return false;
	             }
	             else
	                return false;
	        }
          public boolean canPlay()
          {
        	  if (CardFactoryUtil.canUseAbility(card) && AllZone.GameAction.isCardInPlay(card))
          		return true;
          	else 
          		return false;
          }
          public void resolve()
          {
            if(AllZone.GameAction.isCardInPlay(card))
            {
              card.addIntrinsicKeyword(keyword);
             
              card.setAbilityUsed(card.getAbilityUsed()+1);

              AllZone.EndOfTurn.addUntil(untilEOT);
            }
          }
        };

        String Desc = new String();
        Desc = cardName + " gains " + keyword + " until end of turn.";

        ability.setDescription(manaCost + " : " + Desc);
        ability.setStackDescription(Desc);

        card.addSpellAbility(ability);
      }//if (should pump card)
    }//while - card has more pump keywords - Blistering Dieflyn has two pump keywords


      //Creatures with simple, self-targeted mana-activated power and/or toughness
      //pumping abilities
      //is the card  "self pumper" like Furnace Whelp - this card gets +1/+1 until end of turn?
      //-1 means not found
      while(shouldPTPumpCard(card) != -1)
      {
        int n = shouldPTPumpCard(card);
        if(n != -1)
        {
          String parse = card.getKeyword().get(n).toString();
          card.removeIntrinsicKeyword(parse);

          final int attack[] = new int[1];
          final int defense[] = new int[1];

          String k[] = parse.split(":");
          String pt[] = k[1].split("/");

          final String manaCost = k[0].substring(7);
          
          
          Integer na = card.getNetAttack();
          Integer nd = card.getNetDefense();

          pt[0].replace("p", na.toString());
          pt[0].replace("t", nd.toString());
         
          pt[1].replace("p", na.toString());
          pt[1].replace("t", nd.toString());
          
          attack[0] = Integer.parseInt(pt[0].replace("+", ""));
          defense[0] = Integer.parseInt(pt[1].replace("+", ""));


          final Command untilEOT = new Command()
          {
			private static final long serialVersionUID = -4518618729662470596L;
            public void execute()
            {
              if(AllZone.GameAction.isCardInPlay(card))
              {
                card.addTempAttackBoost(-attack[0]);
                card.addTempDefenseBoost(-defense[0]);
              }
            }
          };

          SpellAbility ability = new Ability_Activated(card, manaCost)
          {
			private static final long serialVersionUID = -5718931378326228534L;
			
			public boolean canPlayAI()
            {
                if (card.getNetDefense() + defense[0] < 1) // no point if it would kill the creature outright
                    return false;
                return CardFactoryUtil.AI_doesCreatureAttack(card);
            }
            public boolean canPlay()
            {
            	if (CardFactoryUtil.canUseAbility(card) && AllZone.GameAction.isCardInPlay(card) && 
            		!card.isFaceDown())
            		return true;
            	else 
            		return false;
            }
            public void resolve()
            {
              if(AllZone.GameAction.isCardInPlay(card))
              {
                card.addTempAttackBoost(attack[0]);
                card.addTempDefenseBoost(defense[0]);
               
                card.setAbilityUsed(card.getAbilityUsed()+1);

                AllZone.EndOfTurn.addUntil(untilEOT);
              }
            }
          };
          
          String Desc = new String();
          Desc = cardName + " gets ";
          if (attack[0] > 0)
              Desc = Desc + "+" + attack[0];
          else
              Desc = Desc + attack[0];
          Desc = Desc + "/";
          if (defense[0] > 0)
              Desc = Desc + "+" + defense[0];
          else
              Desc = Desc + defense[0];
          Desc = Desc + " until end of turn.";

          ability.setDescription(manaCost + " : " + Desc);
          ability.setStackDescription(Desc);

          card.addSpellAbility(ability);
        }//if (should pump card)
      }//while - card has more pump keywords - Blistering Dieflyn has two pump keywords

      //Creatures with simple, self-targeted mana-activated power and/or toughness
      //pumping plus keyword adding abilities
      //is the card  "self pumper" like Furnance Whelp - this card gets +1/+1 until end of turn?
      //-1 means not found
      while(shouldPTKPumpCard(card) != -1)
      {
        int n = shouldPTKPumpCard(card);
        if(n != -1)
        {
          String parse = card.getKeyword().get(n).toString();
          card.removeIntrinsicKeyword(parse);
   
          final int attack[] = new int[1];
          final int defense[] = new int[1];

          String k[] = parse.split(":");
          String ptk[] = k[1].split("/");

          final String manaCost = k[0].substring(8);
                   	
          attack[0] = Integer.parseInt(ptk[0].replace("+", ""));
          defense[0] = Integer.parseInt(ptk[1].replace("+", ""));
          final String keyword = ptk[2];
          
  
          
          final Command untilEOT = new Command()
          {
			private static final long serialVersionUID = -3554196069508466753L;

			public void execute()
            {
              if(AllZone.GameAction.isCardInPlay(card))
              {
                card.removeIntrinsicKeyword(keyword);
                card.addTempAttackBoost(-attack[0]);
                card.addTempDefenseBoost(-defense[0]);

              }
            }
          };
   
          SpellAbility ability = new Ability_Activated(card, manaCost)
          {
			private static final long serialVersionUID = 4196412133232530875L;
			
			public boolean canPlayAI()
              {
                  if (card.getNetDefense() + defense[0] < 1) // no point if it would kill the creature outright
                      return false;
                 
                  if (card.getKeyword().contains(keyword))
                     return false;
                 
                  return CardFactoryUtil.AI_doesCreatureAttack(card);
              }
            public boolean canPlay()
            {
            	if (CardFactoryUtil.canUseAbility(card) && AllZone.GameAction.isCardInPlay(card) &&
            		!card.isFaceDown())
            		return true;
            	else 
            		return false;
            }
            public void resolve()
            {
              if(AllZone.GameAction.isCardInPlay(card))
              {
                card.addIntrinsicKeyword(keyword);
                card.addTempAttackBoost(attack[0]);
                card.addTempDefenseBoost(defense[0]);
                
                card.setAbilityUsed(card.getAbilityUsed()+1);

                AllZone.EndOfTurn.addUntil(untilEOT);
              }
            }
          };
          
   
          String Desc = new String();
          Desc = cardName + " gets ";
          if (attack[0] > 0)
              Desc = Desc + "+" + attack[0];
          else
              Desc = Desc + attack[0];
          Desc = Desc + "/";
          if (defense[0] > 0)
              Desc = Desc + "+" + defense[0];
          else
              Desc = Desc + defense[0];
          Desc = Desc + " and gains " + keyword + " until end of turn.";
   
          ability.setDescription(manaCost + " : " + Desc);
          ability.setStackDescription(Desc);
   
          card.addSpellAbility(ability);
        }//if (should pump card)
      }//while - card has more pump keywords - Blistering Dieflyn has two pump keywords
      
    //Creatures with simple, targeted keyword adding abilities
      // costs may include "T" to indicate a tap cost
      //-1 means not found
      while(shouldTgtKPumpCard(card) != -1)
      {
        int n = shouldTgtKPumpCard(card);
        if(n != -1)
        {
          String parse = card.getKeyword().get(n).toString();
          card.removeIntrinsicKeyword(parse);

          String k[] = parse.split(":");

          String tmpCost = k[0].substring(9);
          final String keyword = k[1];
         
          boolean tapCost = false;
          boolean tapOnlyCost = false;
         
          if (tmpCost.contains("T"))
          {
             tapCost = true;
             tmpCost = tmpCost.replace("T", "");
             tmpCost = tmpCost.trim();
             if (tmpCost.length() == 0)
                tapOnlyCost = true;
          }
         
          final String manaCost = tmpCost;
         
          String tempDesc = new String();
          tempDesc = "Target creature gains " + keyword + " until end of turn.";
          final String Desc = tempDesc;
         
          if (! tapCost)
          {
              final SpellAbility ability = new Ability_Activated(card, manaCost)
              {

            private static final long serialVersionUID = -1118592153328758083L;
            
            public boolean canPlayAI()
                {
                  //if(CardFactoryUtil.AI_doesCreatureAttack(card))
                  //  return false;
              CardList list = getCreature();
              if (list.isEmpty())
                 return false;
              else
              {
                 Random r = new Random();
                 if (r.nextFloat() <= Math.pow(.6667, card.getAbilityUsed()))
                    return true;
                 else
                    return false;
              }
                }
            
            
                public boolean canPlay()
                {
               
                   if (CardFactoryUtil.canUseAbility(card) && AllZone.GameAction.isCardInPlay(card)&&
                      !card.isFaceDown())
                      return true;
                   else
                      return false;
                }
                public void chooseTargetAI()
                {
                  Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
                  setTargetCard(target);
                }
                CardList getCreature()
                {
                  CardList list = new CardList(AllZone.Computer_Play.getCards());
                  list = list.filter(new CardListFilter()
                  {
                    public boolean addCard(Card c)
                    {
                      return c.isCreature() &&
                            (!CardFactoryUtil.AI_doesCreatureAttack(c)) && CardFactoryUtil.canTarget(card, c) &&
                            (! c.getKeyword().contains(keyword)) &&
                            (! c.getKeyword().contains("Defender")) &&
                            (! c.hasSickness() && keyword.equals("Haste"));
                    }
                  });
                  // list.remove(card);      // if mana-only cost, allow self-target
                  return list;
                }//getCreature()
                public void resolve()
                {
                  if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
                  {
                    final Card[] creature = new Card[1];
                    final Command EOT = new Command()
                    {
                  private static final long serialVersionUID = -8840812331316327448L;

               public void execute()
                      {
                        if(AllZone.GameAction.isCardInPlay(creature[0]))
                          creature[0].removeExtrinsicKeyword(keyword);
                      }
                    };
                    creature[0] = getTargetCard();
                    creature[0].addExtrinsicKeyword(keyword);
                    card.setAbilityUsed(card.getAbilityUsed()+1);
                    AllZone.EndOfTurn.addUntil(EOT);
                  }//if (card is in play)
                }//resolve()
              };//SpellAbility
             
              ability.setDescription(manaCost + ":" + Desc);
              ability.setStackDescription(Desc);

              ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
              card.addSpellAbility(ability);
          }
          if (tapOnlyCost)
          {
              final SpellAbility ability = new Ability_Tap(card)
              {
            private static final long serialVersionUID = 5252594757468128739L;
            
            public boolean canPlayAI()
                {
                  if(CardFactoryUtil.AI_doesCreatureAttack(card))
                    return false;
                 
                  return getCreature().size() != 0;
                }
                public boolean canPlay()
                {
                   boolean sick = true;
                   
                   if (!card.hasSickness() || !card.isCreature())
                       sick = false;
                   
                   if (card.isUntapped() && CardFactoryUtil.canUseAbility(card) && AllZone.GameAction.isCardInPlay(card)
                       && !sick && !card.isFaceDown())
                      return true;
                   else
                      return false;
                }
                public void chooseTargetAI()
                {
                   card.tap();
                   Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
                   setTargetCard(target);
                }
                CardList getCreature()
                {
                  CardList list = new CardList(AllZone.Computer_Play.getCards());
                  list = list.filter(new CardListFilter()
                  {
                    public boolean addCard(Card c)
                    {
                      return c.isCreature() &&
                            (!CardFactoryUtil.AI_doesCreatureAttack(c)) &&
                            (! c.getKeyword().contains(keyword)) &&
                            (! c.getKeyword().contains("Defender")) &&
                            (! c.hasSickness() && keyword.equals("Haste"));
                    }
                  });
                  list.remove(card);
                  return list;
                }//getCreature()
                public void resolve()
                {
                  if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
                  {
                    final Card[] creature = new Card[1];
                    final Command EOT = new Command()
                    {
                  private static final long serialVersionUID = 2134353417588894452L;

               public void execute()
                      {
                        if(AllZone.GameAction.isCardInPlay(creature[0]))
                          creature[0].removeExtrinsicKeyword(keyword);
                      }
                    };
                    creature[0] = getTargetCard();
                    creature[0].addExtrinsicKeyword(keyword);
                    AllZone.EndOfTurn.addUntil(EOT);
                  }//if (card is in play)
                }//resolve()
              };//SpellAbility
             
              ability.setDescription("tap:" + Desc);
              ability.setStackDescription(Desc);

              ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
              card.addSpellAbility(ability);
          }
          if (! tapOnlyCost && tapCost)
          {
              final SpellAbility ability = new Ability_Tap(card, manaCost)
              {
            private static final long serialVersionUID = 7593387152288440603L;
            
            public boolean canPlayAI()
                {
                  if(CardFactoryUtil.AI_doesCreatureAttack(card))
                    return false;
                 
                  return getCreature().size() != 0;
                }
                public boolean canPlay()
                {
                   boolean sick = true;
                   
                   if (!card.hasSickness() || !card.isCreature())
                      sick = false;
                   
                   if (card.isUntapped() && CardFactoryUtil.canUseAbility(card) && AllZone.GameAction.isCardInPlay(card) &&
                     !sick && !card.isFaceDown())
                      return true;
                   else
                      return false;
                }
                public void chooseTargetAI()
                {
                   card.tap();
                   Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
                   setTargetCard(target);
                }
                CardList getCreature()
                {
                  CardList list = new CardList(AllZone.Computer_Play.getCards());
                  list = list.filter(new CardListFilter()
                  {
                    public boolean addCard(Card c)
                    {
                      return c.isCreature() &&
                            (!CardFactoryUtil.AI_doesCreatureAttack(c)) &&
                            (! c.getKeyword().contains(keyword)) &&
                            (! c.getKeyword().contains("Defender")) &&
                            (! c.hasSickness() && keyword.equals("Haste"));
                    }
                  });
                  list.remove(card);
                  return list;
                }//getCreature()
                public void resolve()
                {
                  if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card ,getTargetCard()))
                  {
                    final Card[] creature = new Card[1];
                    final Command EOT = new Command()
                    {
                  private static final long serialVersionUID = 3532917180149273560L;

               public void execute()
                      {
                        if(AllZone.GameAction.isCardInPlay(creature[0]))
                          creature[0].removeExtrinsicKeyword(keyword);
                      }
                    };
                    creature[0] = getTargetCard();
                    creature[0].addExtrinsicKeyword(keyword);
                    AllZone.EndOfTurn.addUntil(EOT);
                  }//if (card is in play)
                }//resolve()
              };//SpellAbility
             
              ability.setDescription(manaCost + ", tap:" + Desc);
              ability.setStackDescription(Desc);

              ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
              card.addSpellAbility(ability);
          }
        }
      }//while

    
    //Creatures with self-regenerate abilities
    //-1 means keyword "RegenerateMe" not found
    while (shouldRegenerateMe(card) != -1)
    {
      int n = shouldRegenerateMe(card);
      if (n != -1)
      {
        String parse = card.getKeyword().get(n).toString();
        card.removeIntrinsicKeyword(parse);

        String k[] = parse.split(":");
        final String manacost = k[1];

        final Command untilEOT = new Command() {
          private static final long serialVersionUID = -7619842476705984912L;

          public void execute()
          {
            card.setShield(0);
            
          }
        };

        final SpellAbility a1 = new Ability(card, manacost) {
          public boolean canPlayAI()
          {
            if (CardFactoryUtil.AI_isMainPhase())
            {
              if (CardFactoryUtil.AI_doesCreatureAttack(card))
              {
                //"Fuzzy logic" to determine if using a regenerate ability might be helpful because
                //we can't wait to decide to play this ability during combat, like the human can
                //weight[] is a set of probability percentages to be averaged later
                int weight[] = new int[3];

                // cards with real keywords (flying, trample, etc) are probably more desireable
                if (card.getKeyword().size() > 0)
                  weight[0] = 75;
                else
                  weight[0] = 0;

                // if there are many cards in hand, then maybe it's not such a great idea to waste mana
                CardList HandList = new CardList(AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer).getCards());

                if (HandList.size() >= 4)
                  weight[1] = 25;
                else
                  weight[1] = 75;

                // compare the highest converted mana cost of cards in hand to the number of lands
                // if there's spare mana, then regeneration might be viable
                int hCMC = 0;
                for (int i = 0; i < HandList.size(); i++)
                  if (CardUtil.getConvertedManaCost(HandList.getCard(i).getManaCost()) > hCMC)
                    hCMC = CardUtil.getConvertedManaCost(HandList.getCard(i).getManaCost());

                CardList LandList = new CardList(AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer).getCards());
                LandList = LandList.getType("Land");

                //most regenerate abilities cost 2 or less
                if (hCMC + 2 >= LandList.size())
                  weight[2] = 50;
                else
                  weight[2] = 0;

                // ultimately, it's random fate that dictates if this was the right play
                int aw = (weight[0] + weight[1] + weight[2]) / 3;
                Random r = new Random();
                if (r.nextInt(100) <= aw)
                  return true;
              }
            }
            return false;
          }

          public void resolve()
          {
            card.addShield();
            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }; //SpellAbility

        card.addSpellAbility(a1);

        String Desc = new String();
        Desc = "Regenerate " + cardName;

        a1.setDescription(manacost + " : " + Desc);
        a1.setStackDescription(Desc);

        a1.setBeforePayMana(new Input_PayManaCost(a1));
      } //if (should RegenerateMe)
    } //while - card has more RegenerateMe - Jungle Troll has two Regenerate keywords


    if (shouldUntap(card) != -1)
    {
    	int n = shouldUntap(card);
    	if (n != -1)
    	{
    		String parse = card.getKeyword().get(n).toString();
            card.removeIntrinsicKeyword(parse);
            
            String k[] = parse.split(":");
            final String manacost = k[1];
            
            card.addSpellAbility(CardFactoryUtil.ability_Untap(card, manacost));            
    	}
    }
    
    if (shouldSporeSaproling(card) != -1)
    {
      int n = shouldSporeSaproling(card);
      if (n != -1)
      {
    	String parse = card.getKeyword().get(n).toString();
        card.removeIntrinsicKeyword(parse);
        
        card.addSpellAbility(CardFactoryUtil.ability_Spore_Saproling(card));
      }
    }//Spore Saproling
    
    if (shouldSpDamageTgt(card)  != -1)
    {
       int n = shouldSpDamageTgt(card);
       if (n != -1)
       {
          String parse = card.getKeyword().get(n).toString();
          card.removeIntrinsicKeyword(parse);
                   
          card.clearSpellAbility();
         
          String k[] = parse.split(":");
         
          final boolean TgtCreature[] = {false};
          final boolean TgtPlayer[] = {false};
          final boolean TgtCP[] = {false};
         
          if (k[0].contains("CP"))
             TgtCP[0] = true;
          else if (k[0].contains("P"))
             TgtPlayer[0] = true;
          else if (k[0].contains("C"))
             TgtCreature[0] = true;
         
          // how much damage
        final int NumDmg[] = {-1};
          final String NumDmgX[] = {"none"};

          if (k[1].length() <= 2)      // numeric
             NumDmg[0] = Integer.parseInt(k[1]);
          else                     // result of some sort of function
          {
             if (k[1].startsWith("Count$"))
             {
                String kk[] = k[1].split("\\$");
                NumDmgX[0] = kk[1];
             }
          }
         
          //drawbacks and descriptions
          final String DrawBack[] = {"none"};
          final String spDesc[] = {"none"};
          final String stDesc[] = {"none"};
          if (k.length > 2)
          {
             if (k[2].contains("Drawback$"))
             {
                String kk[] = k[2].split("\\$");
                DrawBack[0] = kk[1];
                if (k.length > 3)
                   spDesc[0] = k[3];
                if (k.length > 4)
                   stDesc[0] = k[4];
             }
             else
             {
                if (k.length > 2)
                   spDesc[0] = k[2];
                if (k.length > 3)
                   stDesc[0] = k[3];
             }
          }
         
          final SpellAbility DamageTgt = new Spell(card)
          {
             private static final long serialVersionUID = 7239608350643325111L;
             private int damage;

             public int getNumDamage()
             {
                if (NumDmg[0] != -1)
                   return NumDmg[0];

                if (! NumDmgX[0].equals("none"))
                   return CardFactoryUtil.xCount(card, NumDmgX[0]);

                return 0;
             }
            
             boolean shouldTgtP()
             {
                PlayerZone compHand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
                CardList hand = new CardList(compHand.getCards());

                if (hand.size() >= 7)      // anti-discard-at-EOT
                   return true;
               
                if(AllZone.Human_Life.getLife() < (10 - damage))   // if damage from this spell would drop the human to less than 10 life
                   return true;
               
                return false;
             }
            
             Card chooseTgtC()
             {
                // Combo alert!!
              PlayerZone compy = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
                CardList cPlay = new CardList(compy.getCards());
                if (cPlay.size() > 0)
                   for (int i = 0; i < cPlay.size(); i++)
                      if (cPlay.get(i).getName().equals("Stuffy Doll"))
                         return cPlay.get(i);
               
                PlayerZone human = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
              CardList hPlay = new CardList(human.getCards());
              hPlay = hPlay.filter(new CardListFilter()
               {
                  public boolean addCard(Card c)
                  {
                     // will include creatures already dealt damage
                     return c.isCreature() && ((c.getNetDefense() + c.getDamage()) <= damage) && CardFactoryUtil.canTarget(card, c);
                  }
               }
              );
             
                if (hPlay.size() > 0)
                {
                   Card best = hPlay.get(0);
               
                   if (hPlay.size() > 1)
                   {
                      for (int i = 1; i < hPlay.size(); i++)
                      {
                         Card b = hPlay.get(i);
                         // choose best overall creature?
                       if (b.getSpellAbility().length > best.getSpellAbility().length ||
                               b.getKeyword().size() > best.getKeyword().size() ||
                               b.getNetAttack() > best.getNetAttack())
                            best = b;
                      }
                   }
                  
                   return best;
                }
                  
                return null;
             }
            
             public boolean canPlayAI()
             {
                damage = getNumDamage();
               
                if (TgtCP[0] == true)
                {
                   if (shouldTgtP() == true)
                   {
                      setTargetPlayer(Constant.Player.Human);
                      return true;
                   }
                  
                   Card c = chooseTgtC();
                   if (c != null)
                   {
                      setTargetCard(c);
                      return true;
                   }
                }
               
                if (TgtPlayer[0] == true)
                {
                   setTargetPlayer(Constant.Player.Human);
                   return shouldTgtP();
                }
               
                if (TgtCreature[0] == true)
                {
                   Card c = chooseTgtC();
                   if (c != null)
                   {
                      setTargetCard(c);
                      return c != null;
                   }
                }
               
                return false;               
             }

             public void resolve()
             {
                damage = getNumDamage();
                String tgtP = new String();
               
                if(getTargetCard() != null)
                {
                   if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
                   {
                      Card c = getTargetCard();
                      //c.addDamage(damage);
                      AllZone.GameAction.addDamage(c, damage);
                      tgtP = c.getController();
                   }
                }
                else
                {
                   AllZone.GameAction.addDamage(getTargetPlayer(), damage);
                   tgtP = getTargetPlayer();
                }

                if (! DrawBack[0].equals("none"))
                   CardFactoryUtil.doDrawBack(DrawBack[0], damage, card.getController(), AllZone.GameAction.getOpponent(card.getController()), tgtP, card, getTargetCard());
             }// resolove
          }; //spellAbility
          if (! spDesc[0].equals("none"))
              DamageTgt.setDescription(spDesc[0]);
            else
            {
              String s;
              s = card.getName() + " deals " + NumDmg[0] + " damage to target";
              if (TgtCP[0])
                s = s + " creature or player.";
              else if (TgtCreature[0])
                s = s + " creature.";
              else if (TgtPlayer[0])
                s = s + " player.";
              DamageTgt.setDescription(s);
            }

            if (! stDesc[0].equals("none"))
              DamageTgt.setStackDescription(stDesc[0]);
            else
              DamageTgt.setStackDescription(card.getName() + " - deals " + NumDmg[0] + " damage.");

          if (TgtCP[0])
             DamageTgt.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(DamageTgt, true));
          else if (TgtCreature[0])
             DamageTgt.setBeforePayMana(CardFactoryUtil.input_targetCreature(DamageTgt));
          else if (TgtPlayer[0])
             DamageTgt.setBeforePayMana(CardFactoryUtil.input_targetPlayer(DamageTgt));

        card.addSpellAbility(DamageTgt);
       }
    }// spDamageTgt

    
    //Spell damage cards  CP means Computer and Player (like shock, Lightning Bolt)
    if (shouldSpDamageCP(card)  != -1)
    {
       int n = shouldSpDamageCP(card);
       if (n != -1)
       {
          String parse = card.getKeyword().get(n).toString();
          //System.out.println("parse: " + parse);
          card.removeIntrinsicKeyword(parse);
                    
          card.clearSpellAbility();
          
          String k[] = parse.split(":");
          final String dmg = k[1];
          
          card.addSpellAbility(CardFactoryUtil.spellability_spDamageCP(card, dmg));
       }
    }
    
    if (shouldSpDamageP(card) != -1)
    {
       int n = shouldSpDamageP(card);
       if (n != -1)
       {
          String parse = card.getKeyword().get(n).toString();
          card.removePrevIntrinsicKeyword(parse);
       
          card.clearSpellAbility();
       
          String k[] = parse.split(":");
          final String dmg = k[1];
       
          card.addSpellAbility(CardFactoryUtil.spellability_spDamageP(card, dmg));
       }
    }//SpDamageP
    
    if (shouldAbDamageCP(card) != -1)
    {
       int n = shouldAbDamageCP(card);
       if (n != -1)
       {
          String parse = card.getKeyword().get(n).toString();
          card.removeIntrinsicKeyword(parse);
          
          String k[] = parse.split(":");

            String tmpCost = k[0].substring(11);
           
            final int dmg[] = new int[1];
            dmg[0] = Integer.parseInt(k[1]);
           
            boolean tapCost = false;
            boolean tapOnlyCost = false;
           
            if (tmpCost.contains("T"))
            {
               tapCost = true;
               tmpCost = tmpCost.replace("T", "");
               tmpCost = tmpCost.trim();
               if (tmpCost.length() == 0)
                  tapOnlyCost = true;
            }
           
            final String manaCost = tmpCost;
           
            String tempDesc = new String();
            tempDesc = cardName + " deals " + dmg[0] + " damage to target creature or player.";
            final String Desc = tempDesc;

            if (! tapCost)
            {
               final SpellAbility ability = new Ability_Activated(card, manaCost)
               {
                 private static final long serialVersionUID = -7560349014757367722L;
                
                 public boolean canPlayAI()
                 {
                    Random r = new Random();
                    if (r.nextFloat() <= Math.pow(.6667, card.getAbilityUsed()))
                       return true;
                    else
                       return false;
                 }
                
                 public void chooseTargetAI()
                 {
                   CardList list = CardFactoryUtil.AI_getHumanCreature(dmg[0], card, true);
                   list.shuffle();
   
                   if(list.isEmpty() || AllZone.Human_Life.getLife() < 5 + dmg[0])
                     setTargetPlayer(Constant.Player.Human);
                   else
                     setTargetCard(list.get(0));
                 }//chooseTargetAI
                
                 public void resolve()
                 {
                   if(getTargetCard() != null)
                   {
                     if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) ) {
                       getTargetCard().addDamage(dmg[0]);
                       if (card.getKeyword().contains("Lifelink"))
                    	   GameActionUtil.executeLifeLinkEffects(card, dmg[0]);
                       for(int i=0; i < CardFactoryUtil.hasNumberEnchantments(card, "Guilty Conscience"); i++)
                    	   GameActionUtil.executeGuiltyConscienceEffects(card, dmg[0]);
                     }
                   }
                   else {
                     AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(dmg[0]);
                     if (card.getKeyword().contains("Lifelink"))
                    	 GameActionUtil.executeLifeLinkEffects(card, dmg[0]);
                     for(int i=0; i < CardFactoryUtil.hasNumberEnchantments(card, "Guilty Conscience"); i++)
                  	   GameActionUtil.executeGuiltyConscienceEffects(card, dmg[0]);
                   }
                 }//resolve()
               };//Ability_Activated
               
               ability.setDescription(manaCost + ": " + Desc);
               ability.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(ability, true));
               card.addSpellAbility(ability);
            }//!tapCost
           
            if (tapOnlyCost == true)
            {
               final Ability_Tap ability = new Ability_Tap(card)
               {
                 private static final long serialVersionUID = -7560349014757367722L;
                
                 public void chooseTargetAI()
                 {
                   CardList list = CardFactoryUtil.AI_getHumanCreature(1, card, true);
                   list.shuffle();
   
                   if(list.isEmpty() || AllZone.Human_Life.getLife() < 5 + dmg[0])
                     setTargetPlayer(Constant.Player.Human);
                   else
                     setTargetCard(list.get(0));
                 }//chooseTargetAI
                
                 public void resolve()
                 {
                   if(getTargetCard() != null)
                   {
                     if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
                     {
                       getTargetCard().addDamage(dmg[0]);
                       if (card.getKeyword().contains("Lifelink"))
                    	   GameActionUtil.executeLifeLinkEffects(card, dmg[0]); 
                       for(int i=0; i < CardFactoryUtil.hasNumberEnchantments(card, "Guilty Conscience"); i++)
                    	   GameActionUtil.executeGuiltyConscienceEffects(card, dmg[0]);   
                       
                     }
                   }
                   else {
                     AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(dmg[0]);
                     if (card.getKeyword().contains("Lifelink"))
                    	 GameActionUtil.executeLifeLinkEffects(card, dmg[0]);
                     for(int i=0; i < CardFactoryUtil.hasNumberEnchantments(card, "Guilty Conscience"); i++)
                  	   GameActionUtil.executeGuiltyConscienceEffects(card, dmg[0]);
                     
                     card.setDealtDmgToOppThisTurn(true);
                   }
                 }//resolve()
               };//Ability_Tap
           
               ability.setDescription("tap: " + Desc);
               ability.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(ability, true));
               card.addSpellAbility(ability);
          }//tapOnlyCost
         
          if (! tapOnlyCost && tapCost)
          {
             final SpellAbility ability = new Ability_Tap(card, manaCost)
             {
                 private static final long serialVersionUID = -7560349014757367722L;
                
                 public void chooseTargetAI()
                 {
                   CardList list = CardFactoryUtil.AI_getHumanCreature(1, card, true);
                   list.shuffle();
   
                   if(list.isEmpty() || AllZone.Human_Life.getLife() < 5 + dmg[0])
                     setTargetPlayer(Constant.Player.Human);
                   else
                     setTargetCard(list.get(0));
                 }//chooseTargetAI
                
                 public void resolve()
                 {
                   if(getTargetCard() != null)
                   {
                     if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) ) {
                       getTargetCard().addDamage(dmg[0]);
                       if (card.getKeyword().contains("Lifelink"))
                    	   GameActionUtil.executeLifeLinkEffects(card, dmg[0]);
                       for(int i=0; i < CardFactoryUtil.hasNumberEnchantments(card, "Guilty Conscience"); i++)
                    	   GameActionUtil.executeGuiltyConscienceEffects(card, dmg[0]);
                   	 }
                   }
                   else {
                     AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(dmg[0]);
                     if (card.getKeyword().contains("Lifelink"))
                    	 GameActionUtil.executeLifeLinkEffects(card, dmg[0]);
                     for(int i=0; i < CardFactoryUtil.hasNumberEnchantments(card, "Guilty Conscience"); i++)
                  	   GameActionUtil.executeGuiltyConscienceEffects(card, dmg[0]);
                     
                     card.setDealtDmgToOppThisTurn(true);
                   }
                 }//resolve()
               };//Ability_Tap
           
               ability.setDescription(manaCost + ", tap: " + Desc);
               ability.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(ability, true));
               card.addSpellAbility(ability);               
          }//!tapOnlyCost && tapCost
       }//n       
    }//AbDamageCP
    
    
    while (shouldAbTgtPTPumpCard(card) != -1)
    {
     int n = shouldAbTgtPTPumpCard(card);
     if (n != -1)
     {
        String parse = card.getKeyword().get(n).toString();
        card.removeIntrinsicKeyword(parse);
        
        String k[] = parse.split(":");
        String pt[] = k[1].split("/");
        
          final int attack[] = new int[1];
          final int defense[] = new int[1];
                   
          attack[0] = Integer.parseInt(pt[0].replace("+", ""));
          defense[0] = Integer.parseInt(pt[1].replace("+", ""));

        String tmpCost = k[0].substring(11);
        boolean tapCost = false;
        boolean tapOnlyCost = false;
        
        if (tmpCost.contains("T"))
        {
           tapCost = true;
              tmpCost = tmpCost.replace("T", "");
              tmpCost = tmpCost.trim();
              if (tmpCost.length() == 0)
                 tapOnlyCost = true;
           }
         
           final String manaCost = tmpCost;
           //System.out.println("manaCost is " + manaCost + " for " + card.getName());
         
           String tmpDesc = new String();
           tmpDesc = "Target creature gets ";
           if (attack[0] > 0)
               tmpDesc = tmpDesc + "+" + attack[0];
           else
               tmpDesc = tmpDesc + attack[0];
           tmpDesc = tmpDesc + "/";
           if (defense[0] > 0)
               tmpDesc = tmpDesc + "+" + defense[0];
           else
               tmpDesc = tmpDesc + defense[0];
           tmpDesc = tmpDesc + " until end of turn.";
           final String Desc = tmpDesc;
           
           if (!tapCost)
           {
              final SpellAbility ability = new Ability_Activated(card, manaCost)
              {
             private static final long serialVersionUID = -845173064437485113L;
             
             public boolean canPlay()
                 {
                    if (CardFactoryUtil.canUseAbility(card) && AllZone.GameAction.isCardInPlay(card) &&
                          !card.isFaceDown())
                       return true;
                    else
                       return false;
                 }
                 public boolean canPlayAI()
                 {
                    CardList list = getAttackers();
                    if (list.isEmpty())
                       return false;
                    else
                    {
                       if (list.get(0).getNetDefense() + defense[0] < 1)
                          return false;
                          Random r = new Random();
                          if (r.nextFloat() <= Math.pow(.6667, card.getAbilityUsed()))
                          {
                             setTargetCard(list.get(0));
                             return true;
                          }
                          else
                             return false;
                    }
                 }//canPlayAI
                 public CardList getAttackers()
                 {
                    Card[] c = ComputerUtil.getAttackers().getAttackers();
                    CardList list = new CardList(c);
                   
                    return list;
                 }//getAttacker
                 public void resolve()
                 {
                    if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
                    {
                       final Card[] creature = new Card[1];
                      
                       creature[0] = getTargetCard();
                       creature[0].addTempAttackBoost(attack[0]);
                       creature[0].addTempDefenseBoost(defense[0]);
                      
                       card.setAbilityUsed(card.getAbilityUsed()+1);
                      
                        final Command EOT = new Command()
                        {
                      private static final long serialVersionUID = 122944434978198700L;

                      public void execute()
                           {
                              if (AllZone.GameAction.isCardInPlay(creature[0]))
                              {
                                 creature[0].addTempAttackBoost(-attack[0]);
                                 creature[0].addTempDefenseBoost(-defense[0]);
                              }
                           }
                        };//EOT
                        AllZone.EndOfTurn.addUntil(EOT);
                    }
                 }//resolve
              };//ability
              ability.setDescription(manaCost+": "+Desc);
              ability.setStackDescription(Desc);
              ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
              card.addSpellAbility(ability);
           }//!tapCost
           
           if (tapOnlyCost)
           {
              final SpellAbility ability = new Ability_Tap(card)
              {
             private static final long serialVersionUID = 6723777240105966031L;
             
             public boolean canPlay()
                 {
                   boolean sick = true;
                   if (!card.hasSickness() || !card.isCreature())
                      sick = false;
                   if (card.isUntapped() && CardFactoryUtil.canUseAbility(card) &&
                         AllZone.GameAction.isCardInPlay(card) && !sick && !card.isFaceDown())
                      return true;
                   else
                      return false;
                 }//canPlay
                 public boolean canPlayAI()
                 {
                    CardList list = getAttackers();
                    if (list.isEmpty())
                       return false;
                    else
                       if (list.get(0).getNetDefense() + defense[0] < 1)
                          return false;
                    if (CardFactoryUtil.AI_doesCreatureAttack(card))
                       return false;
                    setTargetCard(list.get(0));
                    return true;
                 }//canPlayAI
                 public CardList getAttackers()
                 {
                    Card[] c = ComputerUtil.getAttackers().getAttackers();
                    CardList list = new CardList(c);
                    list.remove(card);
                    return list;
                 }
                 public void resolve()
                 {
                    if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
                    {
                       final Card[] creature = new Card[1];
                      
                       creature[0] = getTargetCard();
                       creature[0].addTempAttackBoost(attack[0]);
                       creature[0].addTempDefenseBoost(defense[0]);
                      
                       final Command EOT = new Command()
                       {
                      private static final long serialVersionUID = -852905560563053752L;

                      public void execute()
                          {
                             if (AllZone.GameAction.isCardInPlay(creature[0]))
                             {
                                creature[0].addTempAttackBoost(-attack[0]);
                                creature[0].addTempDefenseBoost(-defense[0]);
                             }
                          }
                       };//EOT
                       AllZone.EndOfTurn.addUntil(EOT);
                    }
                 }//resolve
              };//ability
              ability.setDescription("tap: "+Desc);
              ability.setStackDescription(Desc);
              ability.setBeforePayMana(CardFactoryUtil.input_targetCreature_NoCost_TapAbility((Ability_Tap)ability));
              card.addSpellAbility(ability);
           }//tapOnlyCost
           
           if (!tapOnlyCost && tapCost)
           {
              final SpellAbility ability = new Ability_Tap(card, manaCost)
              {
             private static final long serialVersionUID = 2749576299299014851L;
             
             public boolean canPlay()
                 {
                    boolean sick = true;
                    if (!card.hasSickness() || !card.isCreature())
                       sick = false;
                    if (card.isUntapped() && CardFactoryUtil.canUseAbility(card) &&
                          AllZone.GameAction.isCardInPlay(card) && !sick && !card.isFaceDown())
                       return true;
                    else
                       return false;
                 }//canPlay
                 public boolean canPlayAI()
                 {
                    CardList list = getAttackers();
                    if (list.isEmpty())
                       return false;
                    else
                       if (list.get(0).getNetDefense() + defense[0] < 1)
                          return false;
                    if (CardFactoryUtil.AI_doesCreatureAttack(card))
                       return false;
                    setTargetCard(list.get(0));
                    return true;
                 }//canPlayAI
                 public CardList getAttackers()
                 {
                    Card[] c = ComputerUtil.getAttackers().getAttackers();
                    CardList list = new CardList(c);
                    list.remove(card);
                    return list;
                 }//getAttackers
                 public void resolve()
                 {
                    if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
                    {
                       final Card[] creature = new Card[1];
                      
                       creature[0] = getTargetCard();
                       creature[0].addTempAttackBoost(attack[0]);
                       creature[0].addTempDefenseBoost(defense[0]);
                      
                       final Command EOT = new Command()
                       {
                      private static final long serialVersionUID = 8179097336678296338L;

                      public void execute()
                         {
                            if (AllZone.GameAction.isCardInPlay(creature[0]))
                            {
                               creature[0].addTempAttackBoost(-attack[0]);
                               creature[0].addTempDefenseBoost(-defense[0]);
                            }
                         }
                       };//EOT
                       AllZone.EndOfTurn.addUntil(EOT);
                    }   
                 }//resolve
              };//ability
              ability.setDescription(manaCost+ ", tap: "+Desc);
              ability.setStackDescription(Desc);
              ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
              card.addSpellAbility(ability);
           }//!tapCost
     }
    }//while
    
    // Generic destroy target card
    if (shouldSpDestroyTgt(card) != -1)
    {
       int n = shouldSpDestroyTgt(card);
       
       String parse = card.getKeyword().get(n).toString();
        card.removeIntrinsicKeyword(parse);
       
        String k[] = parse.split(":");
        String Targets = k[1];   // Artifact, Creature, Enchantment, Land, Permanent, White, Blue, Black, Red, Green, Colorless, MultiColor
                          // non-Artifact, non-Creature, non-Enchantment, non-Land, non-Permanent,
                          //non-White, non-Blue, non-Black, non-Red, non-Green, non-Colorless, non-MultiColor
        final String Tgts[] = Targets.split(",");
       
        String tmpDesc = card.getText().substring(15);
        int i = tmpDesc.indexOf(".");
        tmpDesc = tmpDesc.substring(0, i);
        final String Selec = new String("Select target " + tmpDesc + " to destroy.");
      
      final boolean NoRegen = (k.length == 3);
      
        card.clearSpellAbility();
       
        final SpellAbility spDstryTgt = new Spell(card)
        {
         private static final long serialVersionUID = 142142142142L;
         
         public boolean canPlayAI()
         {
            CardList results = new CardList();
            CardList choices = getTargets();
            
            if (choices.size() > 0)
            {
               for (int i = 0; i < Tgts.length; i++)
               {
                  if (Tgts[i].equals("Artifact")) {
                	 if (CardFactoryUtil.AI_getBestArtifact(choices) != null)
                		 results.add(CardFactoryUtil.AI_getBestArtifact(choices));
                  }
                  else if (Tgts[i].equals("Creature")) {
                	 if (CardFactoryUtil.AI_getBestCreature(choices) != null)
                     	results.add(CardFactoryUtil.AI_getBestCreature(choices));
                  }
                  else if (Tgts[i].equals("Enchantment")) {
                	 if (CardFactoryUtil.AI_getBestEnchantment(choices, card, true) != null)
                	  	results.add(CardFactoryUtil.AI_getBestEnchantment(choices, card, true));
                  }
                  else if (Tgts[i].equals("Land")) {
                	  if (CardFactoryUtil.AI_getBestLand(choices) != null)
                	  	results.add(CardFactoryUtil.AI_getBestLand(choices));
                  }
                  else if (Tgts[i].equals("Permanent")){
                	 if (CardFactoryUtil.AI_getMostExpensivePermanent(choices, card, true) != null)
                     	results.add(CardFactoryUtil.AI_getMostExpensivePermanent(choices, card, true));
                  }
               }
            }

            
            if (results.size() > 0)
            {
               results.shuffle();
               setTargetCard(results.get(0));
               return true;
            }
            return false;
         }
         CardList getTargets()
         {
            CardList tmpList = new CardList();
            tmpList.addAll(AllZone.Human_Play.getCards());
            tmpList.filter(new CardListFilter()
            {
               public boolean addCard(Card c)
               {
                  return (CardFactoryUtil.canTarget(card, c));
               }
            });
            
            return tmpList.getValidCards(Tgts);
         }
         public void resolve()
           {
              if (AllZone.GameAction.isCardInPlay(getTargetCard()) &&  CardFactoryUtil.canTarget(card, getTargetCard()))
                 if (NoRegen)
                    AllZone.GameAction.destroyNoRegeneration(getTargetCard());
                 else
                    AllZone.GameAction.destroy(getTargetCard());
              
           }
        }; //SpDstryTgt
       
        Input InGetTarget = new Input()
        {
           private static final long serialVersionUID = -142142142142L;
           
           public void showMessage()
           {
              CardList allCards = new CardList();
              allCards.addAll(AllZone.Human_Play.getCards());
              allCards.addAll(AllZone.Computer_Play.getCards());
              allCards.filter(new CardListFilter()
            {
               public boolean addCard(Card c)
               {
                  return (CardFactoryUtil.canTarget(card, c));
               }
            });
              
              CardList choices = allCards.getValidCards(Tgts);
              stopSetNext(CardFactoryUtil.input_targetSpecific(spDstryTgt, choices, Selec, true));
           }
        };//InGetTarget
       
        //card.clearSpellAbility();
        spDstryTgt.setBeforePayMana(InGetTarget);
        spDstryTgt.setDescription(card.getText());
        card.setText("");
        card.addSpellAbility(spDstryTgt);
    }//spDestroyTgt
    
    if (shouldSpDrawCards(card) != -1)
    {
       int n = shouldSpDrawCards(card);
       String parse = card.getKeyword().get(n).toString();
        card.removeIntrinsicKeyword(parse);
       
        String k[] = parse.split(":");
       
        final boolean Tgt[] = {false};
        Tgt[0] = k[0].contains("Tgt");
       
        final int NumCards[] = {-1};
        final String NumCardsType[] = {"none"};
        final boolean NumCardsTypeYouCtrl[] = {false};
        final boolean NumCardsTypeInPlay[] = {false};
        final boolean NumCardsTypeInYourYard[] = {false};
        final boolean NumCardsTypeInAllYards[] = {false};
        final boolean NumCardsDomain[] = {false};
        if (k[1].length() == 1)
           NumCards[0] = Integer.parseInt(k[1]);
        else
        {
           if (k[1].startsWith("NumCardsType"))
           {
              String kk[] = k[1].split("/");
              NumCardsType[0] = kk[1];
              NumCardsTypeYouCtrl[0] = kk[2].equals("YouCtrl");
              NumCardsTypeInPlay[0] = kk[2].equals("InPlay");
              NumCardsTypeInYourYard[0] = kk[2].equals("InYourYard");
              NumCardsTypeInAllYards[0] = kk[2].equals("InAllYards");
           }
           NumCardsDomain[0] = k[1].equals("Domain");
        }
       
        final int NumDiscard[] = {0};
        final String UnlessDiscardType[] = {"none"};
        final boolean AtRandom[] = {false};
       
        final int NumLoseLife[] = {0};
       
        final int NumToLibrary[] = {0};
        final String LibraryPosition[] = {"none"};
       
        final int NumOppDraw[] = {0};
       
        if (k.length > 2)
        {
           if (k[2].contains("Discard"))
           {
              String kk[] = k[2].split("/");
              if (kk[1].equals("X"))
                 NumDiscard[0] = -1;
              else
                 NumDiscard[0] = Integer.parseInt(kk[1]);
              
              if (kk.length > 2)
              {
                 if (kk[2].equals("UnlessDiscardType"))
                    UnlessDiscardType[0] = kk[3];
                 
                 AtRandom[0] = kk[2].equals("AtRandom");
              }
           }

           if (k[2].contains("LoseLife"))
           {
              String kk[] = k[2].split("/");
              if (kk[1].equals("X"))
                 NumLoseLife[0] = -1;
              else
                 NumLoseLife[0] = Integer.parseInt(kk[1]);
           }

           if (k[2].contains("NumToLibrary"))
           {
              String kk[] = k[2].split("/");
              if (kk[1].equals("X"))
                 NumToLibrary[0] = -1;
              else
                 NumToLibrary[0] = Integer.parseInt(kk[1]);
              LibraryPosition[0] = kk[2];
           }
           
           if (k[2].contains("NumOppDraw"))
           {
              String kk[] = k[2].split("/");
              if (kk[1].equals("X"))
                 NumOppDraw[0] = -1;
              else
                 NumOppDraw[0] = Integer.parseInt(kk[1]);
           }
        }
       
        final SpellAbility spDraw = new Spell(card)
        {
           private static final long serialVersionUID = -7049779241008089696L;

           public int getNumCards()
           {
              if (NumCards[0] != -1)
                 return NumCards[0];

              int n = 0;

              String cardController = card.getController();
              PlayerZone myPlay = AllZone.getZone(Constant.Zone.Play, cardController);
              PlayerZone opPlay = AllZone.getZone(Constant.Zone.Play, AllZone.GameAction.getOpponent(cardController));

              PlayerZone myYard = AllZone.getZone(Constant.Zone.Graveyard, cardController);
              PlayerZone opYard = AllZone.getZone(Constant.Zone.Graveyard, AllZone.GameAction.getOpponent(cardController));

              CardList AllCards = new CardList();

              if (! NumCardsType[0].equals("none"))
              {
                 if (NumCardsTypeInYourYard[0] == false)
                    AllCards.addAll(myYard.getCards());

                 if (NumCardsTypeInAllYards[0] == false)
                 {
                    AllCards.addAll(myYard.getCards());
                    AllCards.addAll(opYard.getCards());
                 }

                 if (NumCardsTypeYouCtrl[0] == true)
                    AllCards.addAll(myPlay.getCards());

                 if (NumCardsTypeInPlay[0] == true)
                 {
                    AllCards.addAll(myPlay.getCards());
                    AllCards.addAll(opPlay.getCards());
                 }

                 AllCards = AllCards.filter(new CardListFilter()
                 {
                    public boolean addCard(Card c)
                    {
                       if (c.getType().contains(NumCardsType[0]))
                          return true;

                       return false;
                    }
                 });

                 n = AllCards.size();
              }
              if (NumCardsDomain[0] == true)
              {
                 AllCards.addAll(myPlay.getCards()); 
                 String basic[] = {"Forest", "Plains", "Mountain", "Island", "Swamp"};

                 for(int i = 0; i < basic.length; i++)
                    if (! AllCards.getType(basic[i]).isEmpty())
                       n++;
              }

              if (NumDiscard[0] == -1)
                 NumDiscard[0] = n;
              if (NumLoseLife[0] == -1)
                 NumLoseLife[0] = n;
              if (NumToLibrary[0] == -1)
                 NumToLibrary[0] = n;
              if (NumOppDraw[0] == -1)
                 NumOppDraw[0] = n;

              return n;
           }

           public boolean canPlayAI()
           {
              int n = getNumCards();
              int h = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer).size();
              Random r = new Random();

              if (((h + n) - (NumDiscard[0] + NumToLibrary[0]) <= 7)
                    && (AllZone.GameAction.getPlayerLife(Constant.Player.Computer).getLife() - NumLoseLife[0]) >= 8
                    && (r.nextInt(10) > 4))
              {
                 setTargetPlayer(Constant.Player.Computer);
                 return true;
              }

              return false;
           }

           public void resolve()
           {
              int n = getNumCards();

              String TgtPlayer = card.getController();
              if (Tgt[0])
                 TgtPlayer = getTargetPlayer();

              for (int i=0; i < n; i++)
                 AllZone.GameAction.drawCard(TgtPlayer);

              if (NumDiscard[0] > 0)
              {
                 if (!UnlessDiscardType[0].equals("none"))
                    AllZone.GameAction.discardUnless(TgtPlayer, NumDiscard[0], UnlessDiscardType[0]);
                 else if (AtRandom[0] == true)
                    AllZone.GameAction.discardRandom(TgtPlayer, NumDiscard[0]);
                 else
                    AllZone.GameAction.discard(TgtPlayer, NumDiscard[0]);
              }
                 
              if (NumLoseLife[0] > 0)
                 AllZone.GameAction.getPlayerLife(TgtPlayer).subtractLife(NumLoseLife[0]);

              if (NumToLibrary[0] > 0)
                 AllZone.GameAction.handToLibrary(TgtPlayer, NumToLibrary[0], LibraryPosition[0]);

              if (NumOppDraw[0] > 0)
                 for (int i = 0; i < NumOppDraw[0]; i++)
                    AllZone.GameAction.drawCard(AllZone.GameAction.getOpponent(TgtPlayer));
           }
        };

        if (Tgt[0])
           spDraw.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spDraw));

        spDraw.setDescription(card.getText());
        card.setText("");
        card.clearSpellAbility();
        card.addSpellAbility(spDraw);
    }//spDrawCards

  //Spell gain life lose life cards (like Soul Feast)
    if (shouldSpLoseLifeGainLife(card)  != -1)
    {
       int n = shouldSpLoseLifeGainLife(card);
       if (n != -1)
       {
           String parse = card.getKeyword().get(n).toString();
          card.removeIntrinsicKeyword(parse);
         
          card.clearSpellAbility();
         
          String k[] = parse.split(":");
          final String lfdmg = k[1];
         
          final SpellAbility spell = new Spell(card)
          {
           private static final long serialVersionUID = -8277174319360648715L;

           public void resolve()
             {
             final int n = Integer.parseInt(lfdmg);
             
                AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(n);
                PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
                life.addLife(n);
             }//resolve()
          };//SpellAbility

          spell.setChooseTargetAI(CardFactoryUtil.AI_targetHuman());
          spell.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell));

          card.clearSpellAbility();
          card.addSpellAbility(spell);

          return card;
       }
    }// spLoseLifeGainLife
    
    if (shouldRebelSearch(card) != -1)
    {
      int n = shouldRebelSearch(card);
      if (n != -1)
      {
    	String parse = card.getKeyword().get(n).toString();
        card.removeIntrinsicKeyword(parse);
        
        String k[] = parse.split(":");
        final String manacost = k[1];
        
        card.addSpellAbility(CardFactoryUtil.ability_Rebel_Search(card, manacost));
      }
    }//Rebel search
    
    if (shouldMercSearch(card) != -1)
    {
      int n = shouldMercSearch(card);
      if (n != -1)
      {
    	String parse = card.getKeyword().get(n).toString();
        card.removeIntrinsicKeyword(parse);
        
        String k[] = parse.split(":");
        final String manacost = k[1];
        
        card.addSpellAbility(CardFactoryUtil.ability_Merc_Search(card, manacost));
      }
    }//Merc search
    
    if (shouldMorph(card) != -1)
    {
      int n = shouldMorph(card);
      if (n != -1)
      {
    	card.setPrevIntrinsicKeyword(card.getIntrinsicKeyword());
    	card.setPrevType(card.getType());
    	
    	String parse = card.getKeyword().get(n).toString();
        card.removeIntrinsicKeyword(parse);
        
        String k[] = parse.split(":");
        final String manacost = k[1];
        
        int attack = card.getBaseAttack();
        int defense = card.getBaseDefense();
        
        String orgManaCost = card.getManaCost();
        
        card.addSpellAbility(CardFactoryUtil.ability_Morph_Up(card, manacost, orgManaCost, attack, defense));
        card.addSpellAbility(CardFactoryUtil.ability_Morph_Down(card));
      }
    }//Morph

    if (shouldFlashback(card) != -1)
    {
      int n = shouldFlashback(card);
      if (n != -1)
      {
    	String parse = card.getKeyword().get(n).toString();
        //card.removeIntrinsicKeyword(parse);
        
        String k[] = parse.split(":");
              
        final String manacost = k[1];
        
        card.addSpellAbility(CardFactoryUtil.ability_Flashback(card, manacost,"0"));
      }
    }//flashback
    
    

    
    if (shouldDevour(card) != -1)
    {
      int n = shouldDevour(card);
      if (n != -1)
      {
    	
    	String parse = card.getKeyword().get(n).toString();
        card.removeIntrinsicKeyword(parse);
        
        String k[] = parse.split(":");
        final String magnitude = k[1];
        
        
        final int multiplier = Integer.parseInt(magnitude);
	  	//final String player = card.getController();
	  	final int[] numCreatures = new int[1];
	  	
	  	  
	  	final SpellAbility devour = new Spell(card)
	  	{
			private static final long serialVersionUID = 4888189840817163900L;
			
			public void resolve()
	  		{
	  			int totalCounters = numCreatures[0] * multiplier;
	  			card.addCounter(Counters.P1P1, totalCounters);
	  			
	  			if(card.getName().equals("Skullmulcher"))
	  			{
	  				for(int i=0;i<numCreatures[0];i++)
	  				{
	  					AllZone.GameAction.drawCard(card.getController());
	  				}
	  			}
	  			else if (card.getName().equals("Caldera Hellion"))
		      	{
	      		  PlayerZone hPlay = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
	      		  PlayerZone cPlay = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
	      		  CardList creatures = new CardList();
	      		  
	      		  creatures.addAll(hPlay.getCards());
	      		  creatures.addAll(cPlay.getCards());
	      		  creatures = creatures.getType("Creature");
	      		  
	      		  for(int i=0;i<creatures.size();i++)
	      		  {
	      			  Card crd = creatures.get(i);
	      			  if (CardFactoryUtil.canDamage(card, crd))
	      				  crd.addDamage(3);
	      		  }
		      	}
	  				
	  		}
	  		public boolean canPlay()
	  		{
	  			return AllZone.Phase.getActivePlayer().equals(card.getController()) && card.isFaceDown() &&
	                  !AllZone.Phase.getPhase().equals("End of Turn") && AllZone.GameAction.isCardInPlay(card);
	  		}
	  			
	  	};//devour
  		
	  	 Command intoPlay = new Command()
	     {
			private static final long serialVersionUID = -7530312713496897814L;

			public void execute()
	        {
	          
	          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
	          CardList creatsToSac = new CardList();
	      	  CardList creats = new CardList(play.getCards());
	      	  creats = creats.filter(new CardListFilter()
	          {
	            public boolean addCard(Card c)
	            {
	              return c.isCreature() && !c.equals(card);
	            }
	          });
	      	  
	      	  //System.out.println("Creats size: " + creats.size());
	      	  
	      	  if (card.getController().equals(Constant.Player.Human))
	      	  {
		      	  Object o = null;
		      	  int creatsSize = creats.size();
		      	  
		      	  for(int k=0; k < creatsSize; k++)
		      	  {
		       		   o = AllZone.Display.getChoiceOptional("Select creature to sacrifice", creats.toArray());
		       		   
		       		   if(o==null)
		       			   break;
		       		   
		       		   Card c = (Card)o;
		       		   creatsToSac.add(c);
		       		   creats.remove(c);
		      	  }
		      	  
		      	  numCreatures[0]=creatsToSac.size();
		      	  for(int m=0;m<creatsToSac.size();m++)
		      	  {
		      		  AllZone.GameAction.sacrifice(creatsToSac.get(m));
		      	  }
		      	 
	      	  }//human
	      	  else
	      	  {
	      		  int count = 0;
	      		  for(int i=0;i<creats.size();i++)
	      		  {
	      			  Card c = creats.get(i);
	      			  if (c.getNetAttack() <= 1 && c.getNetDefense() <= 2) {
	      				  AllZone.GameAction.sacrifice(c);
	      				  count++;
	      			  }
	      			  //is this needed?
	      			  AllZone.Computer_Play.updateObservers(); 
	      		  }
	      		  numCreatures[0] = count;
	      	  }
	          AllZone.Stack.add(devour);
	        }
	      };

	  	  devour.setStackDescription(card.getName() +" - gets " + magnitude + " +1/+1 counter(s) per devoured creature.");
	  	  devour.setDescription("Devour " +magnitude);
	  	  card.addSpellAbility(devour);
	  	  card.addComesIntoPlayCommand(intoPlay);
        
        //card.addSpellAbility(CardFactoryUtil.ability_Devour(card, magnitude));
      }
    }//Devour
    
    while (shouldModular(card) != -1)
    {
       int n = shouldModular(card);
       if (n != -1)
       {
          String parse = card.getKeyword().get(n).toString();
            card.removeIntrinsicKeyword(parse);

            final int m = Integer.parseInt(parse.substring(8));
            String t = card.getSpellText();
            if (!t.equals("")) t += "\r\n";
            card.setText(t + parse + " (This enters the battlefield with " + m + " +1/+1 counters on it. When it's put into a graveyard, you may put its +1/+1 counters on target artifact creature.)");//Erm help? Isn't there a normal way to do this?...
            card.addComesIntoPlayCommand(
                  new Command()
                  {
					private static final long serialVersionUID = 339412525059881775L;

					public void execute()
                     {
                        card.addCounter(Counters.P1P1, m);
                     }});
          final SpellAbility ability = new Ability(card, "0")
            {
             public void resolve()
             {
                if (card.getController().equals(Constant.Player.Computer))
                {
                   CardList choices = new CardList(AllZone.Computer_Play.getCards()).filter(
                    new CardListFilter(){public boolean addCard(Card c) {return c.isCreature() && c.isArtifact(); }});
                   if (choices.size() != 0)
                      CardFactoryUtil.AI_getBestCreature(choices).addCounter(Counters.P1P1, getSourceCard().getCounters(Counters.P1P1));
                }
                else 
                {
	                final SpellAbility ability=this;
	                AllZone.InputControl.setInput(
	                   new Input(){
	                    
						private static final long serialVersionUID = 2322926875771867901L;
						public void showMessage()
	                      {
	                         AllZone.Display.showMessage("Select target artifact creature");
	                         ButtonUtil.enableOnlyCancel();
	                      }
	                      public void selectButtonCancel() {stop();}
	                      public void selectCard(Card card2, PlayerZone zone)
	                      {
	                         if(card2.isCreature() && card2.isArtifact() && zone.is(Constant.Zone.Play) && CardFactoryUtil.canTarget(ability, card))
	                         {
	                            card2.addCounter(Counters.P1P1, ability.getSourceCard().getCounters(Counters.P1P1));//combining input and resolve is skirting rules and hacky at best, but non-stackability of destroyCommand Inputs turns into a major problem when the keyword is mainly used during the simultaneous destruction of combat.
	                            stop();
	                         }
	                      }
	                   });
                }//else
             }//resolve()
            };

          card.addDestroyCommand(new Command()
            {
               private static final long serialVersionUID = 304026662487997331L;
               
               public void execute()
               {
                  ability.setStackDescription("Put "+ card.getCounters(Counters.P1P1) +" +1/+1 counter/s from " + card + " on target artifact creature.");
               AllZone.Stack.push(ability);
               }
            });
           
       }
        
    }//while shouldModular
    
    if (shouldSpellbomb(card) != -1)
    {
      int n = shouldSpellbomb(card);
      if (n != -1)
      {
    	String parse = card.getKeyword().get(n).toString();
        card.removeIntrinsicKeyword(parse);
       
        card.addSpellAbility(CardFactoryUtil.ability_Spellbomb(card));
      }
    }//Spellbomb
    
    // Generic target creature pump
    if (shouldSpPumpTgt(card) != -1)
    {
       int n = shouldSpPumpTgt(card);
       
       String parse = card.getKeyword().get(n).toString();
       card.removeIntrinsicKeyword(parse);
       
       String k[] = parse.split(":");
       String ptk[] = k[1].split("/");
       
       final int attack[] = {0};
       final int defense[] = {0};
       final String keyword[] = {"none"};
       
       if (ptk.length == 1)
          keyword[0] = ptk[0];
       
       if (ptk.length >= 2)
       {
          attack[0] = Integer.parseInt(ptk[0].replace("+", ""));
          defense[0] = Integer.parseInt(ptk[1].replace("+", ""));
       }
       
       if (ptk.length == 3)
          keyword[0] = ptk[2];
       
/*        String Desc = new String();
        Desc = "Target creature ";
        if (attack[0] != 0 || defense[0] != 0)
        {
           Desc = Desc + "gets ";
           if (attack[0] > 0)
              Desc = Desc + "+" + attack[0];
           else
              Desc = Desc + attack[0];
           Desc = Desc + "/";
           if (defense[0] > 0)
              Desc = Desc + "+" + defense[0];
           else
              Desc = Desc + defense[0];
           
           if (! keyword[0].equals("none"))
              Desc = Desc + " and ";
        }
        if (! keyword[0].equals("none"))
           Desc = Desc + "gains " + keyword;
       
        Desc = Desc + " until end of turn.";
*/       
       SpellAbility spPump = new Spell(card)
       {
          private static final long serialVersionUID = 42244224L;
          
          public boolean canPlayAI()
          {
             Card c = getAttacker();
             if (c != null)
             {
                setTargetCard(c);
                return true;
             }
             else
                return false;
          }
          
          public Card getAttacker()
          {
             Combat c = ComputerUtil.getAttackers();
             
             CardList list = new CardList(c.getAttackers());
             CardListUtil.sortFlying(list);
             
             list = list.filter(new CardListFilter()
             {
                public boolean addCard(Card c)
                {
                        return (CardFactoryUtil.canTarget(card, c)) &&
                        (! c.getKeyword().contains(keyword[0])) &&
                        (! c.hasSickness() && keyword[0].equals("Haste"));
                }
             });
             
             if (list.size() > 0)
                return list.get(0);
             else
                return null;
          }
          
          public void resolve()
          {
             final Card[] target = new Card[1];
             
             final Command untilEOT = new Command()
             {
                private static final long serialVersionUID = -42244224L;
                
                public void execute()
                {
                   if (AllZone.GameAction.isCardInPlay(target[0]))
                   {
                      target[0].addTempAttackBoost(-attack[0]);
                      target[0].addTempDefenseBoost(-defense[0]);
                      
                      if (!keyword[0].equals("none"))
                         target[0].removeExtrinsicKeyword(keyword[0]);
                   }
                }
             };
             
             target[0] = getTargetCard();
             if (AllZone.GameAction.isCardInPlay(target[0]) && CardFactoryUtil.canTarget(card, target[0]))
                {
                   target[0].addTempAttackBoost(attack[0]);
                   target[0].addTempDefenseBoost(defense[0]);
                   if (!keyword[0].equals("none"))
                      target[0].addExtrinsicKeyword(keyword[0]);
                   
                   AllZone.EndOfTurn.addUntil(untilEOT);
                }
          }
       };
       
       spPump.setBeforePayMana(CardFactoryUtil.input_targetCreature(spPump));
       //spPump.setDescription(Desc);
       card.clearSpellAbility();
       card.addSpellAbility(spPump);
    }

    
    while (shouldManaAbility(card) != -1)
    {
       int n = shouldManaAbility(card);
       if (n != -1)
       {
          String parse = card.getKeyword().get(n).toString();
          card.removeIntrinsicKeyword(parse);
          final Ability_Mana ability = new Ability_Mana(card, parse)
          {
              private static final long serialVersionUID = -113811381138L;
             
              public boolean canPlayAI()
              {
                 return false;
              }
           };
           //ability.setDescription(parse);
           card.addSpellAbility(ability);
       }
    }
    	    
    ////////////////////////////////////////////////////////////////
    
    if(card.getKeyword().contains("When this card comes into play, draw a card."))
    {
      
    	final SpellAbility ability = new Ability(card, "0")
        {
          public void resolve()
          {
            AllZone.GameAction.drawCard(card.getController());
          }//resolve()
        };//SpellAbility
        Command intoPlay = new Command()
        {

  		private static final long serialVersionUID = 1707519783018941582L;

  		public void execute()
          {
            ability.setStackDescription(card.getName() + " - " +card.getController() +" draws a card.");
            AllZone.Stack.add(ability);
          }
        };
        card.addComesIntoPlayCommand(intoPlay);
    }//end if
   

  //*************** START *********** START **************************
    if(     cardName.equals("Burst of Speed") ||
          cardName.equals("Chorus of Woe") ||
            cardName.equals("Dance of Shadows") ||
            cardName.equals("Desperate Charge") ||
            cardName.equals("Glorious Charge") ||
            cardName.equals("Kjeldoran War Cry") ||
            cardName.equals("Magnify") ||
            cardName.equals("Nature's Cloak") ||
            cardName.equals("Nocturnal Raid") ||
            cardName.equals("Overrun") ||
            cardName.equals("Path of Anger's Flame") ||
            cardName.equals("Resuscitate") ||
            cardName.equals("Righteous Charge") ||
            cardName.equals("Scare Tactics") ||
            cardName.equals("Shield Wall") ||
            cardName.equals("Solidarity") ||
            cardName.equals("Steadfastness") ||
            cardName.equals("Tortoise Formation") ||
            cardName.equals("Tromp the Domains") ||
            cardName.equals("Valorous Charge") ||
            cardName.equals("Virtuous Charge") ||
            cardName.equals("Vitalizing Wind") ||
            cardName.equals("Warrior's Charge") ||
            cardName.equals("Warrior's Honor"))
   {
     SpellAbility spell = new Spell(card)
     {
     private static final long serialVersionUID = -5844664906503221006L;

     public boolean canPlayAI()
       {
         return getAttacker() != null;
       }
       public Card getAttacker()
       {
         //target creatures that is going to attack
         Combat c = ComputerUtil.getAttackers();
         Card[] att = c.getAttackers();
         if(cardName.equals("Dance of Shadows") ||
            cardName.equals("Overrun") ||
            cardName.equals("Tromp the Domains"))
         {
             if (att.length > 2)   // Effect best used with a few creatures
                 return att[0];
             else
                 return null;
         }
         if(cardName.equals("Burst of Speed") ||
           cardName.equals("Chorus of Woe") ||
            cardName.equals("Desperate Charge") ||
            cardName.equals("Glorious Charge") ||
            cardName.equals("Kjeldoran War Cry") ||
            cardName.equals("Magnify") ||
            cardName.equals("Nature's Cloak") ||
            cardName.equals("Nocturnal Raid") ||
            cardName.equals("Path of Anger's Flame") ||
            cardName.equals("Resuscitate") ||
            cardName.equals("Righteous Charge") ||
            cardName.equals("Scare Tactics") ||
            cardName.equals("Shield Wall") ||
            cardName.equals("Solidarity") ||
            cardName.equals("Steadfastness") ||
            cardName.equals("Tortoise Formation") ||
            cardName.equals("Valorous Charge") ||
            cardName.equals("Vitalizing Wind") ||
            cardName.equals("Virtuous Charge") ||
            cardName.equals("Warrior's Charge") ||
            cardName.equals("Warrior's Honor"))
         {
             if (att.length > 1)   // Effect best used on at least a couple creatures
                 return att[0];
             else
                 return null;
         }
         return null;
       }//getAttacker()

       int getPowerBoost()
       {
         if(cardName.equals("Tromp the Domains"))
             return getTtDBoost();

         if(cardName.equals("Kjeldoran War Cry"))
             return getKWCBoost();

         if(cardName.equals("Chorus of Woe") ||
            cardName.equals("Dance of Shadows") ||
            cardName.equals("Glorious Charge") ||
            cardName.equals("Magnify") ||
            cardName.equals("Scare Tactics") ||
            cardName.equals("Virtuous Charge") ||
            cardName.equals("Warrior's Charge") ||
            cardName.equals("Warrior's Honor"))
             return 1;

         if(cardName.equals("Desperate Charge") ||
            cardName.equals("Nocturnal Raid") ||
            cardName.equals("Path of Anger's Flame") ||
            cardName.equals("Righteous Charge") ||
            cardName.equals("Valorous Charge"))
             return 2;

         if(cardName.equals("Overrun"))
             return 3;

         if(cardName.equals("Vitalizing Wind"))
             return 7;

         return 0;
       }//getPowerBoost()

       int getToughBoost()
       {
         if(cardName.equals("Tromp the Domains"))
             return getTtDBoost();

         if(cardName.equals("Kjeldoran War Cry"))
             return getKWCBoost();

         if(cardName.equals("Glorious Charge") ||
           cardName.equals("Magnify") ||
            cardName.equals("Virtuous Charge") ||
            cardName.equals("Warrior's Charge") ||
            cardName.equals("Warrior's Honor"))
             return 1;

         if(cardName.equals("Righteous Charge") ||
            cardName.equals("Shield Wall"))
             return 2;

         if(cardName.equals("Overrun") ||
            cardName.equals("Steadfastness"))
             return 3;

         if(cardName.equals("Solidarity"))
             return 5;

         if(cardName.equals("Vitalizing Wind"))
             return 7;

         return 0;
       }//getToughBoost()

       String getKeywordBoost()
       {
          if(cardName.equals("Burst of Speed"))
              return "Haste";
          
           if(cardName.equals("Overrun") ||
              cardName.equals("Tromp the Domains"))
               return "Trample";

           if(cardName.equals("Dance of Shadows"))
               return "Fear";
          
           if(cardName.equals("Nature's Cloak"))
              return "Forestwalk";
          
           if(cardName.equals("Resuscitate"))
              return "RegenerateMe:1";
          
           if(cardName.equals("Tortoise Formation"))
              return "Shroud";
          
           return "None";
       }//getKeywordBoost()

       int getTtDBoost()     // Tromp the Domains - +1/+1 for each basic land you control
       {
           PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
           CardList land = new CardList(play.getCards());

           String basic[] = {"Forest", "Plains", "Mountain", "Island", "Swamp"};
           int count = 0;

           for (int i = 0; i < basic.length; i++)
           {
               CardList c = land.getType(basic[i]);
               if (!c.isEmpty())
                   count++;
           }
           return count;
       }//getTtDBoost

       int getKWCBoost()     // Kjeldoran War Cry - +X/+X, X = 1 + Num(KWC in All Graveyards)
       {
           PlayerZone hYard = AllZone.getZone(Constant.Zone.Graveyard, Constant.Player.Human);
           PlayerZone cYard = AllZone.getZone(Constant.Zone.Graveyard, Constant.Player.Computer);
           CardList allYards = new CardList();

           allYards.addAll(hYard.getCards());
           allYards.addAll(cYard.getCards());
           allYards = allYards.getName("Kjeldoran War Cry");

           return allYards.size() + 1;
       }//getKWCBoost

       public void resolve()
       {

           final int pboost = getPowerBoost();
           final int tboost = getToughBoost();
           final String kboost = getKeywordBoost();

           CardList list = new CardList();

           if (cardName.equals("Burst of Speed") || // Creatures "you" Control
              cardName.equals("Chorus of Woe") ||
               cardName.equals("Dance of Shadows") ||
               cardName.equals("Desperate Charge") ||
               cardName.equals("Glorious Charge") ||
               cardName.equals("Kjeldoran War Cry") ||
               cardName.equals("Nature's Cloak") ||
               cardName.equals("Overrun") ||
               cardName.equals("Path of Anger's Flame") ||
               cardName.equals("Resuscitate") ||
               cardName.equals("Righteous Charge") ||
               cardName.equals("Scare Tactics") ||
               cardName.equals("Shield Wall") ||
               cardName.equals("Solidarity") ||
               cardName.equals("Steadfastness") ||
               cardName.equals("Tortoise Formation") ||
               cardName.equals("Virtuous Charge") ||
               cardName.equals("Vitalizing Wind") ||
               cardName.equals("Warrior's Charge") ||
               cardName.equals("Warrior's Honor"))
           {
               PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
               list.addAll(play.getCards());
              
               if(cardName.equals("Nature's Cloak"))
                  list = list.getColor("G");
           }

           if (cardName.equals("Magnify") || // All Creatures in Play
               cardName.equals("Nocturnal Raid") || // All Black Creatures in Play
               cardName.equals("Valorous Charge")) // All White Creatures in Play
           {
               PlayerZone human = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
               PlayerZone comp = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);

               list.addAll(human.getCards());
               list.addAll(comp.getCards());

               if(cardName.equals("Nocturnal Raid"))
                   list = list.getColor("B");

               if(cardName.equals("Valorous Charge"))
                   list = list.getColor("W");
           }

         for(int i = 0; i < list.size(); i++)
         {
           final Card[] target = new Card[1];
           target[0] = list.get(i);

           final Command untilEOT = new Command()
           {
          private static final long serialVersionUID = 5063161656920609389L;

          public void execute()
             {
               if(AllZone.GameAction.isCardInPlay(target[0]))
               {
                 target[0].addTempAttackBoost(-pboost);
                 target[0].addTempDefenseBoost(-tboost);

                 if(!kboost.equals("None"))
                     target[0].removeExtrinsicKeyword(kboost);
               }
             }
           };//Command

           if(AllZone.GameAction.isCardInPlay(target[0]))
           {
             target[0].addTempAttackBoost(pboost);
             target[0].addTempDefenseBoost(tboost);

             if(!kboost.equals("None"))
                 target[0].addExtrinsicKeyword(kboost);

             AllZone.EndOfTurn.addUntil(untilEOT);
           }//if
         }//for
       }//resolve()
     };
     card.clearSpellAbility();
     card.addSpellAbility(spell);
   }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    if(cardName.equals("Elspeth, Knight-Errant"))
    {
      //computer only plays ability 1 and 3, gain life and put X\X token into play
      final int turn[] = new int[1];
      turn[0] = -1;

      final Card card2 = new Card()
      {
        public void addDamage(int n)
        {
          subtractCounter(Counters.LOYALTY, n);
          AllZone.GameAction.checkStateEffects();
        }
      };
      card2.addCounter(Counters.LOYALTY, 4);

      card2.setOwner(owner);
      card2.setController(owner);

      card2.setName(card.getName());
      card2.setType(card.getType());
      card2.setManaCost(card.getManaCost());
      card2.addSpellAbility(new Spell_Permanent(card2));

      //ability2: target creature gets +3/+3 and flying until EOT
      final SpellAbility ability2 = new Ability(card2, "0")
      {
   	   
   	   public void resolve()
          {
   		   
   		 card2.addCounter(Counters.LOYALTY, 1);
   		 
   		 turn[0] = AllZone.Phase.getTurn();
   		 
            final Command eot = new Command()
            {
			   private static final long serialVersionUID = 94488363210770877L;

			   public void execute()
              {
                Card c = getTargetCard();
                if(AllZone.GameAction.isCardInPlay(c))
                {
                  c.addTempAttackBoost(-3);
                  c.addTempDefenseBoost(-3);
                  c.removeExtrinsicKeyword("Flying");
                }
              }//execute()
            };//Command

            Card c = getTargetCard();
            if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card2, c))
            {
              c.addTempAttackBoost(3);
              c.addTempDefenseBoost(3);
              c.addExtrinsicKeyword("Flying");

              AllZone.EndOfTurn.addUntil(eot);
            }
          }//resolve()

        public boolean canPlayAI()
        {
          return false;
        }

        public boolean canPlay()
        {
          @SuppressWarnings("unused") // library
		   PlayerZone library = AllZone.getZone(Constant.Zone.Library, card2.getController());

          return 0 < card2.getCounters(Counters.LOYALTY) &&
                      AllZone.getZone(card2).is(Constant.Zone.Play) &&
                      turn[0] != AllZone.Phase.getTurn() &&
                      AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
                      !AllZone.Phase.getPhase().equals("End of Turn");
          
        }//canPlay()
      };//SpellAbility ability2

      ability2.setBeforePayMana(new Input()
      {
		private static final long serialVersionUID = 9062830120519820799L;
		
		int check = -1;
         public void showMessage()
         {
           if(check != AllZone.Phase.getTurn())
           {
             check = AllZone.Phase.getTurn();
             turn[0] = AllZone.Phase.getTurn();
             
             
             AllZone.Stack.push(ability2);
           }
           stop();
         }//showMessage()
      });
      
      

      //ability3
      final SpellAbility ability3 = new Ability(card2, "0")
      {
        public void resolve()
        {
          card2.subtractCounter(Counters.LOYALTY, 8);
          turn[0] = AllZone.Phase.getTurn();

          //make all permanents in play/hand/library and graveyard	
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          
          CardList list = new CardList();
          list.addAll(play.getCards());
          list.addAll(hand.getCards());
          list.addAll(library.getCards());
          list.addAll(grave.getCards());
          
          
          for (int i=0;i < list.size(); i++)
          {
       	   Card c = list.get(i);
       	   if (c.isPermanent() && !c.isPlaneswalker())
       	   {
       		   c.addExtrinsicKeyword("Indestructible");
       	   }
       	   
          }
          
        }
        public boolean canPlay()
        {
          return 8 <= card2.getCounters(Counters.LOYALTY) && AllZone.getZone(card2).is(Constant.Zone.Play) &&
              turn[0] != AllZone.Phase.getTurn() &&
              AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
              !AllZone.Phase.getPhase().equals("End of Turn");
        }//canPlay()
        public boolean canPlayAI()
        {
                return true;
        }
      };
      ability3.setBeforePayMana(new Input()
      {
		  private static final long serialVersionUID = -2054686425541429389L;
		
		  int check = -1;
         public void showMessage()
         {
           if(check != AllZone.Phase.getTurn())
           {
             check = AllZone.Phase.getTurn();
             turn[0] = AllZone.Phase.getTurn();
             AllZone.Stack.push(ability3);
           }
           stop();
         }//showMessage()
      });

      //ability 1: create white 1/1 token
      final SpellAbility ability1 = new Ability(card2, "0")
      {
        public void resolve()
        {
          card2.addCounter(Counters.LOYALTY, 1);
          turn[0] = AllZone.Phase.getTurn();
          
          Card c = new Card();

          c.setOwner(card2.getController());
          c.setController(card2.getController());

          c.setManaCost("W");
          c.setToken(true);
          
          c.setImageName("W 1 1 Soldier");
          c.setName("Soldier");
          c.addType("Creature");
          c.addType("Soldier");
          c.setBaseAttack(1);
          c.setBaseDefense(1);
          //AllZone.GameAction.getPlayerLife(card.getController()).addLife(2);
          
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card2.getController());
          play.add(c);
        }
        public boolean canPlayAI()
        {
          if(ability3.canPlay() && ability3.canPlayAI()) {
            return false;
          } else
          {
            return true;
          }
        }
        public boolean canPlay()
        {
          return 0 < card2.getCounters(Counters.LOYALTY) && AllZone.getZone(card2).is(Constant.Zone.Play) &&
              turn[0] != AllZone.Phase.getTurn() &&
              AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
              !AllZone.Phase.getPhase().equals("End of Turn");
        }//canPlay()
      };//SpellAbility ability1

      ability1.setBeforePayMana(new Input()
      {
		  private static final long serialVersionUID = -7892114885686285881L;
		  
		  int check = -1;
         public void showMessage()
         {
           if(check != AllZone.Phase.getTurn())
           {
             check = AllZone.Phase.getTurn();
             turn[0] = AllZone.Phase.getTurn();
             AllZone.Stack.push(ability1);
           }
           stop();
         }//showMessage()
      });

      ability1.setDescription("+1: Put a white 1/1 Soldier creature token into play.");
      ability1.setStackDescription("Elspeth, Knight-Errant - put 1/1 token into play.");
      card2.addSpellAbility(ability1);

      ability2.setDescription("+1: Target creature gets +3/+3 and gains flying until end of turn.");
      ability2.setStackDescription("Elspeth, Knight-Errant - creature gets +3/+3 and Flying until EOT.");
      ability2.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability2));
      
      card2.addSpellAbility(ability2);
     
      ability3.setDescription("-8: For the rest of the game, artifacts, creatures, enchantments, and lands you control are indestructible.");
      ability3.setStackDescription("Elspeth, Knight-Errant - Make everything indestructible.");
      card2.addSpellAbility(ability3);

      return card2;
    }
    //*************** END ************ END **************************
    
     
   //*************** START *********** START **************************
     if(cardName.equals("Nissa Revane"))
     {
       final int turn[] = new int[1];
       turn[0] = -1;

       final Card card2 = new Card()
       {
         public void addDamage(int n)
         {
           subtractCounter(Counters.LOYALTY, n);
           AllZone.GameAction.checkStateEffects();
         }
       };
       card2.addCounter(Counters.LOYALTY, 2);

       card2.setOwner(owner);
       card2.setController(owner);

       card2.setName(card.getName());
       card2.setType(card.getType());
       card2.setManaCost(card.getManaCost());
       card2.addSpellAbility(new Spell_Permanent(card2));

       //ability2: gain 2 life for each elf controlled
       final SpellAbility ability2 = new Ability(card2, "0")
       {
    	   
    	   public void resolve()
           {
    		   
    		 card2.addCounter(Counters.LOYALTY, 1);
    		 
    		 turn[0] = AllZone.Phase.getTurn();
    		 
    		 PlayerZone play = AllZone.getZone(Constant.Zone.Play, card2.getController());
    		 CardList elves = new CardList(play.getCards());
    		 elves = elves.getType("Elf");

    		 AllZone.GameAction.getPlayerLife(card.getController()).addLife(2*elves.size());
             
           }//resolve()

         public boolean canPlayAI()
         {
        	 PlayerZone lib = AllZone.getZone(Constant.Zone.Library, Constant.Player.Computer);

        	 CardList chosens = new CardList(lib.getCards());
    		 chosens = chosens.getName("Nissa's Chosen");
    		 
    		 if (chosens.size() > 0)
    			 return false;
    		 
    		 return true;
         }

         public boolean canPlay()
         {
           @SuppressWarnings("unused") // library
		   PlayerZone library = AllZone.getZone(Constant.Zone.Library, card2.getController());

           return 0 < card2.getCounters(Counters.LOYALTY) &&
                       AllZone.getZone(card2).is(Constant.Zone.Play) &&
                       turn[0] != AllZone.Phase.getTurn() &&
                       AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
                       !AllZone.Phase.getPhase().equals("End of Turn");
           
         }//canPlay()
       };//SpellAbility ability2

       ability2.setBeforePayMana(new Input()
       {
		
		
		private static final long serialVersionUID = 2828718386226165026L;
		int check = -1;
          public void showMessage()
          {
            if(check != AllZone.Phase.getTurn())
            {
              check = AllZone.Phase.getTurn();
              turn[0] = AllZone.Phase.getTurn();
              
              
              AllZone.Stack.push(ability2);
            }
            stop();
          }//showMessage()
       });
       

       //ability3
       final SpellAbility ability3 = new Ability(card2, "0")
       {
         public void resolve()
         {
           card2.subtractCounter(Counters.LOYALTY, 7);
           turn[0] = AllZone.Phase.getTurn();

           //make all permanents in play/hand/library and graveyard	
           PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
           PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
           
           CardList list = new CardList();;
           list.addAll(library.getCards());
           list = list.getType("Elf");
           
           //currently, just adds all elves into play.
           for (int i=0;i < list.size(); i++)
           {
        	   Card c = list.get(i);
        	   if (c.isCreature() )
        	   {
        		   library.remove(c);
        		   play.add(c);
        	   }
           }
         }
         public boolean canPlay()
         {
           return 7 <= card2.getCounters(Counters.LOYALTY) && AllZone.getZone(card2).is(Constant.Zone.Play) &&
               turn[0] != AllZone.Phase.getTurn() &&
               AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
               !AllZone.Phase.getPhase().equals("End of Turn");
         }//canPlay()
         public boolean canPlayAI()
         {
        	 PlayerZone lib = AllZone.getZone(Constant.Zone.Library, Constant.Player.Computer);
    		 
        	 CardList elves = new CardList(lib.getCards());
    		 elves = elves.getType("Elf");
    		 
    		 return elves.size() > 3;
         }
       };
       ability3.setBeforePayMana(new Input()
       {

		private static final long serialVersionUID = -7189927522150479572L;
		int check = -1;
          public void showMessage()
          {
            if(check != AllZone.Phase.getTurn())
            {
              check = AllZone.Phase.getTurn();
              turn[0] = AllZone.Phase.getTurn();
              AllZone.Stack.push(ability3);
            }
            stop();
          }//showMessage()
       });

       //ability 1: search for Nessa's Chosen
       final SpellAbility ability1 = new Ability(card2, "0")
       {
         public void resolve()
         {
           card2.addCounter(Counters.LOYALTY, 1);
           turn[0] = AllZone.Phase.getTurn();
           
           if (card2.getController().equals(Constant.Player.Human)){
	           Object check = AllZone.Display.getChoiceOptional("Search for Nissa's Chosen", AllZone.Human_Library.getCards());
	           if(check != null)
	           {
	        	 Card c = (Card)check;
	        	   
	             PlayerZone play = AllZone.getZone(Constant.Zone.Play, card2.getController());
	             PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card2.getController());
	             
	             if (c.getName().equals("Nissa's Chosen"))
	             {
		             lib.remove(c);
		             play.add(c);
	             }
	           }
	           AllZone.GameAction.shuffle(Constant.Player.Human);
           }//human
           else
           {
        	   PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card2.getController());
        	   PlayerZone play = AllZone.getZone(Constant.Zone.Play, card2.getController());
        	   CardList nissas = new CardList(lib.getCards());
        	   nissas = nissas.getName("Nissa's Chosen");
        	   
        	   if (nissas.size() > 0)
        	   {
        		   Card nissa = nissas.get(0);
        		   lib.remove(nissa);
        		   play.add(nissa);
        	   }
        	   AllZone.GameAction.shuffle(Constant.Player.Computer);
           }

         }
         public boolean canPlayAI()
         {
           if(ability3.canPlay() && ability3.canPlayAI()) {
             return false;
           } else
           {
             return true;
           }
         }
         public boolean canPlay()
         {
           return 0 < card2.getCounters(Counters.LOYALTY) && AllZone.getZone(card2).is(Constant.Zone.Play) &&
               turn[0] != AllZone.Phase.getTurn() &&
               AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
               !AllZone.Phase.getPhase().equals("End of Turn");
         }//canPlay()
       };//SpellAbility ability1

       ability1.setBeforePayMana(new Input()
       {
		  
		private static final long serialVersionUID = 7668642820407492396L;
		int check = -1;
          public void showMessage()
          {
            if(check != AllZone.Phase.getTurn())
            {
              check = AllZone.Phase.getTurn();
              turn[0] = AllZone.Phase.getTurn();
              AllZone.Stack.push(ability1);
            }
            stop();
          }//showMessage()
       });

       ability1.setDescription("+1: Search your library for a card named Nissa's Chosen and put it onto the battlefield. Then shuffle your library.");
       ability1.setStackDescription("Nissa Revane - Search for a card named Nissa's Chosen and put it onto the battlefield.");
       card2.addSpellAbility(ability1);

       ability2.setDescription("+1: You gain 2 life for each Elf you control.");
       ability2.setStackDescription("Nissa Revane - You gain 2 life for each Elf you control.");
       
       card2.addSpellAbility(ability2);
      
       ability3.setDescription("-7: Search your library for any number of Elf creature cards and put them onto the battlefield. Then shuffle your library.");
       ability3.setStackDescription("Nissa Revane - Search your library for any number of Elf creature cards and put them onto the battlefield. Then shuffle your library.");
       card2.addSpellAbility(ability3);

       return card2;
     }
     //*************** END ************ END **************************
     
   //*************** START *********** START **************************
     if(cardName.equals("Nicol Bolas, Planeswalker"))
     {
       
       final int turn[] = new int[1];
       turn[0] = -1;

       final Card card2 = new Card()
       {
         public void addDamage(int n)
         {
           subtractCounter(Counters.LOYALTY, n);
           AllZone.GameAction.checkStateEffects();
         }
       };
       card2.addCounter(Counters.LOYALTY, 5);

       card2.setOwner(owner);
       card2.setController(owner);

       card2.setName(card.getName());
       card2.setType(card.getType());
       card2.setManaCost(card.getManaCost());
       card2.addSpellAbility(new Spell_Permanent(card2));
       
       //ability3
       final SpellAbility ability3 = new Ability(card2, "0")
       {
         public void resolve()
         {
           card2.subtractCounter(Counters.LOYALTY, 9);
           turn[0] = AllZone.Phase.getTurn();

           String player = card2.getController();
           String opponent = AllZone.GameAction.getOpponent(player);
           
           PlayerZone play = AllZone.getZone(Constant.Zone.Play, opponent);
           CardList oppPerms = new CardList(play.getCards());
           
           PlayerLife life = AllZone.GameAction.getPlayerLife(opponent);
    	   life.subtractLife(7);
    	   
    	   for (int j=0; j<7; j++)
    	   {
    		   //will not actually let human choose which cards to discard
    		   AllZone.GameAction.discardRandom(opponent);
    	   }
    	   
    	   CardList permsToSac = new CardList();
    	   CardList oppPermTempList = new CardList(play.getCards());
           
           if (player.equals("Human"))
           {
        	   for(int k=0; k < oppPerms.size(); k++)
        	   {
        		   Card c = oppPerms.get(k);
        		   
        		   permsToSac.add(c);
        		   
        		   if (k == 6)
        			   break;
        	   }
           }
           
           else //computer
           {
        	   Object o = null;
        	   for(int k=0; k < oppPerms.size(); k++)
        	   {
        		   o = AllZone.Display.getChoiceOptional("Select Card to sacrifice", oppPermTempList.toArray());
        		   Card c = (Card)o;
        		   //AllZone.GameAction.sacrifice(c);
        		   permsToSac.add(c);
        		   oppPermTempList.remove(c);
        		   
        		           		   
        		   if (k == 6)
        			   break;
        	   }
           }
           for(int m=0;m<permsToSac.size();m++)
           {
        	   AllZone.GameAction.sacrifice(permsToSac.get(m));
           }

         }
         public boolean canPlay()
         {
           SpellAbility sa;
    	   for (int i=0; i<AllZone.Stack.size(); i++)
    	   {
    	    	     sa = AllZone.Stack.peek(i);
    	    	     if (sa.getSourceCard().equals(card2))
    	    	          return false;
    	   }
           return 9 <= card2.getCounters(Counters.LOYALTY) && AllZone.getZone(card2).is(Constant.Zone.Play) &&
               turn[0] != AllZone.Phase.getTurn() &&
               AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
               !AllZone.Phase.getPhase().equals("End of Turn");
         }//canPlay()
         public boolean canPlayAI()
         {
        	 return true;
         }
       };
       ability3.setBeforePayMana(new Input()
       {
		  private static final long serialVersionUID = 2946754243072466628L;
		  
		  int check = -1;
          public void showMessage()
          {
            if(check != AllZone.Phase.getTurn())
            {
              check = AllZone.Phase.getTurn();
              turn[0] = AllZone.Phase.getTurn();
              AllZone.Stack.push(ability3);
            }
            stop();
          }//showMessage()
       });
       
       final SpellAbility ability2 = new Ability(card2, "0")
       {
    	   
    	   public void resolve()
           {
    		   
    		 card2.subtractCounter(Counters.LOYALTY, 2);
    		 
    		 turn[0] = AllZone.Phase.getTurn();
    		 
    		 Card c = getTargetCard();
             if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card2,c))
             {
              //set summoning sickness
               if(c.getKeyword().contains("Haste")){
                 c.setSickness(false);
               }
               else{
                 c.setSickness(true);
               }
               
               ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
               ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);

               PlayerZone from = AllZone.getZone(c);
               from.remove(c);
              
               c.setController(card.getController());

               PlayerZone to = AllZone.getZone(Constant.Zone.Play, card.getController());
               to.add(c);

               ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
               ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
             }//if
    		 

           }//resolve()

    	   public boolean canPlayAI()
           {
    		 if (ability3.canPlay() && ability3.canPlayAI())
    		 {
    			 return false;
    		 }
             CardList c = CardFactoryUtil.AI_getHumanCreature(card, true);
             CardListUtil.sortAttack(c);
             CardListUtil.sortFlying(c);

             if(c.isEmpty())
               return false;

             if(2 <= c.get(0).getNetAttack() && c.get(0).getKeyword().contains("Flying"))
             {
               setTargetCard(c.get(0));
               return true;
             }

             CardListUtil.sortAttack(c);
             if(4 <= c.get(0).getNetAttack())
             {
               setTargetCard(c.get(0));
               return true;
             }

             return false;
           }//canPlayAI()

         public boolean canPlay()
         {
        	 
           SpellAbility sa;
    	   for (int i=0; i<AllZone.Stack.size(); i++)
    	   {
    	    	     sa = AllZone.Stack.peek(i);
    	    	     if (sa.getSourceCard().equals(card2))
    	    	          return false;
    	   }
           return 2 < card2.getCounters(Counters.LOYALTY) &&
                       AllZone.getZone(card2).is(Constant.Zone.Play) &&
                       turn[0] != AllZone.Phase.getTurn() &&
                       AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
                       !AllZone.Phase.getPhase().equals("End of Turn");
           
         }//canPlay()
       };//SpellAbility ability2

       ability2.setBeforePayMana(new Input()
       {
		  private static final long serialVersionUID = -1877437173665495402L;
		  
		  int check = -1;
          public void showMessage()
          {
            if(check != AllZone.Phase.getTurn())
            {
              check = AllZone.Phase.getTurn();
              turn[0] = AllZone.Phase.getTurn();
              
              
              AllZone.Stack.push(ability2);
            }
            stop();
          }//showMessage()
       });
       

       //ability 1: destroy target noncreature permanent
       final SpellAbility ability1 = new Ability(card2, "0")
       {
         public void resolve()
         {
           card2.addCounter(Counters.LOYALTY, 3);
           turn[0] = AllZone.Phase.getTurn();
           
           Card c = getTargetCard();
           AllZone.GameAction.destroy(c);
         }
         public boolean canPlayAI()
         {
           if(ability3.canPlay() && ability3.canPlayAI() || getNonCreaturePermanent() == null) {
             return false;
           } else
           {
             return true;
           }
         }
         public boolean canPlay()
         {
           SpellAbility sa;
    	   for (int i=0; i<AllZone.Stack.size(); i++)
    	   {
    	    	     sa = AllZone.Stack.peek(i);
    	    	     if (sa.getSourceCard().equals(card2))
    	    	          return false;
    	   }
           return 0 < card2.getCounters(Counters.LOYALTY) && AllZone.getZone(card2).is(Constant.Zone.Play) &&
               turn[0] != AllZone.Phase.getTurn() &&
               AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
               !AllZone.Phase.getPhase().equals("End of Turn");
         }//canPlay()
         
         public void chooseTargetAI()
         {
           Card c = getNonCreaturePermanent();
           
           if (getNonCreaturePermanent() != null)
        	   setTargetCard(c);
         }//chooseTargetAI()

         Card getNonCreaturePermanent()
         {
           PlayerZone play = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
           int highestCost = 0;
           Card bestCard = null;
           CardList nonCreaturePermanents = new CardList(play.getCards());
           nonCreaturePermanents = nonCreaturePermanents.filter(new CardListFilter()
           {

			public boolean addCard(Card c) {
				return CardFactoryUtil.canTarget(card2, c) && !c.isCreature();
			}
        	   
           });

           for(int i = 0; i < nonCreaturePermanents.size(); i++)
           {
             if(CardUtil.getConvertedManaCost(nonCreaturePermanents.get(i).getManaCost()) > highestCost)
             {
            	 highestCost = CardUtil.getConvertedManaCost(nonCreaturePermanents.get(i).getManaCost());
            	 bestCard = nonCreaturePermanents.get(i);
             }
           }
           if (bestCard == null && nonCreaturePermanents.size() > 0)
           {
        	   bestCard = nonCreaturePermanents.get(0);
        	   return bestCard;
           }
           
           return null;
         }
       };//SpellAbility ability1

       ability1.setBeforePayMana(new Input()
       {
		  private static final long serialVersionUID = 9167121234861249451L;
		  
		  int check = -1;
          public void showMessage()
          {
            if(check != AllZone.Phase.getTurn())
            {
              check = AllZone.Phase.getTurn();
              turn[0] = AllZone.Phase.getTurn();
              AllZone.Stack.push(ability1);
            }
            stop();
          }//showMessage()
       });

       ability1.setDescription("+3: Destroy target noncreature permanent.");
       ability1.setStackDescription("Nicol Bolas - Destroy target noncreature permanent.");
       ability1.setBeforePayMana(CardFactoryUtil.input_targetNonCreaturePermanent(ability1, Command.Blank));
       
       card2.addSpellAbility(ability1);
       
       ability2.setDescription("-2: Gain control of target creature.");
       ability2.setStackDescription("Nicol Bolas - Gain control of target creature.");
       ability2.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability2));
       
       card2.addSpellAbility(ability2);
      
       ability3.setDescription("-9: Nicol Bolas deals 7 damage to target player. That player discards 7 cards, then sacrifices 7 permanents.");
       ability3.setStackDescription("Nicol Bolas - deals 7 damage to target player. That player discards 7 cards, then sacrifices 7 permanents.");
       card2.addSpellAbility(ability3);

       return card2;
     }
     //*************** END ************ END **************************





//*************** START *********** START **************************
    if(cardName.equals("Ajani Goldmane"))
    {
      //computer only plays ability 1 and 3, gain life and put X\X token into play
      final int turn[] = new int[1];
      turn[0] = -1;

      final Card card2 = new Card()
      {
        public void addDamage(int n)
        {
          subtractCounter(Counters.LOYALTY,n);
          AllZone.GameAction.checkStateEffects();
        }
      };
      card2.addCounter(Counters.LOYALTY, 4);

      card2.setOwner(owner);
      card2.setController(owner);

      card2.setName(card.getName());
      card2.setType(card.getType());
      card2.setManaCost(card.getManaCost());
      card2.addSpellAbility(new Spell_Permanent(card2));

      //ability2: all controller's creatures get +1\+1 and vigilance until EOT
      final SpellAbility ability2 = new Ability(card2, "0")
      {
              final Command untilEOT = new Command()
          {
			private static final long serialVersionUID = -5436621445704076988L;

			public void execute()
            {
                String player = card2.getController();
                CardList creatures;
                if(player.equals(Constant.Player.Human)) {
                        creatures = new CardList(AllZone.Human_Play.getCards());
                } else {
                        creatures = new CardList(AllZone.Computer_Play.getCards());
                }
                
                creatures = creatures.getType("Creature");
                
                for (int i = 0; i < creatures.size(); i++) {
                        Card card = creatures.get(i);
                        //card.setAttack(card.getAttack() - 1);
                        //card.setDefense(card.getDefense() - 1);
                        card.removeExtrinsicKeyword("Vigilance");
                }
            }
          };

        public void resolve()
        {
          card2.subtractCounter(Counters.LOYALTY,1);
          turn[0] = AllZone.Phase.getTurn();

          String player = card2.getController();
          CardList creatures;
          if(player.equals(Constant.Player.Human)) {
                creatures = new CardList(AllZone.Human_Play.getCards());
          } else {
                creatures = new CardList(AllZone.Computer_Play.getCards());
          }
          
          creatures = creatures.getType("Creature");
          
          for (int i = 0; i < creatures.size(); i++) {
                  Card card = creatures.get(i);
                  card.addCounter(Counters.P1P1,1);
                  card.addExtrinsicKeyword("Vigilance");
          }

          AllZone.EndOfTurn.addUntil(untilEOT);
        }

        public boolean canPlayAI()
        {
          return false;
        }

        public boolean canPlay()
        {
          @SuppressWarnings("unused") // library
		  PlayerZone library = AllZone.getZone(Constant.Zone.Library, card2.getController());

          return 0 < card2.getCounters(Counters.LOYALTY) &&
                                  AllZone.getZone(card2).is(Constant.Zone.Play) &&
                      turn[0] != AllZone.Phase.getTurn() &&
                      AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
                      !AllZone.Phase.getPhase().equals("End of Turn");
          
        }//canPlay()
      };//SpellAbility ability2

      ability2.setBeforePayMana(new Input()
      {
		 private static final long serialVersionUID = 6373573398967821630L;
        int check = -1;
         public void showMessage()
         {
           if(check != AllZone.Phase.getTurn())
           {
             check = AllZone.Phase.getTurn();
             turn[0] = AllZone.Phase.getTurn();
             AllZone.Stack.push(ability2);
           }
           stop();
         }//showMessage()
      });

      //ability3
      final SpellAbility ability3 = new Ability(card2, "0")
      {
        public void resolve()
        {
          card2.subtractCounter(Counters.LOYALTY, 6);
          turn[0] = AllZone.Phase.getTurn();

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());

          //Create token
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setImageName("W N N Avatar");
          c.setName("Avatar");
          c.setManaCost("W");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Avatar");
          c.setBaseAttack(AllZone.GameAction.getPlayerLife(card.getController()).getLife());
          c.setBaseDefense(AllZone.GameAction.getPlayerLife(card.getController()).getLife());

          c.addIntrinsicKeyword("This creature's power and toughness are each equal to your life total.");

          play.add(c);
        }
        public boolean canPlay()
        {
          return 6 <= card2.getCounters(Counters.LOYALTY) && AllZone.getZone(card2).is(Constant.Zone.Play) &&
              turn[0] != AllZone.Phase.getTurn() &&
              AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
              !AllZone.Phase.getPhase().equals("End of Turn");
        }//canPlay()
        public boolean canPlayAI()
        {
                // may be it's better to put only if you have less than 5 life
                return true;
        }
      };
      ability3.setBeforePayMana(new Input()
      {
		 private static final long serialVersionUID = 7530960428366291386L;
		 
		 int check = -1;
         public void showMessage()
         {
           if(check != AllZone.Phase.getTurn())
           {
             check = AllZone.Phase.getTurn();
             turn[0] = AllZone.Phase.getTurn();
             AllZone.Stack.push(ability3);
           }
           stop();
         }//showMessage()
      });

      //ability 1: gain 2 life
      final SpellAbility ability1 = new Ability(card2, "0")
      {
        public void resolve()
        {
          card2.addCounter(Counters.LOYALTY, 1);
          turn[0] = AllZone.Phase.getTurn();
          
          
          AllZone.GameAction.getPlayerLife(card.getController()).addLife(2);
          System.out.println("current phase: " +AllZone.Phase.getPhase());
        }
        public boolean canPlayAI()
        {
          if(ability3.canPlay() && ability3.canPlayAI()) {
            return false;
          } else
          {
            return true;
          }
        }
        public boolean canPlay()
        {
          return 0 < card2.getCounters(Counters.LOYALTY) && AllZone.getZone(card2).is(Constant.Zone.Play) &&
              turn[0] != AllZone.Phase.getTurn() &&
              AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
              !AllZone.Phase.getPhase().equals("End of Turn");
        }//canPlay()
      };//SpellAbility ability1

      ability1.setBeforePayMana(new Input()
      {
		 private static final long serialVersionUID = -7969603493514210825L;
		 
		 int check = -1;
         public void showMessage()
         {
           if(check != AllZone.Phase.getTurn())
           {
             check = AllZone.Phase.getTurn();
             turn[0] = AllZone.Phase.getTurn();
             AllZone.Stack.push(ability1);
           }
           stop();
         }//showMessage()
      });

      ability1.setDescription("+1: You gain 2 life.");
      ability1.setStackDescription("Ajani Goldmane - " + card2.getController() +  " gains 2 life");
      card2.addSpellAbility(ability1);

      ability2.setDescription("-1: Put a +1/+1 counter on each creature you control. Those creatures gain vigilance until end of turn.");
      ability2.setStackDescription("Ajani Goldmane - Put a +1/+1 counter on each creature you control. They get vigilance.");
      card2.addSpellAbility(ability2);

      ability3.setDescription("-6: Put a white Avatar creature token into play with \"This creature's power and toughness are each equal to your life total.\"");
      ability3.setStackDescription("Ajani Goldmane - Put X\\X white Avatar creature token into play.");
      card2.addSpellAbility(ability3);

      return card2;
    }
    //*************** END ************ END **************************


    //contributed code
    //*************** START *********** START **************************
    if(cardName.equals("Dark Banishing"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -5621665629586583879L;
		
		Card check;

        public boolean canPlayAI()
        {
          check = getNonBlackCreature();
          return check != null;
        }

        public void chooseTargetAI()
        {
          Card c = getNonBlackCreature();
          if((c == null) || (! check.equals(c)))
            throw new RuntimeException(card +" error in chooseTargetAI() - Card c is " +c +",  Card check is " +check);

          setTargetCard(c);
        }//chooseTargetAI()

        Card getNonBlackCreature()
        {
          int maxAttack = 0;
          Card bestCard = null;
          CardList nonBlackCards = CardFactoryUtil.AI_getHumanCreature(card, true);

          for(int i = 0; i < nonBlackCards.size(); i++)
            if(!CardUtil.getColors(nonBlackCards.get(i)).contains(Constant.Color.Black))
              if(nonBlackCards.get (i).getNetAttack() > maxAttack)
          {
            maxAttack = nonBlackCards.get(i).getNetAttack();
            bestCard = nonBlackCards.get(i);
          }

          return bestCard;
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card,getTargetCard()))
          {
            AllZone.GameAction.destroyNoRegeneration(getTargetCard());
          }
        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      //target
      Input target = new Input()
      {
		private static final long serialVersionUID = -3155643868640376193L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target non-black creature for " +spell.getSourceCard());
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          if (!CardFactoryUtil.canTarget(card, c))
          {
        	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }
          else if((!CardUtil.getColors(c).contains(Constant.Color.Black))
             && c.isCreature()
             && zone.is(Constant.Zone.Play))
          {
            spell.setTargetCard(c);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }
      };//SpellAbility - target

      spell.setBeforePayMana(target);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Filthy Cur"))
    {
      final Card newCard = new Card()
      {
        public void addDamage(final int n)
        {
          super.addDamage(n);
          SpellAbility ability = new Ability(card, "0")
          {
            public void resolve()
            {
              AllZone.GameAction.getPlayerLife(getController()).subtractLife(n);
            }
          };
          ability.setStackDescription("Filthy Cur - causes " +n +" damage to " +getController());
          AllZone.Stack.add(ability);
        }//addDamage()
      };//Card

      newCard.setOwner(card.getOwner());
      newCard.setController(card.getController());

      newCard.setManaCost(card.getManaCost());
      newCard.setName(card.getName());
      newCard.addType("Creature");
      newCard.addType("Hound");
      newCard.setText(card.getSpellText());
      newCard.setBaseAttack(card.getBaseAttack());
      newCard.setBaseDefense(card.getBaseDefense());

      newCard.addSpellAbility(new Spell_Permanent(newCard));

      return newCard;
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Shinka Gatekeeper"))
    {
      final Card newCard = new Card()
      {
        public void addDamage(final int n)
        {
          super.addDamage(n);
          SpellAbility ability = new Ability(card, "0")
          {
            public void resolve()
            {
              AllZone.GameAction.getPlayerLife(getController()).subtractLife(n);
            }
          };
          ability.setStackDescription("Shinka Gatekeeper - causes " +n +" damage to " +getController());
          AllZone.Stack.add(ability);
        }//addDamage()
      };//Card

      newCard.setOwner(card.getOwner());
      newCard.setController(card.getController());

      newCard.setManaCost(card.getManaCost());
      newCard.setName(card.getName());
      newCard.addType("Creature");
      newCard.addType("Ogre");
      newCard.addType("Warrior");
      newCard.setText(card.getSpellText());
      newCard.setBaseAttack(card.getBaseAttack());
      newCard.setBaseDefense(card.getBaseDefense());

      newCard.addSpellAbility(new Spell_Permanent(newCard));

      return newCard;
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Jackal Pup"))
    {
      final Card newCard = new Card()
      {
        public void addDamage(final int n)
        {
          super.addDamage(n);
          SpellAbility ability = new Ability(card, "0")
          {
            public void resolve()
            {
              AllZone.GameAction.getPlayerLife(getController()).subtractLife(n);
            }
          };
          ability.setStackDescription("Jackal Pup - causes " +n +" damage to " +getController());
          AllZone.Stack.add(ability);
        }//addDamage()
      };//Card

      newCard.setOwner(card.getOwner());
      newCard.setController(card.getController());

      newCard.setManaCost(card.getManaCost());
      newCard.setName(card.getName());
      newCard.addType("Creature");
      newCard.addType("Hound");
      newCard.setText(card.getSpellText());
      newCard.setBaseAttack(card.getBaseAttack());
      newCard.setBaseDefense(card.getBaseDefense());

      newCard.addSpellAbility(new Spell_Permanent(newCard));

      return newCard;
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Stuffy Doll"))
    {
      final Card newCard = new Card()
      {
    	Card c = this;
        public void addDamage(final int n)
        {
          super.addDamage(n);
          final String opponent = AllZone.GameAction.getOpponent(owner);

          SpellAbility ability = new Ability(card, "0")
          {
            public void resolve()
            {
              AllZone.GameAction.getPlayerLife(opponent).subtractLife(n);
              
              if (c.getKeyword().contains("Lifelink"))
            	  GameActionUtil.executeLifeLinkEffects(c,n);
              for(int i=0; i < CardFactoryUtil.hasNumberEnchantments(c, "Guilty Conscience"); i++)
           	   GameActionUtil.executeGuiltyConscienceEffects(c, n);
            }
          };
          ability.setStackDescription("Stuffy Doll - causes " +n +" damage to " +opponent);
          AllZone.Stack.add(ability);
        }//addDamage()
      };//Card

      newCard.setOwner(card.getOwner());
      newCard.setController(card.getController());

      newCard.setManaCost(card.getManaCost());
      newCard.setName(card.getName());
      newCard.addType("Artifact");
      newCard.addType("Creature");
      newCard.addType("Construct");
      newCard.setText("Whenever damage is dealt to Stuffy Doll, it deals that much damage to your opponent.");
      newCard.setBaseAttack(0);
      newCard.setBaseDefense(1);

      newCard.addIntrinsicKeyword("Indestructible");

      final Ability_Tap ability = new Ability_Tap(newCard)
      {
		private static final long serialVersionUID = 577739727089395613L;

		public void resolve()
        {
          newCard.addDamage(1);
          
          if (newCard.getKeyword().contains("Lifelink"))
        	  GameActionUtil.executeLifeLinkEffects(newCard, 1);
          for(int i=0; i < CardFactoryUtil.hasNumberEnchantments(newCard, "Guilty Conscience"); i++)
       	   GameActionUtil.executeGuiltyConscienceEffects(newCard, 1);
        }
      };//SpellAbility
      ability.setDescription("tap: Stuffy Doll deals 1 damage to itself.");
      ability.setStackDescription("Stuffy Doll - deals 1 damage to itself.");
      ability.setBeforePayMana(new Input_NoCost_TapAbility(ability));

//      card.addSpellAbility(ability);
//      return card;
///*
      newCard.addSpellAbility(new Spell_Permanent(newCard));
      newCard.addSpellAbility(ability);

      return newCard;
//*/
    }//*************** END ************ END **************************


//    computer plays 2 land of these type instead of just 1 per turn

    //*************** START *********** START **************************
    //Ravinca Duel Lands
    if(cardName.equals("Blood Crypt") || cardName.equals("Breeding Pool") || cardName.equals("Godless Shrine") || cardName.equals("Hallowed Fountain") || cardName.equals("Overgrown Tomb") || cardName.equals("Sacred Foundry") || cardName.equals("Steam Vents") || cardName.equals("Stomping Ground") || cardName.equals("Temple Garden") || cardName.equals("Watery Grave"))
    {
      //if this isn't done, computer plays more than 1 copy
      //card.clearSpellAbility();
      card.clearSpellKeepManaAbility();

      card.addComesIntoPlayCommand(new Command()
      {
		private static final long serialVersionUID = 7352127748114888255L;
		
		public void execute()
        {
          if(card.getController().equals(Constant.Player.Human))
            humanExecute();
          else
            computerExecute();
        }
        public void computerExecute()
        {
          boolean pay = false;

          if(AllZone.Computer_Life.getLife() > 9)
            pay = MyRandom.random.nextBoolean();

          if(pay)
            AllZone.Computer_Life.subtractLife(2);
          else
            card.tap();
        }
        public void humanExecute()
        {
          PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
          if(2 < life.getLife())
          {
            String[] choices = {"Yes", "No"};
            Object o = AllZone.Display.getChoice("Pay 2 life?", choices);
            if(o.equals("Yes"))
              life.subtractLife(2);
            else
              tapCard();
          }//if
          else
            tapCard();
        }//execute()
        private void tapCard()
        {
          card.tap();
        }
      });
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Kabira Crossroads"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = card;
          PlayerLife life = AllZone.GameAction.getPlayerLife(c.getController());
          life.addLife(2);
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -4550013855602477643L;

		public void execute()
    	  {
			  card.tap();
    		  ability.setStackDescription(card.getName() + " - " +card.getController() +" gains 2 life");
    		  AllZone.Stack.add(ability);
    	  }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Graypelt Refuge")|| cardName.equals("Sejiri Refuge")|| cardName.equals("Jwar Isle Refuge") || 
       cardName.equals("Akoum Refuge")|| cardName.equals("Kazandu Refuge"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = card;
          c.tap();
          PlayerLife life = AllZone.GameAction.getPlayerLife(c.getController());
          life.addLife(1);
        }
      };
      Command intoPlay = new Command()
      {
      private static final long serialVersionUID = 5055232386220487221L;

      public void execute()
        {
    	  card.tap();
          ability.setStackDescription(card.getName() + " - " +card.getController() +" gains 1 life");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Faerie Conclave"))
    {
      card.addComesIntoPlayCommand(new Command()
      {
		private static final long serialVersionUID = 2792041290726604698L;

		public void execute()
        {
          card.tap();
        }
      });

      final Command eot1 = new Command()
      {
		private static final long serialVersionUID = 5106629534549783845L;

		public void execute()
        {
          Card c = card;

          c.setBaseAttack(0);
          c.setBaseDefense(0);
          c.removeIntrinsicKeyword("Flying");
          c.removeType("Creature");
          c.removeType("Faerie");
        }
      };

      final SpellAbility a1 = new Ability(card, "1 U")
      {
        public boolean canPlayAI()
        {
          return false;
        }
        public void resolve()
        {
          Card c = card;

          c.setBaseAttack(2);
          c.setBaseDefense(1);

          //to prevent like duplication like "Flying Flying Creature Creature"
          if(! c.getIntrinsicKeyword().contains("Flying"))
          {
            c.addIntrinsicKeyword("Flying");
            c.addType("Creature");
            c.addType("Faerie");
          }
          AllZone.EndOfTurn.addUntil(eot1);
        }
      };//SpellAbility
      card.setManaCost("U");

      card.clearSpellKeepManaAbility();
      card.addSpellAbility(a1);
      a1.setDescription("1U: Faerie Conclave becomes a 2/1 blue Faerie creature with flying until end of turn. It's still a land.");
      a1.setStackDescription(card +" becomes a 2/1 creature with flying until EOT");

      Command paid1 = new Command() {
		private static final long serialVersionUID = -601119544294387668L;
		public void execute() {AllZone.Stack.add(a1);}
	  };

      a1.setBeforePayMana(new Input_PayManaCost_Ability(a1.getManaCost(), paid1));

    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Forbidding Watchtower"))
    {
      card.addComesIntoPlayCommand(new Command()
      {
		private static final long serialVersionUID = 5212793782060828409L;

		public void execute()
        {
          card.tap();
        }
      });

      final Command eot1 = new Command()
      {
		private static final long serialVersionUID = 8806880921707550181L;

		public void execute()
        {
          Card c = card;

          c.setBaseAttack(0);
          c.setBaseDefense(0);
          c.removeType("Creature");
          c.removeType("Soldier");
        }
      };

      final SpellAbility a1 = new Ability(card, "1 W")
      {
        public boolean canPlayAI()
        {
          return false;
        }
        public void resolve()
        {
          Card c = card;

          c.setBaseAttack(1);
          c.setBaseDefense(5);

          //to prevent like duplication like "Creature Creature"
          if(! c.getType().contains("Creature"))
          {
            c.addType("Creature");
            c.addType("Soldier");
          }
          AllZone.EndOfTurn.addUntil(eot1);
        }
      };//SpellAbility

      card.clearSpellKeepManaAbility();
      card.addSpellAbility(a1);
      a1.setStackDescription(card +" becomes a 1/5 creature until EOT");

      Command paid1 = new Command() {
		private static final long serialVersionUID = -7211256926392695778L;
		public void execute() {AllZone.Stack.add(a1);}
      };

      a1.setBeforePayMana(new Input_PayManaCost_Ability(a1.getManaCost(), paid1));

    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Treetop Village"))
    {
      card.addComesIntoPlayCommand(new Command()
      {
		private static final long serialVersionUID = -2246560994818997231L;

		public void execute()
        {
          card.tap();
        }
      });

      final Command eot1 = new Command()
      {
		private static final long serialVersionUID = -8535770979347971863L;

		public void execute()
        {
          Card c = card;

          c.setBaseAttack(0);
          c.setBaseDefense(0);
          c.removeType("Creature");
          c.removeType("Ape");
          c.removeIntrinsicKeyword("Trample");
        }
      };

      final SpellAbility a1 = new Ability(card, "1 G")
      {
        public boolean canPlayAI()
        {
          return ! card.getType().contains("Creature");
        }
        public void resolve()
        {
          Card c = card;

          c.setBaseAttack(3);
          c.setBaseDefense(3);

          //to prevent like duplication like "Creature Creature"
          if(! c.getIntrinsicKeyword().contains("Trample"))
          {
            c.addType("Creature");
            c.addType("Ape");
            c.addIntrinsicKeyword("Trample");
          }
          AllZone.EndOfTurn.addUntil(eot1);
        }
      };//SpellAbility

      card.clearSpellKeepManaAbility();
      card.addSpellAbility(a1);
      a1.setStackDescription(card +" becomes a 3/3 creature with trample until EOT");

      Command paid1 = new Command() {
		private static final long serialVersionUID = -6800983290478844750L;

		public void execute() {AllZone.Stack.add(a1);}
	  };

      a1.setBeforePayMana(new Input_PayManaCost_Ability(a1.getManaCost(), paid1));

    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Serra Avenger"))
    {
      SpellAbility spell = new Spell_Permanent(card)
      {
		private static final long serialVersionUID = -1148518222979323313L;

		public boolean canPlay()
        {
          return super.canPlay() && 6 < AllZone.Phase.getTurn();
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }
    //*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Force of Savagery"))
    {
      SpellAbility spell = new Spell_Permanent(card)
      {
		private static final long serialVersionUID = 1603238129819160467L;

		public boolean canPlayAI()
        {
          CardList list = new CardList(AllZone.Computer_Play.getCards());

          return list.containsName("Glorious Anthem") || list.containsName("Gaea's Anthem");
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }
    //*************** END ************ END **************************

    //*************** START *********** START **************************
    if(cardName.equals("Pyrohemia"))
    {
      SpellAbility ability = new Ability(card, "R")
      {
        public boolean canPlayAI()
        {
          CardList human    = new CardList(AllZone.Human_Play.getCards());
          CardList computer = new CardList(AllZone.Computer_Play.getCards());

          human = human.getType("Creature");
          computer = computer.getType("Creature");

          return AllZone.Computer_Life.getLife() > 2 && !(human.size() == 0 && 0 < computer.size());
        }
        public void resolve()
        {
          //get all creatures
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.getType("Creature");

          for(int i = 0; i < list.size(); i++){
        	  if (CardFactoryUtil.canDamage(card, list.get(i)))
        		  list.get(i).addDamage(1);
          }
          
          AllZone.Human_Life.subtractLife(1);
          AllZone.Computer_Life.subtractLife(1);
        }//resolve()
      };//SpellAbility
      ability.setDescription("R: Pyrohemia deals 1 damage to each creature and each player.");
      ability.setStackDescription(card +" deals 1 damage to each creature and each player.");

      card.clearSpellAbility();
     card.addSpellAbility(new Spell_Permanent(card)
     {
	   private static final long serialVersionUID = 5596915641671666843L;

	   public boolean canPlayAI()
       {
         //get all creatures
         CardList list = new CardList();
         list.addAll(AllZone.Human_Play.getCards());
         list.addAll(AllZone.Computer_Play.getCards());
         list = list.getType("Creature");

         return 0 < list.size();
       }
      });

      card.addSpellAbility(ability);
    }
    //*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Pestilence"))
    {
      SpellAbility ability = new Ability(card, "B")
      {
        public boolean canPlayAI()
        {
          CardList human    = new CardList(AllZone.Human_Play.getCards());
          CardList computer = new CardList(AllZone.Computer_Play.getCards());

          human = human.getType("Creature");
          computer = computer.getType("Creature");

          return AllZone.Computer_Life.getLife() > 2 && !(human.size() == 0 && 0 < computer.size());
        }
        public void resolve()
        {
          //get all creatures
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.getType("Creature");

          for(int i = 0; i < list.size(); i++) {
        	  if (CardFactoryUtil.canDamage(card, list.get(i)))
        		  list.get(i).addDamage(1);
          }
        	  
          AllZone.Human_Life.subtractLife(1);
          AllZone.Computer_Life.subtractLife(1);
        }//resolve()
      };//SpellAbility
      ability.setDescription("B: Pestilence deals 1 damage to each creature and each player.");
      ability.setStackDescription(card +" deals 1 damage to each creature and each player.");

      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = -4163089323122672307L;

		public boolean canPlayAI()
        {
          //get all creatures
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.getType("Creature");

          return 0 < list.size();
        }
      });

      card.addSpellAbility(ability);
    }
    //*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Greater Forgeling"))
    {
      final Command untilEOT = new Command()
      {
		private static final long serialVersionUID = -4569751606008597903L;

		public void execute()
        {
          if(AllZone.GameAction.isCardInPlay(card))
          {
            card.addTempAttackBoost(-3);
            card.addTempDefenseBoost(3);
          }
        }
      };

      SpellAbility ability = new Ability(card, "1 R")
      {
        public boolean canPlayAI()
        {
          return MyRandom.random.nextBoolean() && CardFactoryUtil.AI_doesCreatureAttack(card) &&
              3 < card.getNetDefense();
        }
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(card))
          {
            card.addTempAttackBoost(3);
            card.addTempDefenseBoost(-3);
            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }
      };

      ability.setDescription("1 R: Greater Forgeling gets +3/-3 until end of turn.");
      ability.setStackDescription(card +" gets +3/-3 until end of turn.");
      card.addSpellAbility(ability);
    }
    //*************** END ************ END **************************

    //*************** START *********** START **************************
    if(cardName.equals("Liliana Vess"))
    {
      //computer only plays ability 1 and 3, discard and return creature from graveyard to play
      final int turn[] = new int[1];
      turn[0] = -1;

      final Card card2 = new Card()
      {
        public void addDamage(int n)
        {
          subtractCounter(Counters.LOYALTY,n);
          AllZone.GameAction.checkStateEffects();
        }
      };
      card2.addCounter(Counters.LOYALTY, 5);

      card2.setOwner(owner);
      card2.setController(owner);

      card2.setName(card.getName());
      card2.setType(card.getType());
      card2.setManaCost(card.getManaCost());
      card2.addSpellAbility(new Spell_Permanent(card2));

      //ability2
      final SpellAbility ability2 = new Ability(card2, "0")
      {
        public void resolve()
        {
          card2.subtractCounter(Counters.LOYALTY, 2);
          turn[0] = AllZone.Phase.getTurn();

          String player = card2.getController();
          if(player.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void computerResolve()
        {
          CardList creature = new CardList(AllZone.Computer_Library.getCards());
          creature = creature.getType("Creature");
          if(creature.size() != 0)
          {
            Card c = creature.get(0);
            AllZone.GameAction.shuffle(card2.getController());

            //move to top of library
            AllZone.Computer_Library.remove(c);
            AllZone.Computer_Library.add(c, 0);
          }
        }//computerResolve()
        public void humanResolve()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card2.getController());

          CardList list = new CardList(library.getCards());

          if(list.size() != 0)
          {
            Object o = AllZone.Display.getChoiceOptional("Select any card", list.toArray());

            AllZone.GameAction.shuffle(card2.getController());
            if(o != null)
            {
              //put creature on top of library
              library.remove(o);
              library.add((Card)o, 0);
            }
          }//if
        }//resolve()
        public boolean canPlayAI()
        {
          return false;
        }

        public boolean canPlay()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card2.getController());

          return 2 <= card2.getCounters(Counters.LOYALTY)                  &&
                      AllZone.getZone(card2).is(Constant.Zone.Play) &&
                      1 < library.size()                            &&
                      turn[0] != AllZone.Phase.getTurn() &&
                      AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
                      !AllZone.Phase.getPhase().equals("End of Turn");
        }//canPlay()
      };//SpellAbility ability2

      ability2.setBeforePayMana(new Input()
      {
		 private static final long serialVersionUID = 5726590384281714755L;
		
		 int check = -1;
         public void showMessage()
         {
           if(check != AllZone.Phase.getTurn())
           {
             check = AllZone.Phase.getTurn();
             turn[0] = AllZone.Phase.getTurn();
             AllZone.Stack.push(ability2);
           }
           stop();
         }//showMessage()
      });

      //ability3
      final SpellAbility ability3 = new Ability(card2, "0")
      {
        public void resolve()
        {
          card2.subtractCounter(Counters.LOYALTY, 8);
          turn[0] = AllZone.Phase.getTurn();

          //get all graveyard creatures
          CardList list = new CardList();
          list.addAll(AllZone.Human_Graveyard.getCards());
          list.addAll(AllZone.Computer_Graveyard.getCards());
          list = list.getType("Creature");

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card2.getController());
          PlayerZone grave = null;
          Card c = null;
          for(int i = 0; i < list.size(); i++)
          {
            //this is a rough hack, but no one will ever see this code anyways, lol ;+)
            c = list.get(i);
            c.setController(card.getController());

            grave = AllZone.getZone(c);
            if(grave != null)
              grave.remove(c);

            play.add(c);
          }
        }
        public boolean canPlay()
        {
          return 8 <= card2.getCounters(Counters.LOYALTY) && AllZone.getZone(card2).is(Constant.Zone.Play) &&
              turn[0] != AllZone.Phase.getTurn() &&
              AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
              !AllZone.Phase.getPhase().equals("End of Turn");
        }//canPlay()
        public boolean canPlayAI()
        {
          CardList list = new CardList();
          list.addAll(AllZone.Human_Graveyard.getCards());
          list.addAll(AllZone.Computer_Graveyard.getCards());
          list = list.getType("Creature");

          return 3 < list.size();
        }
      };
      ability3.setBeforePayMana(new Input()
      {
		 private static final long serialVersionUID = -3297439284172874241L;
		
		 int check = -1;
         public void showMessage()
         {
           if(check != AllZone.Phase.getTurn())
           {
             check = AllZone.Phase.getTurn();
             turn[0] = AllZone.Phase.getTurn();
             AllZone.Stack.push(ability3);
           }
           stop();
         }//showMessage()
      });

      //ability 1
      final SpellAbility ability1 = new Ability(card2, "0")
      {
        public void resolve()
        {
          card2.addCounter(Counters.LOYALTY,1);
          turn[0] = AllZone.Phase.getTurn();

          String s = getTargetPlayer();
          setStackDescription("Liliana Vess - " +s +" discards a card");

          if(s.equals(Constant.Player.Human))
            AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
          else
            AllZone.GameAction.discardRandom(Constant.Player.Computer);
        }
        public boolean canPlayAI()
        {
          if(ability3.canPlay() && ability3.canPlayAI())
            return false;
          else
          {
            setTargetPlayer(Constant.Player.Human);
            return true;
          }
        }
        public boolean canPlay()
        {
          return 0 < card2.getCounters(Counters.LOYALTY) && AllZone.getZone(card2).is(Constant.Zone.Play) &&
              turn[0] != AllZone.Phase.getTurn() &&
              AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
              !AllZone.Phase.getPhase().equals("End of Turn");
        }//canPlay()
      };//SpellAbility ability1

      Input target = new Input()
      {
		private static final long serialVersionUID = 4997055112713151705L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target player");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectPlayer(String player)
        {
          turn[0] = AllZone.Phase.getTurn();
          ability1.setTargetPlayer(player);
          AllZone.Stack.add(ability1);
          stop();
        }
      };//Input target
      ability1.setBeforePayMana(target);
      ability1.setDescription("+1: Target player discards a card.");
      card2.addSpellAbility(ability1);

      ability2.setDescription("-2: Search your library for a card, then shuffle your library and put that card on top of it.");
      ability2.setStackDescription("Liliana Vess - Search your library for a card, then shuffle your library and put that card on top of it.");
      card2.addSpellAbility(ability2);

      ability3.setDescription("-8: Put all creature cards in all graveyards into play under your control.");
      ability3.setStackDescription("Liliana Vess - Put all creature cards in all graveyards into play under your control.");
      card2.addSpellAbility(ability3);

      return card2;
    }
    //*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Chandra Nalaar"))
    {
      //computer only plays ability 1 and 3, discard and return creature from graveyard to play
      final int turn[] = new int[1];
      turn[0] = -1;

      final Card card2 = new Card()
      {
        public void addDamage(int n)
        {
          subtractCounter(Counters.LOYALTY, n);
          AllZone.GameAction.checkStateEffects();
        }
      };
      card2.addCounter(Counters.LOYALTY, 6);

      card2.setOwner(owner);
      card2.setController(owner);

      card2.setName(card.getName());
      card2.setType(card.getType());
      card2.setManaCost(card.getManaCost());
      card2.addSpellAbility(new Spell_Permanent(card2));

      //ability 1
      final SpellAbility ability1 = new Ability(card2, "0")
      {
        public void resolve()
        {
          card2.addCounter(Counters.LOYALTY, 1);
          turn[0] = AllZone.Phase.getTurn();
          
          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card2,getTargetCard()))
            {
              Card c = getTargetCard();
              if (CardFactoryUtil.canDamage(card2, c))
            	  c.addDamage(1);
            }
          }
          
          else
          {
	          PlayerLife life = AllZone.GameAction.getPlayerLife(getTargetPlayer());
	          life.subtractLife(1);
          }
        }
        public boolean canPlay()
        {
          SpellAbility sa;
	      for (int i=0; i<AllZone.Stack.size(); i++)
	      {
	    	     sa = AllZone.Stack.peek(i);
	    	     if (sa.getSourceCard().equals(card2))
	    	          return false;
	      }
			
          return AllZone.getZone(card2).is(Constant.Zone.Play) &&
                 turn[0] != AllZone.Phase.getTurn() &&
                 AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
                 !AllZone.Phase.getPhase().equals("End of Turn");
        }
        public boolean canPlayAI()
        {
          setTargetPlayer(Constant.Player.Human);
          setStackDescription("Chandra Nalaar - deals 1 damage to " +Constant.Player.Human);
          return card2.getCounters(Counters.LOYALTY) < 8;
        }
      };//SpellAbility ability1

      Input target1 = new Input()
      {
		private static final long serialVersionUID = 5263705146686766284L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target Player or Planeswalker");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if(card.isPlaneswalker() && zone.is(Constant.Zone.Play))
          {
            ability1.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(ability1));
          }
        }//selectCard()
        public void selectPlayer(String player)
        {
          ability1.setTargetPlayer(player);
          stopSetNext(new Input_PayManaCost(ability1));
        }
      };
      ability1.setBeforePayMana(target1);
      ability1.setDescription("+1: Chandra Nalaar deals 1 damage to target player.");
      card2.addSpellAbility(ability1);
      //end ability1




      //ability 2
      final int damage2[] = new int[1];

      final SpellAbility ability2 = new Ability(card2, "0")
      {
        public void resolve()
        {
          turn[0] = AllZone.Phase.getTurn();

          card2.subtractCounter(Counters.LOYALTY, damage2[0]);
          if (CardFactoryUtil.canDamage(card2, getTargetCard()))
        	  getTargetCard().addDamage(damage2[0]);

          damage2[0] = 0;
        }//resolve()
        public boolean canPlay()
        {
          SpellAbility sa;
  	      for (int i=0; i<AllZone.Stack.size(); i++)
  	      {
  	    	     sa = AllZone.Stack.peek(i);
  	    	     if (sa.getSourceCard().equals(card2))
  	    	          return false;
  	      }

          return AllZone.getZone(card2).is(Constant.Zone.Play) &&
                 turn[0] != AllZone.Phase.getTurn() &&
                 AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
                 !AllZone.Phase.getPhase().equals("End of Turn");
        }
        public boolean canPlayAI()
        {
          return false;
        }
      };//SpellAbility ability2

      Input target2 = new Input()
      {
		private static final long serialVersionUID = -2160464080456452897L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target creature");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          if(!CardFactoryUtil.canTarget(card, c)){
          	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }
          else if(c.isCreature())
          {
            turn[0] = AllZone.Phase.getTurn();


            damage2[0] = getDamage();

            ability2.setTargetCard(c);
            ability2.setStackDescription("Chandra Nalaar - deals damage to " +c);

            AllZone.Stack.add(ability2);
            stop();
          }
        }//selectCard()
        int getDamage()
        {
          int size = card2.getCounters(Counters.LOYALTY);
          Object choice[] = new Object[size];

          for(int i = 0; i < choice.length; i++)
            choice[i] = new Integer(i + 1);

           Integer damage = (Integer) AllZone.Display.getChoice("Select X", choice);
           return damage.intValue();
        }
      };//Input target
      ability2.setBeforePayMana(target2);
      ability2.setDescription("-X: Chandra Nalaar deals X damage to target creature.");
      card2.addSpellAbility(ability2);
      //end ability2



      //ability 3
      final SpellAbility ability3 = new Ability(card2, "0")
      {
        public void resolve()
        {
          card2.subtractCounter(Counters.LOYALTY, 8);
          turn[0] = AllZone.Phase.getTurn();

          PlayerLife life = AllZone.GameAction.getPlayerLife(getTargetPlayer());
          life.subtractLife(10);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, getTargetPlayer());
          CardList list = new CardList(play.getCards());
          list = list.getType("Creature");

          for(int i = 0; i < list.size(); i++)
          { 
        	  if (CardFactoryUtil.canDamage(card, list.get(i)))
        		  list.get(i).addDamage(10);
          }
        }//resolve()
        public boolean canPlay()
        {
        	
          SpellAbility sa;
  	      for (int i=0; i<AllZone.Stack.size(); i++)
  	      {
  	    	     sa = AllZone.Stack.peek(i);
  	    	     if (sa.getSourceCard().equals(card2))
  	    	          return false;
  	      }
  			
          return AllZone.getZone(card2).is(Constant.Zone.Play) &&
                 turn[0] != AllZone.Phase.getTurn()            &&
                 7 < card2.getCounters(Counters.LOYALTY) &&
          		 AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
          		!AllZone.Phase.getPhase().equals("End of Turn");
        }
        public boolean canPlayAI()
        {
          setTargetPlayer(Constant.Player.Human);
          setStackDescription("Chandra Nalaar - deals 10 damage to " +Constant.Player.Human +" and each creature he or she controls.");
          return true;
        }
      };//SpellAbility ability3

      Input target3 = new Input()
      {
		private static final long serialVersionUID = -3014450919506364666L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target player");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectPlayer(String player)
        {
          turn[0] = AllZone.Phase.getTurn();

          ability3.setTargetPlayer(player);
          ability3.setStackDescription("Chandra Nalaar - deals 10 damage to " +player +" and each creature he or she controls.");

          AllZone.Stack.add(ability3);
          stop();
        }
      };//Input target
      ability3.setBeforePayMana(target3);
      ability3.setDescription("-8: Chandra Nalaar deals 10 damage to target player and each creature he or she controls.");
      card2.addSpellAbility(ability3);
      //end ability3

      return card2;
    }
    //*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Garruk Wildspeaker"))
    {
      final int turn[] = new int[1];
      turn[0] = -1;

      final Card card2 = new Card()
      {
        public void addDamage(int n)
        {
          subtractCounter(Counters.LOYALTY,n);
          AllZone.GameAction.checkStateEffects();
        }
      };
      card2.addCounter(Counters.LOYALTY,3);

      card2.setOwner(owner);
      card2.setController(owner);

      card2.setName(card.getName());
      card2.setType(card.getType());
      card2.setManaCost(card.getManaCost());
      card2.addSpellAbility(new Spell_Permanent(card2));

      //ability1
      final SpellAbility ability1 = new Ability(card2, "0")
      {
        public void resolve()
        {
          card2.addCounter(Counters.LOYALTY, 1);

          turn[0] = AllZone.Phase.getTurn();

          //only computer uses the stack
          CardList tapped = new CardList(AllZone.Computer_Play.getCards());
          tapped = tapped.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isLand() && c.isTapped();
            }
          });

          for(int i = 0; i < 2 && i < tapped.size(); i++)
            tapped.get(i).untap();
        }//resolve()
        public boolean canPlayAI()
        {
          return card2.getCounters(Counters.LOYALTY) < 4 && AllZone.Phase.getPhase().equals(Constant.Phase.Main2);
        }
        public boolean canPlay()
        {
          return  AllZone.getZone(card2).is(Constant.Zone.Play) &&
                  turn[0] != AllZone.Phase.getTurn() &&
                  AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
                  !AllZone.Phase.getPhase().equals("End of Turn");
        }//canPlay()
      };
      final Input targetLand = new Input()
      {
		private static final long serialVersionUID = -6609158314106861676L;
		
		private int count;
        public void showMessage()
        {
          AllZone.Display.showMessage("Select a land to untap");
          ButtonUtil.disableAll();
        }
        public void selectCard(Card c, PlayerZone zone)
        {
          if(c.isLand() && zone.is(Constant.Zone.Play))
          {
            count++;
            c.untap();
          }

          //doesn't use the stack, its just easier this way
          if(count == 2)
          {
            count = 0;
            turn[0] = AllZone.Phase.getTurn();
            card2.addCounter(Counters.LOYALTY,1);
            stop();
          }
        }//selectCard()
      };//Input

      Input runtime1 = new Input()
      {
		private static final long serialVersionUID = 8709088526618867662L;

		public void showMessage()
        {
          stopSetNext(targetLand);
        }
      };//Input
      ability1.setDescription("+1: Untap two target lands.");
      ability1.setStackDescription("Garruk Wildspeaker - Untap two target lands.");

      ability1.setBeforePayMana(runtime1);
      card2.addSpellAbility(ability1);
      //end ability 1


      //start ability 2
      final SpellAbility ability2 = new Ability(card2, "0")
      {
        public void resolve()
        {
          card2.subtractCounter(Counters.LOYALTY,1);
          turn[0] = AllZone.Phase.getTurn();

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card2.getController());
          play.add(getToken());
        }
        Card getToken()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());
          
          c.setImageName("G 3 3 Beast");
          c.setName("Beast");
          c.setManaCost("G");
          c.setToken(true);
          //c.addKeyword("Token");

          c.addType("Creature");
          c.addType("Beast");
          c.setBaseAttack(3);
          c.setBaseDefense(3);

          return c;
        }//makeToken()

        public boolean canPlay()
        {
          return  AllZone.getZone(card2).is(Constant.Zone.Play) &&
                  turn[0] != AllZone.Phase.getTurn() &&
                  0 < card2.getCounters(Counters.LOYALTY) &&
                  AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
                  !AllZone.Phase.getPhase().equals("End of Turn");
        }//canPlay()
        public boolean canPlayAI()
        {
          CardList c = new CardList(AllZone.Computer_Play.getCards());
          c = c.getType("Creature");
          return c.size() < 4;
        }
      };//SpellAbility ability 2
      Input runtime2 = new Input()
      {
		private static final long serialVersionUID = -1718455991391244845L;
		
		int check = -1;
        public void showMessage()
        {
          if(check != AllZone.Phase.getTurn())
          {
            check = AllZone.Phase.getTurn();
            turn[0] = AllZone.Phase.getTurn();

            AllZone.Stack.push(ability2);
            stop();
          }
        }
      };//Input
      ability2.setStackDescription(card2.getName() +" -  Put a 3/3 green Beast creature token into play.");
      ability2.setDescription("-1: Put a 3/3 green Beast creature token into play.");
      ability2.setBeforePayMana(runtime2);
      card2.addSpellAbility(ability2);
      //end ability 2


      //start ability 3
      final SpellAbility ability3 = new Ability(card2, "0")
      {
        public void resolve()
        {
          card2.subtractCounter(Counters.LOYALTY, 4);
          turn[0] = AllZone.Phase.getTurn();

          final int boost = 3;
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card2.getController());
          CardList list = new CardList(play.getCards());
          @SuppressWarnings("unused") // c
          Card c;

          for(int i = 0; i < list.size(); i++)
          {
            final Card[] target = new Card[1];
            target[0] = list.get(i);

            final Command untilEOT = new Command()
            {
			  private static final long serialVersionUID = 478068133055335098L;

			  public void execute()
              {
                if(AllZone.GameAction.isCardInPlay(target[0]))
                {
                  target[0].addTempAttackBoost(-boost);
                  target[0].addTempDefenseBoost(-boost);

                  target[0].removeExtrinsicKeyword("Trample");
                }
              }
            };//Command

            if(AllZone.GameAction.isCardInPlay(target[0]))
            {
              target[0].addTempAttackBoost(boost);
              target[0].addTempDefenseBoost(boost);

              target[0].addExtrinsicKeyword("Trample");

              AllZone.EndOfTurn.addUntil(untilEOT);
            }//if
          }//for

        }//resolve()
        public boolean canPlay()
        {
          return  AllZone.getZone(card2).is(Constant.Zone.Play) &&
                  turn[0] != AllZone.Phase.getTurn() &&
                  3 < card2.getCounters(Counters.LOYALTY) &&
          		  AllZone.Phase.getActivePlayer().equals(card2.getController()) &&
          		  !AllZone.Phase.getPhase().equals("End of Turn");
        }//canPlay()
        public boolean canPlayAI()
        {
          CardList c = new CardList(AllZone.Computer_Play.getCards());
          c = c.getType("Creature");
          return c.size() >= 4 && AllZone.Phase.getPhase().equals(Constant.Phase.Main1) && 
          AllZone.Phase.getActivePlayer().equals(card2.getController());
        }
      };//SpellAbility ability3
      Input runtime3 = new Input()
      {
		private static final long serialVersionUID = 7697504647440222302L;
		
		int check = -1;
        public void showMessage()
        {
          if(check != AllZone.Phase.getTurn())
          {
            check = AllZone.Phase.getTurn();
            turn[0] = AllZone.Phase.getTurn();

            AllZone.Stack.push(ability3);
            stop();
          }
        }
      };//Input
      ability3.setStackDescription(card2.getName() +" -  Creatures you control get +3/+3 and trample until end of turn.");
      ability3.setDescription("-4: Creatures you control get +3/+3 and trample until end of turn.");
      ability3.setBeforePayMana(runtime3);
      card2.addSpellAbility(ability3);
      //end ability 3

      return card2;
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Caller of the Claw"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          int stop = countGraveyard();
          for(int i = 0; i < stop; i++)
            makeToken();
        }//resolve()
        int countGraveyard()
        {
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          CardList list = new CardList(grave.getCards());
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isCreature() && (c.getTurnInZone() == AllZone.Phase.getTurn());
            }
          });
          return list.size();
        }//countGraveyard()
        void makeToken()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());
          
          c.setImageName("G 2 2 Bear");
          c.setName("Bear");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Bear");
          c.setBaseAttack(2);
          c.setBaseDefense(2);

          play.add(c);
        }//makeToken()
      };//SpellAbility

      Command comesIntoPlay = new Command()
      {
		private static final long serialVersionUID = 8485080996453793968L;

		public void execute()
        {
          AllZone.Stack.add(ability);
        }
      };//Command
      ability.setStackDescription("Caller of the Claw - Put a 2/2 green Bear creature token into play for each nontoken creature put into your graveyard from play this turn.");
      card.addComesIntoPlayCommand(comesIntoPlay);

      SpellAbility spell = new Spell_Permanent(card)
      {
		private static final long serialVersionUID = 6946020026681536710L;

		public boolean canPlayAI() {return super.canPlay();}
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Kiki-Jiki, Mirror Breaker"))
    {
      final SpellAbility ability = new Ability_Tap(card)
      {
		private static final long serialVersionUID = -943706942500499644L;
		
		public boolean canPlayAI() {return getCreature().size() != 0;}
        public void chooseTargetAI()
        {
          setTargetCard(getCreature().get(0));
        }
        CardList getCreature()
        {
          CardList list = null;
          if(card.getController().equals(Constant.Player.Human)){
             list = new CardList(AllZone.Human_Play.getCards());
          }
          else{
             list = new CardList(AllZone.Computer_Play.getCards());
          }

          list = list.getType("Creature");
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (!c.getType().contains("Legendary") );
            }
          });
          CardListUtil.sortAttack(list);
          return list;
        }//getCreature()
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && getTargetCard().getController().equals(card.getController()) 
       		  && CardFactoryUtil.canTarget(card,getTargetCard()) )
          {
        	Card copy;
        	if (!getTargetCard().isToken())
        	{
	            //copy creature and put it into play
	            copy = getCard(getTargetCard().getName(), card.getController());
	            copy.setToken(true);
	            
	            if (getTargetCard().isFaceDown()) {
	            	copy.setIsFaceDown(true);
	            	copy.setManaCost("");
	            	copy.setBaseAttack(2);
	            	copy.setBaseDefense(2);
	            	copy.setIntrinsicKeyword(new ArrayList<String>()); //remove all keywords
	    			copy.setType(new ArrayList<String>()); //remove all types
	    			copy.addType("Creature");
	    			copy.clearSpellAbility(); //disallow "morph_up"
	            }
	            copy.addIntrinsicKeyword("Haste");
        	}
        	else //isToken()
        	{
        		Card c = getTargetCard();
        		copy = new Card();
        		
        		copy.setName(c.getName());

                copy.setOwner(c.getController());
                copy.setController(c.getController());

                copy.setManaCost(c.getManaCost());
                copy.setToken(true);

                copy.setType(c.getType());

                copy.setBaseAttack(c.getBaseAttack());
                copy.setBaseDefense(c.getBaseDefense());
                copy.addIntrinsicKeyword("Haste");
        	}

            PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
            play.add(copy);


            //have to do this since getTargetCard() might change
            //if Kiki-Jiki somehow gets untapped again
            final Card[] target = new Card[1];
            target[0] = copy;
            Command atEOT = new Command()
            {
			  private static final long serialVersionUID = 7803915905490565557L;
              public void execute()
              {
                //technically your opponent could steal the token
                //and the token shouldn't be sacrificed
                if(AllZone.GameAction.isCardInPlay(target[0]))
                  AllZone.GameAction.sacrifice(target[0]); //maybe do a setSacrificeAtEOT, but probably not.
              }
            };//Command
            AllZone.EndOfTurn.addAt(atEOT);
          }//is card in play?
        }//resolve()
      };//SpellAbility

      Input runtime = new Input()
      {
		private static final long serialVersionUID = 7171284831370490875L;

		public void showMessage()
        {
          //get all non-legendary creatures you control
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isCreature() &&
                  (!c.getType().contains("Legendary"));
            }
          });
          stopSetNext(CardFactoryUtil.input_targetSpecific(ability, list, "Select target creature to copy that is not legendary.", true));
        }
      };//Input
      ability.setStackDescription("Kiki-Jiki - copy card.");
      ability.setDescription("tap: Put a token into play that's a copy of target nonlegendary creature you control. That creature token has haste. Sacrifice it at end of turn.");
      ability.setBeforePayMana(runtime);
      card.addSpellAbility(ability);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Nevinyrral's Disk"))
    {
      SpellAbility summoningSpell = new Spell_Permanent(card)
      {
		private static final long serialVersionUID = -8859376851358601934L;

		public boolean canPlayAI()
        {
          boolean nevinyrralInPlay = false;

          CardList inPlay = new CardList();
          inPlay.addAll(AllZone.Computer_Play.getCards());
          for(int i=0; i<inPlay.size(); ++i)
          {
            if( inPlay.getCard(i).getName().equals("Nevinyrral's Disk"))
            {
              nevinyrralInPlay = true;
            }
          }
          return ! nevinyrralInPlay && (0 < CardFactoryUtil.AI_getHumanCreature(card, false).size());
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(summoningSpell);

      card.addComesIntoPlayCommand(new Command()
      {
		private static final long serialVersionUID = -2504426622672629123L;

		public void execute()
        {
          card.tap();
        }
      });
      final SpellAbility ability = new Ability_Tap(card, "1")
      {
		private static final long serialVersionUID = 4175577092552330100L;
		
		public void resolve()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());
          all = filter(all);

          for(int i = 0; i < all.size(); i++)
            AllZone.GameAction.destroy(all.get(i));
        }
        private CardList filter(CardList list)
        {
          return list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isArtifact() || c.isCreature() || c.isEnchantment();
            }
          });
        }//filter()
        public boolean canPlayAI()
        {
          CardList human    = new CardList(AllZone.Human_Play.getCards());
          CardList computer = new CardList(AllZone.Computer_Play.getCards());

          human    = human.getType("Creature");
          computer = computer.getType("Creature");

          //the computer will at least destroy 2 more human creatures
          return computer.size() < human.size()-1 || AllZone.Computer_Life.getLife() < 7;
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("1, tap: Destroy all artifacts, creatures, and enchantments.");
      ability.setStackDescription("Destroy all artifacts, creatures, and enchantments.");
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Magus of the Disk"))
    {
      SpellAbility summoningSpell = new Spell_Permanent(card)
      {
		private static final long serialVersionUID = 2510163318362956239L;

		public boolean canPlayAI()
        {
          boolean nevinyrralInPlay = false;

          CardList inPlay = new CardList();
          inPlay.addAll(AllZone.Computer_Play.getCards());
          for(int i=0; i<inPlay.size(); ++i)
          {
            if( inPlay.getCard(i).getName().equals("Nevinyrral's Disk"))
            {
              nevinyrralInPlay = true;
            }
          }
          return ! nevinyrralInPlay && (0 < CardFactoryUtil.AI_getHumanCreature(card, false).size());
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(summoningSpell);

      card.addComesIntoPlayCommand(new Command()
      {
		private static final long serialVersionUID = 1227443034730254929L;

		public void execute()
        {
          card.tap();
        }
      });
      final SpellAbility ability = new Ability_Tap(card, "1")
      {
		private static final long serialVersionUID = -4871606824998622131L;
		
		public void resolve()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());
          all = filter(all);

          for(int i = 0; i < all.size(); i++)
            AllZone.GameAction.destroy(all.get(i));
        }
        private CardList filter(CardList list)
        {
          return list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isArtifact() || c.isCreature() || c.isEnchantment();
            }
          });
        }//filter()
        public boolean canPlayAI()
        {
          CardList human    = new CardList(AllZone.Human_Play.getCards());
          CardList computer = new CardList(AllZone.Computer_Play.getCards());

          human    = human.getType("Creature");
          computer = computer.getType("Creature");

          //the computer will at least destroy 2 more human creatures
          return computer.size() < human.size()-1  || AllZone.Computer_Life.getLife() < 7;
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("1, tap: Destroy all artifacts, creatures, and enchantments.");
      ability.setStackDescription("Destroy all artifacts, creatures, and enchantments.");
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Tanglebloom"))
    {
      final SpellAbility a1 = new Ability_Tap(card, "1")
      {
		private static final long serialVersionUID = -6395076857898740906L;
		
		public boolean canPlayAI() {return AllZone.Phase.getPhase().equals(Constant.Phase.Main2);}
        public void resolve()
        {
          AllZone.GameAction.getPlayerLife(card.getController()).addLife(1);
        }
      };//SpellAbility
      card.addSpellAbility(a1);
      a1.setDescription("1, tap: You gain 1 life.");
      a1.setStackDescription("Tanglebloom - " +card.getController() +" gains 1 life.");

      a1.setBeforePayMana(new Input_PayManaCost(a1));
    }//*************** END ************ END **************************
    
  
  //*************** START *********** START **************************
    if(cardName.equals("Azusa, Lost but Seeking"))
    {
    	
    	final Ability ability = new Ability(card, "0")
    	{
    		public boolean canPlay()
    		{
    			SpellAbility sa;
    	    	for (int i=0; i<AllZone.Stack.size(); i++)
    	    	{
    	    	     sa = AllZone.Stack.peek(i);
    	    	     if (sa.getSourceCard().equals(card))
    	    	          return false;
    	    	}
    			
    			String player = card.getController();
    			PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, player);
    			CardList lands = new CardList(hand.getCards());
    			lands = lands.getType("Land");
    			
    			return lands.size() > 0 &&
    				(AllZone.Phase.getPhase().equals(Constant.Phase.Main2) || AllZone.Phase.getPhase().equals(Constant.Phase.Main1))
    				&& AllZone.GameAction.isCardInPlay(card) && CardFactoryUtil.canUseAbility(card);
    		}
    		public void resolve()
    		{

    			String player = card.getController();
    			
    			PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, player);
    			PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
    			
    			
    			CardList lands = new CardList(hand.getCards());
    			lands = lands.getType("Land");
    			
    			if (lands.size() > 0)
    			{
    				if (player.equals(Constant.Player.Human))
    				{
		    			Object o = AllZone.Display.getChoiceOptional("Select land to play", lands.toArray());
		    			if (o!=null)
		    			{
		    				Card c = (Card)o;
		    				hand.remove(c);
		    				play.add(c);
		    			}
    				}
    				else
    				{
    					Card c = lands.get(0);
    					hand.remove(c);
    					play.add(c);
    				}
    				card.setAbilityUsed(card.getAbilityUsed()+1);
    			}
    		}
    	};
    	
    	card.addSpellAbility(ability);
    	ability.setDescription("You may play two additional lands on each of your turns.");
        ability.setStackDescription(card.getName() + " - " + card.getController() + " plays an additional land.");
    }//*************** END ************ END **************************  
    
  //*************** START *********** START **************************
    if(cardName.equals("Exploration"))
    {
    	final int turn[] = new int[1];
    	turn[0] = -1;
    	
    	final Ability ability = new Ability(card, "0")
    	{
    		public boolean canPlay()
    		{
    			SpellAbility sa;
    	    	for (int i=0; i<AllZone.Stack.size(); i++)
    	    	{
    	    	     sa = AllZone.Stack.peek(i);
    	    	     if (sa.getSourceCard().equals(card))
    	    	          return false;
    	    	}
    			
    			String player = card.getController();
    			PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, player);
    			CardList lands = new CardList(hand.getCards());
    			lands = lands.getType("Land");
    			
    			return lands.size() > 0 &&
    				(AllZone.Phase.getPhase().equals(Constant.Phase.Main2) || AllZone.Phase.getPhase().equals(Constant.Phase.Main1))
    				&& AllZone.GameAction.isCardInPlay(card) && turn[0] != AllZone.Phase.getTurn();
    		}
    		public void resolve()
    		{
    			turn[0] = AllZone.Phase.getTurn();
    			String player = card.getController();
    			
    			PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, player);
    			PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
    			
    			
    			CardList lands = new CardList(hand.getCards());
    			lands = lands.getType("Land");
    			
    			if (lands.size() > 0)
    			{
    				if (player.equals(Constant.Player.Human))
    				{
		    			Object o = AllZone.Display.getChoiceOptional("Select land to play", lands.toArray());
		    			if (o!=null)
		    			{
		    				Card c = (Card)o;
		    				hand.remove(c);
		    				play.add(c);
		    			}
    				}
    				else
    				{
    					Card c = lands.get(0);
    					hand.remove(c);
    					play.add(c);
    				}
    			}
    		}
    	};
    	
    	card.addSpellAbility(ability);
    	ability.setDescription("You may play an additional land each of your turns.");
        ability.setStackDescription(card.getName() + " - " + card.getController() + " plays an additional land.");
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Fastbond"))
    {
    	final Ability ability = new Ability(card, "0")
    	{
    		public boolean canPlayAI()
    		{
    			if(AllZone.GameAction.getPlayerLife(Constant.Player.Computer).getLife() > 4)
    				return true;
    			else
    				return false;
    		}
    		public boolean canPlay()
    		{
    			SpellAbility sa;
    	    	for (int i=0; i<AllZone.Stack.size(); i++)
    	    	{
    	    	     sa = AllZone.Stack.peek(i);
    	    	     if (sa.getSourceCard().equals(card))
    	    	          return false;
    	    	}
    			
    			String player = card.getController();
    			PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, player);
    			CardList lands = new CardList(hand.getCards());
    			lands = lands.getType("Land");
    			
    			return !Input_Main.canPlayLand && lands.size() > 0 &&
    				(AllZone.Phase.getPhase().equals(Constant.Phase.Main2) || AllZone.Phase.getPhase().equals(Constant.Phase.Main1))
    				&& AllZone.GameAction.isCardInPlay(card);
    		}
    		public void resolve()
    		{
    			String player = card.getController();

    			
    			PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, player);
    			PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
    			
    			CardList fastbonds = new CardList(play.getCards());
    			fastbonds = fastbonds.getName("Fastbond"); //do this, because if there are more in play, fastbond will deal more damage per land
    			
    			AllZone.GameAction.getPlayerLife(player).subtractLife(fastbonds.size());
    			
    			CardList lands = new CardList(hand.getCards());
    			lands = lands.getType("Land");
    			
    			if (lands.size() > 0)
    			{
    				if (player.equals(Constant.Player.Human))
    				{
		    			Object o = AllZone.Display.getChoiceOptional("Select land to play", lands.toArray());
		    			if (o!=null)
		    			{
		    				Card c = (Card)o;
		    				hand.remove(c);
		    				play.add(c);
		    			}
    				}
    				else
    				{
    					Card c = lands.get(0);
    					hand.remove(c);
    					play.add(c);
    					
    				}
    			}
    		}
    	};
    	
    	card.addSpellAbility(ability);
    	ability.setDescription("You may play as many lands as you choose on your turn. Whenever you play a land other than the first land of the turn, Fastbond deals 1 damage to you.");
        ability.setStackDescription(card.getName() + " - deals damage to " + card.getController() + ", plays another land.");
    }//*************** END ************ END **************************
    		


    //*************** START *********** START **************************
    if(cardName.equals("Wellwisher"))
    {
      final SpellAbility ability = new Ability_Tap(card, "0")
      {
		private static final long serialVersionUID = 1446529067071763247L;
		
		public boolean canPlay()
        {
          setStackDescription(card.getName() +" - " +card.getController() +" gains " +countElf() +" life.");

          return super.canPlay();
        }
        public void resolve()
        {
          AllZone.GameAction.getPlayerLife(card.getController()).addLife(countElf());
        }
        int countElf()
        {
          //get all creatures
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.getType("Elf");
          return list.size();
        }
      };//SpellAbility
      ability.setDescription("tap: You gain 1 life for each Elf in play.");
      ability.setBeforePayMana(new Input_NoCost_TapAbility((Ability_Tap) ability));
      card.addSpellAbility(ability);
    }//*************** END ************ END **************************

    
  //*************** START *********** START **************************
    if(cardName.equals("Sliver Overlord"))
    {
    	//final String player = card.getController();
	    final SpellAbility ability = new Ability(card, "3")
		  {
		      public boolean canPlay()
		      {
		    	  SpellAbility sa;
		    	  for (int i=0; i<AllZone.Stack.size(); i++)
		    	  {
		    	       sa = AllZone.Stack.peek(i);
		    	       if (sa.getSourceCard().equals(card))
		    	             return false;
		    	  }
		    	  
		    	  if (AllZone.GameAction.isCardInPlay(card))
		    		  return true;
		    	  else
		    		  return false;
		      }
		      public boolean canPlayAI() 
		      {
		    	  PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
		    	  CardList list = new CardList(lib.getCards());
		    	  list = list.getType("Sliver");
		    	  
		    	  if (list.size()==0)
		    		  return false;
		    	  
		    	  if (AllZone.Phase.getPhase().equals(Constant.Phase.Main2) && list.size() > 0)
		    		  return true;
		    	  else
		    		  return false;
		    	  
		      }
		      
		      
		      public void resolve()
		      {
		    	  PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
		    	  PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
		    	  String player = card.getController();
		    	  
		    	  CardList list = new CardList(lib.getCards());
		    	  list = list.getType("Sliver");
		    	  
		    	  if (list.size()==0)
		    		  return;
		    	  
		    	  if (player.equals(Constant.Player.Computer))
		    	  {
		    		  Card sliver = CardFactoryUtil.AI_getBestCreature(list);
		    		  lib.remove(sliver);
		    		  hand.add(sliver);
		    	  }
		    	  else //human
		    	  {
		    		  Object o = AllZone.Display.getChoiceOptional("Select target Sliver", list.toArray());
		    		  Card sliver = (Card)o;
		    		  lib.remove(sliver);
		    		  hand.add(sliver);
		    	  }
		    	  AllZone.GameAction.shuffle(player);
		      }
		  };
		  
		  final SpellAbility ability2 = new Ability(card, "3")
	       {
	    	   
	    	   public void resolve()
	           {
	    		   
	    		 
	    		 Card c = getTargetCard();
	             if(AllZone.GameAction.isCardInPlay(c) && (c.getType().contains("Sliver") || c.getKeyword().contains("Changeling") )
	            	&& CardFactoryUtil.canTarget(card,c) )
	             {
	              //set summoning sickness
	               if(c.getKeyword().contains("Haste")){
	                 c.setSickness(false);
	               }
	               else{
	                 c.setSickness(true);
	               }
	               
	               ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
	               ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);

	               PlayerZone from = AllZone.getZone(c);
	               from.remove(c);
	              
	               c.setController(card.getController());

	               PlayerZone to = AllZone.getZone(Constant.Zone.Play, card.getController());
	               to.add(c);

	               ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
	               ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
	             }//if
	    		 

	           }//resolve()

	    	   public boolean canPlayAI()
	           {
	    		
	             CardList c = CardFactoryUtil.AI_getHumanCreature(card, true);
	             CardListUtil.sortAttack(c);
	             CardListUtil.sortFlying(c);
	             c = c.filter(new CardListFilter(){

					public boolean addCard(Card c) {
						return c.getType().contains("Sliver") || c.getKeyword().contains("Changeling");
					}
	            	 
	             });

	             if(c.isEmpty())
	               return false;

	             if(2 <= c.get(0).getNetAttack() && c.get(0).getKeyword().contains("Flying") &&
	            	c.get(0).getKeyword().contains("Sliver"))
	             {
	               setTargetCard(c.get(0));
	               return true;
	             }

	             CardListUtil.sortAttack(c);
	             if(4 <= c.get(0).getNetAttack() && c.get(0).getKeyword().contains("Sliver"))
	             {
	               setTargetCard(c.get(0));
	               return true;
	             }

	             return false;
	           }//canPlayAI()

	         public boolean canPlay()
	         {
	           return AllZone.GameAction.isCardInPlay(card);
	           
	         }//canPlay()
	       };//SpellAbility ability2

	       ability2.setBeforePayMana(new Input()
	       {
			private static final long serialVersionUID = 1489433384490805477L;

			public void showMessage()
	           {
	    		 String opponent = AllZone.GameAction.getOpponent(card.getController());
	             CardList slivers = new CardList(AllZone.getZone(Constant.Zone.Play, opponent).getCards());
	             slivers = slivers.getType("Sliver");
	             
	             stopSetNext(CardFactoryUtil.input_targetSpecific(ability2, slivers, "Select a Sliver", true));
	           }
	       });
	       
		  ability.setDescription("3:Search your library for a Sliver card, reveal that card, and put it into your hand. Then shuffle your library.");
		  ability.setStackDescription(card.getName() +" - search for a Sliver card and put it into your hand.");
		  
		  ability2.setDescription("3:Gain control of target Sliver.");
		  ability.setStackDescription(card.getName() +" - Gain control of target Sliver.");
		  
		  card.addSpellAbility(ability);
		  card.addSpellAbility(ability2);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Sliver Queen"))
    {
      final SpellAbility a1 = new Ability(card, "2")
      {
    	  
    	public boolean canPlay()
    	{
    		SpellAbility sa;
            //this is a hack, check the stack to see if this card has an ability on the stack
            //if so, we can't use the ability
            for (int i=0; i<AllZone.Stack.size(); i++)
            {
            	sa = AllZone.Stack.peek(i);
            	if (sa.getSourceCard().equals(card))
            			return false;
            }
            return AllZone.GameAction.isCardInPlay(card);
    	}
        public void resolve()
        {
          makeToken();
        }
        void makeToken()
        {
          Card c = new Card();

          c.setImageName("C 1 1 Sliver");
          c.setName("Sliver");

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setManaCost("");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Sliver");
          c.setBaseAttack(1);
          c.setBaseDefense(1);
          
          

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//makeToken()
        
        public boolean canPlayAI()
        {
        	return AllZone.Phase.getPhase().equals(Constant.Phase.Main2);
        }
      };//SpellAbility
      card.addSpellAbility(a1);
      a1.setDescription("2: Put a 1/1 colorless Sliver creature token into play.");
      a1.setStackDescription("Put a 1/1 colorless Sliver creature token into play.");

      a1.setBeforePayMana(new Input_PayManaCost(a1));
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Korlash, Heir to Blackblade"))
    {
      ///////////////////////////////////////////

      final SpellAbility ability = new Ability(card, "0")
      {
        public void chooseTargetAI()
        {
          PlayerZone p = AllZone.getZone(Constant.Zone.Hand, card.getController());
          CardList list = new CardList(p.getCards());
          list = list.getName(cardName);

          AllZone.GameAction.discard(list.get(0));
        }

        public boolean canPlay()
        {
          PlayerZone p = AllZone.getZone(Constant.Zone.Hand, card.getController());
          CardList list = new CardList(p.getCards());
          list = list.getName(cardName);
          return 0 < list.size() && AllZone.getZone(card).getZone().equals(Constant.Zone.Play);
        }

        public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());

          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          CardList list = new CardList(library.getCards());
          CardList swamp = list.getType("Swamp");

          for(int i = 0; i < 2 && (! swamp.isEmpty()); i++)
          {
            Card c = swamp.get(0);
            swamp.remove(c);

            library.remove(c);
            play.add(c);
            c.tap();
          }
          for (String effect : AllZone.StateBasedEffects.getStateBasedMap().keySet() ) {
  			Command com = GameActionUtil.commands.get(effect);
  			com.execute();
  		  }
          GameActionUtil.executeCardStateEffects();
        }
      };
      Input removeCard = new Input()
      {
		private static final long serialVersionUID = -8560221326412798885L;
		
		int n = 0;
        public void showMessage()
        {
          //this is called twice, this is an ugly hack
          if(n % 2 == 0)
            stop();


          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          CardList list = new CardList(hand.getCards());

          list = list.getName(cardName);
          AllZone.GameAction.discard(list.get(0));

          AllZone.Stack.push(ability);
          stop();
        }
      };
      ability.setBeforePayMana(removeCard);

      ability.setDescription("Grandeur - Discard Korlash and put two Swamps from your library into play tapped.");
      ability.setStackDescription(cardName +" - Search for two swamps and put them into play tapped.");

      card.addSpellAbility(ability);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Tarox Bladewing"))
    {
      final Command untilEOT = new Command()
      {
		private static final long serialVersionUID = 2642394522583318055L;

		public void execute()
        {
          int n = card.getNetAttack();

          card.addTempDefenseBoost(- n/2);
          card.addTempAttackBoost(- n/2);
        }
      };

      final SpellAbility ability = new Ability(card, "0")
      {
        public void chooseTargetAI()
        {
          PlayerZone p = AllZone.getZone(Constant.Zone.Hand, card.getController());
          CardList list = new CardList(p.getCards());
          list = list.getName(cardName);

          AllZone.GameAction.discard(list.get(0));
        }

        public boolean canPlay()
        {
          PlayerZone p = AllZone.getZone(Constant.Zone.Hand, card.getController());
          CardList list = new CardList(p.getCards());
          list = list.getName(cardName);
          return 0 < list.size() && AllZone.getZone(card).getZone().equals(Constant.Zone.Play);
        }

        public void resolve()
        {
          card.addTempDefenseBoost(card.getNetAttack());
          card.addTempAttackBoost(card.getNetAttack());

          AllZone.EndOfTurn.addUntil(untilEOT);
        }
      };
      Input removeCard = new Input()
      {
		private static final long serialVersionUID = -1312910959802746127L;
		
		int n = 0;
        public void showMessage()
        {
          //this is called twice, this is an ugly hack
          if(n % 2 == 0)
            stop();


          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          CardList list = new CardList(hand.getCards());

          list = list.getName(cardName);
          AllZone.GameAction.discard(list.get(0));

          AllZone.Stack.push(ability);
          stop();
        }
      };
      ability.setBeforePayMana(removeCard);

      ability.setDescription("Grandeur - Discard another card named Tarox Bladewing: Tarox Bladewing gets +X/+X until end of turn, where X is his power.");
      ability.setStackDescription(cardName +" - gets +X/+X until end of turn.");

      card.addSpellAbility(ability);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Baru, Fist of Krosa"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void chooseTargetAI()
        {
          PlayerZone p = AllZone.getZone(Constant.Zone.Hand, card.getController());
          CardList list = new CardList(p.getCards());
          list = list.getName(cardName);

          AllZone.GameAction.discard(list.get(0));
        }

        public boolean canPlay()
        {
          PlayerZone p = AllZone.getZone(Constant.Zone.Hand, card.getController());
          CardList list = new CardList(p.getCards());
          list = list.getName(cardName);
          return 0 < list.size() && AllZone.getZone(card).getZone().equals(Constant.Zone.Play);
        }

        public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList list = new CardList(play.getCards());
          list = list.getType("Land");
          makeToken(list.size());
        }
        void makeToken(int stats)
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setImageName("G X X Wurm");
          c.setName("Wurm");
          c.setManaCost("G");
          c.setToken(true);
          
          c.addType("Creature");
          c.addType("Wurm");
          c.setBaseAttack(stats);
          c.setBaseDefense(stats);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, c.getController());
          play.add(c);
        }//makeToken()
      };
      Input removeCard = new Input()
      {
		private static final long serialVersionUID = 7738090787920616790L;
		
		int n = 0;
        public void showMessage()
        {
          //this is called twice, this is an ugly hack
          if(n % 2 == 0)
            stop();


          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          CardList list = new CardList(hand.getCards());

          list = list.getName(cardName);
          AllZone.GameAction.discard(list.get(0));

          AllZone.Stack.push(ability);
          stop();
        }
      };
      ability.setBeforePayMana(removeCard);

      ability.setDescription("Grandeur - Discard another card named Baru, Fist of Krosa: Put an X/X green Wurm creature token into play, where X is the number of lands that you control.");
      ability.setStackDescription(cardName +" - put X/X token into play.");

      card.addSpellAbility(ability);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Hunted Phantasm"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          for(int i = 0; i < 5; i++)
            makeToken();
        }
        void makeToken()
        {
          //warning, different owner and controller
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, opponent);
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(opponent);

          c.setName("Goblin");
          c.setImageName("R 1 1 Goblin");
          c.setManaCost("R");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Goblin");
          c.setBaseAttack(1);
          c.setBaseDefense(1);


          play.add(c);
        }//makeToken()
      };//SpellAbility

      Command intoPlay = new Command()
      {

		private static final long serialVersionUID = -5515684113290670830L;

		public void execute()
        {
          AllZone.Stack.add(ability);
        }
      };
      ability.setStackDescription("Hunted Phantasm - Opponent puts five 1/1 Goblin Creature tokens onto the battlefield.");
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Hunted Horror"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          for(int i = 0; i < 2; i++)
            makeToken();
        }
        void makeToken()
        {
          //warning, different owner and controller
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, opponent);
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(opponent);

          c.setName("Centaur");
          c.setImageName("G 3 3 Centaur Pro Black");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Centaur");
          c.setBaseAttack(3);
          c.setBaseDefense(3);
          c.addIntrinsicKeyword("Protection from black");

          play.add(c);
        }//makeToken()
      };//SpellAbility

      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -5515684113290670830L;

		public void execute()
        {
          AllZone.Stack.add(ability);
        }
      };
      ability.setStackDescription("Hunted Horror - Opponent puts two 3/3 Centaur tokens with Protection from Black onto the battlefield.");
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Hunted Lammasu"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {	
        	makeToken();
        }
        void makeToken()
        {
          //warning, different owner and controller
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, opponent);
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(opponent);

          c.setName("Horror");
          c.setImageName("B 4 4 Horror");
          c.setManaCost("B");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Horror");
          c.setBaseAttack(4);
          c.setBaseDefense(4);

          play.add(c);
        }//makeToken()
      };//SpellAbility

      Command intoPlay = new Command()
      {
		
		private static final long serialVersionUID = -5515684113290670830L;

		public void execute()
        {
          AllZone.Stack.add(ability);
        }
      };
      ability.setStackDescription("Hunted Lammasu - Opponent puts a 4/4 black Horror creature token onto the battlefield.");
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Hunted Dragon"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          for(int i = 0; i < 3; i++)
            makeToken();
        }
        void makeToken()
        {
          //warning, different owner and controller
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, opponent);
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(opponent);

          c.setName("Knight");
          c.setImageName("W 2 2 Knight");
          c.setManaCost("W");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Knight");
          c.setBaseAttack(2);
          c.setBaseDefense(2);
          c.addIntrinsicKeyword("First Strike");

          play.add(c);
        }//makeToken()
      };//SpellAbility

      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -5091710462434865200L;

		public void execute()
        {
          AllZone.Stack.add(ability);
        }
      };
      ability.setStackDescription("Hunted Dragon - Opponent puts 3 Knight tokens with First Strike into play");
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Hunted Troll"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {

          for(int i = 0; i < 4; i++)
            makeToken();
        }
        void makeToken()
        {
          //warning, different owner and controller
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, opponent);
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(opponent);
          
          c.setName("Faerie");
          c.setImageName("U 1 1 Faerie");
          c.setManaCost("U");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Faerie ");
          c.setBaseAttack(1);
          c.setBaseDefense(1);
          c.addIntrinsicKeyword("Flying");

          play.add(c);
        }//makeToken()
      };//SpellAbility

      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 7599515041000061901L;

		public void execute()
        {
          AllZone.Stack.add(ability);
        }
      };
      ability.setStackDescription("Hunted Troll - Opponent puts 4 Faerie tokens with flying into play");
      card.addComesIntoPlayCommand(intoPlay);


      final Command untilEOT = new Command()
      {
		private static final long serialVersionUID = -451839437837081897L;

		public void execute()
        {
          card.setShield(0);
        }
      };

      final SpellAbility a1 = new Ability(card, "G")
      {
        public boolean canPlayAI() {return false;}

        public void resolve()
        {
          card.addShield();
          AllZone.EndOfTurn.addUntil(untilEOT);
        }
      };//SpellAbility
      card.addSpellAbility(a1);
      a1.setDescription("G: Regenerate Hunted Troll.");
      a1.setStackDescription("Regenerate Hunted Troll");

      a1.setBeforePayMana(new Input_PayManaCost(a1));
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
 if(cardName.equals("Blinkmoth Nexus"))
 {
   final SpellAbility a1 = new Ability(card, "1")
   {
     final Command eot1 = new Command()
     {
	   private static final long serialVersionUID = 3564161001279001235L;

	   public void execute()
       {
         Card c = card;

         c.setBaseAttack(0);
         c.setBaseDefense(0);
         c.removeIntrinsicKeyword("Flying");
         c.removeType("Artifact");
         c.removeType("Creature");
         c.removeType("Blinkmoth");
       }
     };
     public boolean canPlayAI()
     {
       return false;
     }
     public void resolve()
     {
       Card c = card;

       c.setBaseAttack(1);
       c.setBaseDefense(1);
       //to prevent like duplication like "Flying Flying Creature Creature"
       if(! c.getIntrinsicKeyword().contains("Flying"))
       {
         c.addIntrinsicKeyword("Flying");
       }
       c.addType("Artifact");
       c.addType("Creature");
       c.addType("Blinkmoth");

       AllZone.EndOfTurn.addUntil(eot1);
     }
   };//SpellAbility
   card.addSpellAbility(a1);
   a1.setDescription("1: Blinkmoth Nexus becomes a 1/1 Blinkmoth artifact creature with flying until end of turn. It's still a land.");
   a1.setStackDescription(card +" becomes a 1/1 creature with flying until EOT");

   Command paid1 = new Command() {
	   private static final long serialVersionUID = -5122292582368202498L;
	   public void execute() {AllZone.Stack.add(a1);}
   };
   a1.setBeforePayMana(new Input_PayManaCost_Ability(a1.getManaCost(), paid1));

   final SpellAbility[] a2 = new SpellAbility[1];
   final Command eot2 = new Command()
     {
	   private static final long serialVersionUID = 6180724472470740160L;

	   public void execute()
       {
         Card c = a2[0].getTargetCard();
         if(AllZone.GameAction.isCardInPlay(c))
         {
           c.addTempAttackBoost(-1);
           c.addTempDefenseBoost(-1);
         }
       }
     };

   a2[0] = new Ability_Tap(card,"1")
   {
	private static final long serialVersionUID = 3561450520225198222L;

	public boolean canPlayAI()
     {
       return getAttacker() != null;
     }
     public void chooseTargetAI()
     {
       setTargetCard(getAttacker());
     }
     public Card getAttacker()
     {
       //target creature that is going to attack
       Combat c = ComputerUtil.getAttackers();
       CardList att = new CardList(c.getAttackers());
       att.remove(card);
       att.shuffle();

       if(att.size() != 0)
         return att.get(0);
       else
         return null;
     }//getAttacker()

     public void resolve()
     {
       Card c = a2[0].getTargetCard();
       if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card,c) )
       {
         c.addTempAttackBoost(1);
         c.addTempDefenseBoost(1);

         AllZone.EndOfTurn.addUntil(eot2);
       }
     }//resolve()
   };//SpellAbility
   card.addSpellAbility(a2[0]);
   a2[0].setDescription("1, tap: Target Blinkmoth gets +1/+1 until end of turn.");


   @SuppressWarnings("unused") // target unused
final Input target = new Input()
   {
	 private static final long serialVersionUID = 8913477363141356082L;
	
	 public void showMessage()
     {
       ButtonUtil.enableOnlyCancel();
       AllZone.Display.showMessage("Select Blinkmoth to get +1/+1");
     }
     public void selectCard(Card c, PlayerZone zone)
     {
      if(!CardFactoryUtil.canTarget(card, c)){
       	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
      }
      else if(c.isCreature() && c.getType().contains("Blinkmoth"))
      {
         card.tap();
         AllZone.Human_Play.updateObservers();

         a2[0].setTargetCard(c);//since setTargetCard() changes stack description
         a2[0].setStackDescription(c +" gets +1/+1 until EOT");

         AllZone.InputControl.resetInput();
         AllZone.Stack.add(a2[0]);
       }
     }//selectCard()
     public void selectButtonCancel()
     {
       card.untap();
       stop();
     }
   };//Input target
   a2[0].setBeforePayMana(CardFactoryUtil.input_targetType(a2[0], "Blinkmoth"));
 }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Mishra's Factory"))
    {
      final Command eot1 = new Command()
      {
		private static final long serialVersionUID = -956566640027406078L;

		public void execute()
        {
          Card c = card;

          c.setBaseAttack(0);
          c.setBaseDefense(0);
          c.removeType("Artifact");
          c.removeType("Creature");
          c.removeType("Assembly-Worker");
        }
      };

      final SpellAbility a1 = new Ability(card, "1")
      {
        public boolean canPlayAI()
        {
          return false;
          //it turns into a creature, but doesn't attack
//          return (! card.getKeyword().contains("Flying") &&
//                 (CardFactoryUtil.AI_getHumanCreature("Flying").isEmpty()));
        }
        public void resolve()
        {
          Card c = card;

          c.setBaseAttack(2);
          c.setBaseDefense(2);
          //to prevent like duplication like "Creature Creature"
          if(! c.getKeyword().contains("Creature"))
          {
            c.addType("Artifact");
            c.addType("Creature");
            c.addType("Assembly-Worker");
          }
          AllZone.EndOfTurn.addUntil(eot1);
        }
      };//SpellAbility
      card.addSpellAbility(a1);
      a1.setStackDescription(card +" - becomes a 2/2 creature until EOT");

      Command paid1 = new Command() {
		private static final long serialVersionUID = -6767109002136516590L;

		public void execute() {AllZone.Stack.add(a1);}
	  };

      a1.setBeforePayMana(new Input_PayManaCost_Ability(a1.getManaCost(), paid1));
    }//*************** END ************ END **************************

  //*************** START *********** START **************************
    if(cardName.equals("Filigree Angel"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          int n = countArtifacts();

          PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
            life.addLife(3*n);

        }
        int countArtifacts()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList list = new CardList(play.getCards());
          list = list.getType("Artifact");
          return list.size();
        }

      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -319011246650583681L;

		public void execute()
        {
          ability.setStackDescription(card.getName() + " - " +card.getController() +" gains 3 life for each artifact he controls");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Venerable Monk") || cardName.equals("Kitchen Finks") || cardName.equals("Shu Grain Caravan"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = card;
          PlayerLife life = AllZone.GameAction.getPlayerLife(c.getController());
          life.addLife(2);
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 1832932499373431651L;

		public void execute()
        {
          ability.setStackDescription(card.getController() +" gains 2 life");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Shu Soldier-Farmers") || cardName.equals("Staunch Defenders") ||
       cardName.equals("Spiritual Guardian") || cardName.equals("Teroh's Faithful") || 
       cardName.equals("Jedit's Dragoons") || cardName.equals("Loxodon Hierarch"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = card;
          PlayerLife life = AllZone.GameAction.getPlayerLife(c.getController());
          life.addLife(4);
        }
      };
      Command intoPlay = new Command()
      {
 		private static final long serialVersionUID = -1537994957313929513L;

		public void execute()
        {
          ability.setStackDescription(card.getController() +" gains 4 life");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Loxodon Hierarch"))
    {
      final Ability ability = new Ability(card, "G W")
      {
        public boolean canPlayAI() {return false;}

        public void resolve()
        {
        	final Card[] c = AllZone.getZone(Constant.Zone.Play, card.getController()).getCards();

            for(int i = 0; i < c.length; i++)
              if(c[i].isCreature())
                c[i].addShield();

            AllZone.EndOfTurn.addUntil(new Command()
            {
			  private static final long serialVersionUID = 5853778391858472471L;

			  public void execute()
              {
                for(int i = 0; i < c.length; i++)
                  c[i].resetShield();
              }
            });
        }//resolve()
      };//SpellAbility

      card.addSpellAbility(ability);
      ability.setDescription("GW, Sacrifice Loxodon Hierarch: Regenerate each creature you control.");
      ability.setStackDescription(cardName + " regenerate each of " + card.getController() + "'s creatures.");
      ability.setBeforePayMana(new Input_PayManaCost_Ability(ability.getManaCost(), new Command()
      {
		private static final long serialVersionUID = -8594393519904006680L;

		public void execute()
        {
          AllZone.GameAction.sacrifice(card);
          AllZone.Stack.add(ability);
        }
      }));
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Conspiracy") || cardName.equals("Cover of Darkness") || cardName.equals("Door of Destinies") ||
       cardName.equals("Engineered Plague") || cardName.equals("Shared Triumph") || cardName.equals("Belbe's Portal") ||
       cardName.equals("Steely Resolve") )
    {
    	final String[] input = new String[1];
    	final String player = card.getController();
    	
    	final SpellAbility ability = new Ability(card, "0")
    	{
    		public void resolve()
    		{
    			if (player.equals(Constant.Player.Human))
    			{
	    			input[0] =  (String)JOptionPane.showInputDialog(null, "Which creature type?", "Pick type", JOptionPane.QUESTION_MESSAGE);
	    			
	    			if (input[0].equals("Legendary") || input[0].equals("Artifact") || input[0].equals("Enchantment") || input[0].equals("Creature"))
	    				input[0] = "";
	    			//TODO: some more input validation, case-sensitivity, etc.
	    			
	    			input[0] = input[0].trim(); //this is to prevent "cheating", and selecting multiple creature types,eg "Goblin Soldier"
    			}
    			else
    			{
    				String chosenType = CardFactoryUtil.chooseCreatureTypeAI(card);
    				if (!chosenType.equals(""))
    					input[0] = chosenType;
    				else 
    					input[0] = "Sliver"; //what to put here for the AI???
    			}
    			
    			card.setChosenType(input[0]);
    		}
    	};//ability
    	Command intoPlay = new Command()
        {
		  private static final long serialVersionUID = 5634360316643996274L;

		  public void execute()
          {
            ability.setStackDescription("When " + card.getName() + " comes into play, choose a creature type.");
            AllZone.Stack.add(ability);
          }
        };
        card.addComesIntoPlayCommand(intoPlay);
     
    	
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Sarpadian Empires, Vol. VII"))
    {
    	
    	final String[] choices = { 
    			 "Citizen", 
    			 "Camarid",
    			 "Thrull",
    			 "Goblin",
    			 "Saproling"
    	 };
    	 
    	final String player = card.getController();
    	
    	final SpellAbility ability = new Ability(card, "0")
    	{
    		public void resolve()
    		{
    			String type = "";
    			String imageName = "";
    			String color = "";
    			
    			if (player.equals(Constant.Player.Computer))
    			{
    				type = "Thrull";
    				imageName = "B 1 1 Thrull";
    				color = "B";
    			}
    			else if (player.equals(Constant.Player.Human))
    			{
    				Object q = AllZone.Display.getChoiceOptional("Select type of creature", choices);
		        	if (q.equals("Citizen"))
		        	{
		        		type = "Citizen";
		        		imageName = "W 1 1 Citizen";
		        		color = "W";
		        	}
		        	else if(q.equals("Camarid"))
		        	{
		        		type = "Camarid";
		        		imageName = "U 1 1 Camarid";
		        		color = "U";
		        	}
		        	else if(q.equals("Thrull"))
		        	{
		        		type = "Thrull";
		        		imageName = "B 1 1 Thrull";
		        		color = "B";
		        	}
		        	else if(q.equals("Goblin"))
		        	{
		        		type = "Goblin";
		        		imageName = "R 1 1 Goblin";
		        		color = "R";
		        	}
		        	else if(q.equals("Saproling"))
		        	{
		        		type = "Saproling";
		        		imageName = "G 1 1 Saproling";
		        		color = "G";
		        	}
    			}
    			card.setChosenType(type);
    			
    			final String t = type;
    			final String in = imageName;
    			final String col = color;
    			//card.setChosenType(input[0]);
    			
    			final Ability_Tap a1 = new Ability_Tap(card, "3")
    			{
    				
					private static final long serialVersionUID = -2114111483117171609L;

					public void resolve() {
						Card c = new Card();

				        c.setOwner(card.getController());
				        c.setController(card.getController());

				        c.setName(t);
				        c.setImageName(in);
				        c.setManaCost(col);
				        c.setToken(true);
				        
				        c.addType("Creature");
				        c.addType(t);
				        
				        c.setBaseAttack(1);
				        c.setBaseDefense(1);

				        PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
				        play.add(c);
					}
					
    			};
    			a1.setDescription("3, Tap: Put a 1/1 creature token of the chosen color and type onto the battlefield.");
    			a1.setStackDescription(card.getName() + " - " +  card.getController() + " puts a 1/1" + t + " token into play");
    			card.addSpellAbility(a1);
    		}
    	};//ability
    	Command intoPlay = new Command()
        {
			private static final long serialVersionUID = 7202704600935499188L;
	
			public void execute()
	          {
	            ability.setStackDescription("As Sarpadian Empires, Vol. VII enters the battlefield, choose white Citizen, blue Camarid, black Thrull, red Goblin, or green Saproling.");
	            AllZone.Stack.add(ability);
	          }
        };
        card.addComesIntoPlayCommand(intoPlay);
    	
    }//*************** END ************ END **************************
    		

  //*************** START *********** START **************************
    if(cardName.equals("Springjack Shepherd"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
        	int number = CardFactoryUtil.getNumberOfManaSymbolsControlledByColor("W", card.getController());
        	for (int i=0;i<number;i++)
        	{
        		makeToken();
        	}
            
        }//resolve()
        public void makeToken()
        {
	        Card c = new Card();
	
	        c.setOwner(card.getController());
	        c.setController(card.getController());
	
	        c.setImageName("W 0 1 Goat");
	        c.setName("Goat");
	        c.setManaCost("W");
	        c.setToken(true);
	
	        c.addType("Creature");
	        c.addType("Goat");
	
	        c.setBaseAttack(0);
	        c.setBaseDefense(1);
	
	        PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
	        play.add(c);
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -5515684113290670830L;

		public void execute()
        {
          ability.setStackDescription("Springjack Shepherd - put a 0/1 white Goat creature token into play for each white mana symbol of permanents you control");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Gilder Bairn"))
    {
    	final SpellAbility a1 = new Ability(card,"2 GU")
        {
          public void resolve()
          {
        	Card c = getTargetCard();
        	card.untap();
        	
        	if (c.sumAllCounters() == 0)
        		return;
        	else if (AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, c))
        	{
        		//zerker clean up:
        		for(Counters c_1 : Counters.values())
                    if (c.getCounters(c_1) != 0)
                        c.addCounter(c_1, c.getCounters(c_1));
        	}
          }
          
          public boolean canPlay()
          {
        	 
        	  if (card.isTapped() && !card.hasSickness())
        		  return true;
        	  else 
        		  return false;
          }
          
          public void chooseTargetAI()
          {
        	  PlayerZone play  = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
          	  CardList perms = new CardList(play.getCards());
          	  perms = perms.filter(new CardListFilter()
          	  {
				public boolean addCard(Card c) {
					return c.sumAllCounters() > 0 && CardFactoryUtil.canTarget(card, c);
				}
          	  });
          	  perms.shuffle();
          	  setTargetCard(perms.get(0)); //TODO: improve this.
          }
          
          public boolean canPlayAI()
          {
        	  PlayerZone play  = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
          	  CardList perms = new CardList(play.getCards());
          	  perms = perms.filter(new CardListFilter()
          	  {
				public boolean addCard(Card c) {
					return c.sumAllCounters() > 0;
				}
          	  });
          	  return perms.size() > 0;
          }
        };//SpellAbility
        
        Input runtime = new Input()
	    {
			private static final long serialVersionUID = 1571239319226728848L;

			public void showMessage()
	        {
			  PlayerZone human = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
		      PlayerZone comp = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
			  CardList perms = new CardList();
			  perms.addAll(human.getCards());
			  perms.addAll(comp.getCards());
			  
	          stopSetNext(CardFactoryUtil.input_targetSpecific(a1, perms, "Select target permanent.", true));
	        }
	    };  
        
        card.addSpellAbility(a1);
        a1.setDescription("2 GU, Untap: For each counter on target permanent, put another of those counters on that permanent.");
        
        a1.setBeforePayMana(runtime);
    
  }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Order of Whiteclay"))
    {
    	final SpellAbility a1 = new Ability(card,"1 W W")
        {
          public void resolve()
          {
        	PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
        	PlayerZone play  = AllZone.getZone(Constant.Zone.Play, card.getController());
        	CardList creats = new CardList(grave.getCards());
        	creats = creats.filter(new CardListFilter()
      	  	{
				public boolean addCard(Card c)
				{
					return CardUtil.getConvertedManaCost(c.getManaCost()) <= 3;				
				}
      		  
      	  	});
        	
        	if (card.getController().equals(Constant.Player.Human))
        	{
        		Object o = AllZone.Display.getChoiceOptional("Choose a creature", creats.toArray());
        		if (o!=null)
        		{
        			Card c = (Card)o;
        			grave.remove(c);
        			play.add(c);
        			card.untap();
        		}
        	}
        	else //Computer
        	{
        		Card c = creats.get(0);
        		grave.remove(c);
        		play.add(c);
        		card.untap();
        	}
            
          }
          
          public boolean canPlay()
          {
        	  PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
        	  CardList creats = new CardList(grave.getCards());
        	  creats = creats.filter(new CardListFilter()
        	  {

				public boolean addCard(Card c)
				{
					return CardUtil.getConvertedManaCost(c.getManaCost()) <= 3;				
				}
        		  
        	  });
        	  if (card.isTapped() && !card.hasSickness() && creats.size() > 0)
        		  return true;
        	  else 
        		  return false;
          }
          
          public boolean canPlayAI()
          {
        	  return true;
          }
        };//SpellAbility
        card.addSpellAbility(a1);
        a1.setDescription("1 W W, Untap:  Return target creature card with converted mana cost 3 or less from your graveyard to play.");
        a1.setStackDescription(card.getName() + " - return target creature card with converted mana cost 3 or less from your graveyard to play.");

        a1.setBeforePayMana(new Input_PayManaCost(a1));
    
  }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Patrol Signaler"))
    {
    	final SpellAbility a1 = new Ability(card,"1 W")
        {
          public void resolve()
          {
        	card.untap();
            makeToken();
          }
          void makeToken()
          {
            Card c = new Card();

            c.setName("Kithkin Soldier");
            c.setImageName("W 1 1 Kithkin Soldier");

            c.setOwner(card.getController());
            c.setController(card.getController());

            c.setManaCost("W");
            c.setToken(true);             
            
            c.addType("Creature");
            c.addType("Kithkin");
            c.addType("Soldier");
            c.setBaseAttack(1);
            c.setBaseDefense(1);

            PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
            play.add(c);
          }//makeToken()
          public boolean canPlay()
          {
        	  SpellAbility sa;
        	  for (int i=0; i<AllZone.Stack.size(); i++)
              {
              	sa = AllZone.Stack.peek(i);
              	if (sa.getSourceCard().equals(card))
              			return false;
              }
        	  
        	  if (card.isTapped() && !card.hasSickness())
        		  return true;
        	  else 
        		  return false;
          }
          
          public boolean canPlayAI()
          {
        	  return true;
          }
        };//SpellAbility
        card.addSpellAbility(a1);
        a1.setDescription("1 W, Untap:  Put a 1/1 white Kithkin Soldier creature token into play.");
        a1.setStackDescription(card.getName() + " - put a 1/1 white Kithkin Soldier creature token into play.");

        a1.setBeforePayMana(new Input_PayManaCost(a1));
    
  }//*************** END ************ END **************************
	
  //*************** START *********** START **************************
    if(cardName.equals("Guardian of Cloverdell"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          makeToken();
          makeToken();
          makeToken();
        }//resolve()
        
        public void makeToken()
        {
	        Card c = new Card();
	
	        c.setOwner(card.getController());
	        c.setController(card.getController());
	
	        c.setName("Kithkin Soldier");
	        c.setImageName("W 1 1 Kithkin Soldier");
	        c.setManaCost("W");
	        c.setToken(true);
	
	        c.addType("Creature");
	        c.addType("Kithkin");
	        c.addType("Soldier");
	
	        c.setBaseAttack(1);
	        c.setBaseDefense(1);
	
	        PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
	        play.add(c);
        }

      }; //ability
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -2030165469109890833L;
        public void execute()
        {
          ability.setStackDescription(card.getName() + " - put three 1/1 white Kithkin Soldier creature tokens into play.");
          AllZone.Stack.add(ability);
        }
      };
      
      card.addComesIntoPlayCommand(intoPlay);
      
      final SpellAbility a2 = new Ability(card, "G")
	    {
    	  public void chooseTargetAI()
	    	{
	    		PlayerZone play = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
	        	CardList kiths = new CardList(play.getCards());
	        	kiths = kiths.filter(new CardListFilter()
	        	{

					public boolean addCard(Card c) {
						if(c.getType().contains("Kithkin") || c.getKeyword().contains("Changeling"))
							return true;
						return false;
					}
	        	
	        	});
	        	
	        	if (kiths.size() != 0)
	        		setTargetCard(kiths.getCard(0));
	    	}
    	  
	        public void resolve()
	        {
	          //get all Kithkin:
	          Card c = getTargetCard();
	
	          if(AllZone.GameAction.isCardInPlay(c))
	          {
	            //AllZone.getZone(c).remove(c);
	        	AllZone.GameAction.sacrifice(c);
	        	  
	        	PlayerLife life = AllZone.GameAction.getPlayerLife(c.getController());
	        	life.addLife(1);
	          }
	        }//resolve
	        public boolean canPlayAI()
	        {
	        	if(AllZone.Computer_Life.getLife() < 4)
	        		return true;
	        	else
	        		return false;
	        }
	      };//SpellAbility
	      
	      Input runtime = new Input()
	      {
			private static final long serialVersionUID = 1775972794359668520L;

			public void showMessage()
	        {
	          CardList kith = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
	          kith = kith.getType("Kithkin");
	          
	          stopSetNext(CardFactoryUtil.input_targetSpecific(a2, kith, "Select a Kithkin to sacrifice.", true));
	        }
	      };  
	      
	      card.addSpellAbility(a2);
	      a2.setDescription("Sacrifice a Kithkin: You gain 1 life.");
	      a2.setStackDescription(card.getController() + " gains 1 life.");
	      a2.setBeforePayMana(runtime);
  	
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Ambassador Oak"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Elf Warrior");
          c.setImageName("G 1 1 Elf Warrior");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Elf");
          c.addType("Warrior");

          c.setBaseAttack(1);
          c.setBaseDefense(1);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);

        }//resolve()
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -8593037498281765796L;

		public void execute()
        {
          ability.setStackDescription("Ambassador Oak - put a 1/1 green Elf Warrior creature token into play.");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Mudbutton Torchrunner"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          if(getTargetCard() != null && CardFactoryUtil.canDamage(card, getTargetCard()) && CardFactoryUtil.canTarget(card,getTargetCard()) )
            getTargetCard().addDamage(3);
          else
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(3);
        }
      };
      Command leavesPlay = new Command()
      {
		private static final long serialVersionUID = 2740098107360213191L;

		public void execute()
        {
          if(card.getController().equals(Constant.Player.Human))
            AllZone.InputControl.setInput(CardFactoryUtil.input_targetCreaturePlayer(ability, true));
          else
          {
            CardList list = CardFactoryUtil.AI_getHumanCreature(3, card, true);
            CardListUtil.sortAttack(list);

            if(MyRandom.percentTrue(50))
              CardListUtil.sortFlying(list);

            for(int i = 0; i < list.size(); i++)
              if(2 <= list.get(i).getNetAttack())
                ability.setTargetCard(list.get(i));

            if(ability.getTargetCard() == null)
              ability.setTargetPlayer(Constant.Player.Human);

            AllZone.Stack.add(ability);
          }
        }//execute()
      };//Command
      card.addDestroyCommand(leavesPlay);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Mulldrifter"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          for(int i = 0; i < 2; i++)
            AllZone.GameAction.drawCard(card.getController());
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 9072052875006010497L;

		public void execute()
        {
          ability.setStackDescription(card.getName() +" - " +card.getController() +" draws 2 cards.");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);

      card.addSpellAbility(new Spell_Evoke(card, "2 U")
      {
		private static final long serialVersionUID = 5061298336319833956L;

		public boolean canPlayAI() {return false;}
      });
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Meadowboon"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone zone = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList list = new CardList(zone.getCards());
          list = list.getType("Creature");
          Card c;

          for(int i = 0; i < list.size(); i++)
          {
            c = list.get(i);
            c.addCounter(Counters.P1P1, 1);

          }
        }//resolve()
      };
      Command leavesPlay = new Command()
      {
		private static final long serialVersionUID = -8083212279082607731L;

		public void execute()
        {
          ability.setStackDescription(card.getName() +" - " +card.getController() +" puts a +1/+1 on each creature he controls.");
          AllZone.Stack.add(ability);
        }
      };
      card.addLeavesPlayCommand(leavesPlay);

      card.addSpellAbility(new Spell_Evoke(card, "3 W")
      {
		private static final long serialVersionUID = 5001777391157132871L;

		public boolean canPlayAI() {return false;}
      });
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Sengir Autocrat"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          for(int i = 0; i < 3; i++)
            makeToken();
        }
        void makeToken()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Serf");
          c.setImageName("B 0 1 Serf");
          c.setManaCost("B");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Serf");
          c.setBaseAttack(0);
          c.setBaseDefense(1);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//makeToken()
      };//SpellAbility
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -2966662310531173458L;

		public void execute()
        {
          ability.setStackDescription(card.getName() +" - " +card.getController() +" puts three 0/1 tokens into play");
          AllZone.Stack.add(ability);
        }
      };
      Command leavesPlay = new Command()
      {
		private static final long serialVersionUID = 7242867764317580066L;

		public void execute()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());

          all = all.getType("Serf");
          for(int i = 0; i < all.size(); i++)
            AllZone.GameAction.destroy(all.get(i));
        }//execute
      };//Command
      card.addComesIntoPlayCommand(intoPlay);
      card.addLeavesPlayCommand(leavesPlay);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Haunted Angel"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          makeToken();

          //remove this card from the graveyard and from the game

          //fixed - error if this card is copied like with Kiki, Jiki mirror breaker
          //null pointer exception

          if(card.isToken())
            return;

          AllZone.GameAction.removeFromGame(card);
        }
        void makeToken()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Angel");
          c.setImageName("B 3 3 Angel");
          c.setManaCost("B");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Angel");
          c.setBaseAttack(3);
          c.setBaseDefense(3);
          c.addIntrinsicKeyword("Flying");

          String opponent = AllZone.GameAction.getOpponent(card.getController());
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, opponent);
          play.add(c);
        }//makeToken()
      };//SpellAbility
      Command destroy = new Command()
      {
		private static final long serialVersionUID = 8044338194100037815L;

		public void execute()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          ability.setStackDescription(card.getName() +" - " +opponent +" puts a 3/3 flying token into play");
          AllZone.Stack.add(ability);
        }
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Angel of Mercy") || cardName.equals("Rhox Bodyguard"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = card;
          PlayerLife life = AllZone.GameAction.getPlayerLife(c.getController());
          life.addLife(3);
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 6457889481637587581L;

		public void execute()
        {
          ability.setStackDescription(card.getName() + " - " +card.getController() +" gains 3 life");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************



  //*************** START *********** START **************************
    if(cardName.equals("Groundbreaker") || cardName.equals("Ball Lightning") ||
       cardName.equals("Blistering Firecat") || cardName.equals("Spark Elemental"))
    {
      final SpellAbility spell = new Ability(card, "0")
      {
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(card))
            AllZone.GameAction.sacrifice(card);
        }
      };
      spell.setStackDescription("Sacrifice " +card);

      final Command destroy = new Command()
      {
		private static final long serialVersionUID = -3114095443175559598L;

		public void execute()
        {
          if(AllZone.GameAction.isCardInPlay(card))
            AllZone.Stack.add(spell);
        }
      };

      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 1923179467785421942L;

		public void execute()
        {
          if(!card.isFaceDown())
        	  AllZone.EndOfTurn.addAt(destroy);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
      card.addTurnFaceUpCommand(intoPlay);
      card.setSacrificeAtEOT(true);
    }//*************** END ************ END **************************
    
    
    //*************** START *********** START **************************
    if (cardName.equals("Rukh Egg"))
    {
    	final SpellAbility ability = new Ability(card, "0")
        {
          public void resolve()
          {
            makeToken();
          }
          public void makeToken()
          {
        	  PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
              Card c = new Card();

              c.setOwner(card.getController());
              c.setController(card.getController());

              c.setName("Bird");
              c.setImageName("R 4 4 Bird");
              c.setManaCost("R");
              c.setToken(true);

              c.addType("Creature");
              c.addType("Bird");
              c.setBaseAttack(4);
              c.setBaseDefense(4);
              c.addIntrinsicKeyword("Flying");
              
              play.add(c);
          }
        }; //ability
        ability.setStackDescription(cardName + " - Put a 4/4 red Bird creature token with flying onto the battlefield.");

        
        final Command createBird = new Command()
        {
			private static final long serialVersionUID = 2856638426932227407L;

			public void execute(){
        		AllZone.Stack.add(ability);
        	}
        };
        
        final Command destroy = new Command()
        {
		  private static final long serialVersionUID = 2320128493809478823L;

		  public void execute()
          {
        	  AllZone.EndOfTurn.addAt(createBird);
          }
        };
        
        card.addDestroyCommand(destroy);
    	
    }//*************** END ************ END **************************

	

    //*************** START *********** START **************************
    if(cardName.equals("Primal Plasma") || cardName.equals("Primal Clay"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          String choice = "";
          String choices[] = {"3/3", "2/2 with flying", "1/6 with defender"};

          if(card.getController().equals(Constant.Player.Human))
          {
            choice = (String) AllZone.Display.getChoice("Choose one", choices);
          }
          else
            choice = choices[MyRandom.random.nextInt(3)];

          if(choice.equals("2/2 with flying"))
          {
            card.setBaseAttack(2);
            card.setBaseDefense(2);
            card.addIntrinsicKeyword("Flying");
          }
          if(choice.equals("1/6 with defender"))
          {
            card.setBaseAttack(1);
            card.setBaseDefense(6);
            card.addIntrinsicKeyword("Defender");
          }

        }//resolve()
      };//SpellAbility
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 8957338395786245312L;

		public void execute()
        {
          ability.setStackDescription(card.getName() +" - choose: 3/3, 2/2 flying, 1/6 defender");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Phyrexian Gargantua"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
          life.subtractLife(2);

          AllZone.GameAction.drawCard(card.getController());
          AllZone.GameAction.drawCard(card.getController());
        }//resolve()
      };//SpellAbility
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -3016651104325305186L;

		public void execute()
        {
          ability.setStackDescription("Phyrexian Gargantua - " +card.getController() +" draws 2 cards and loses 2 life");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Phyrexian Rager"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
          life.subtractLife(1);

          AllZone.GameAction.drawCard(card.getController());
        }//resolve()
      };//SpellAbility
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -4808204528319094292L;

		public void execute()
        {
          ability.setStackDescription("Phyrexian Rager - " +card.getController() +" draws 1 card and loses 1 life");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END ************************** 
  
    
    //*************** START *********** START **************************
    if(cardName.equals("Cao Ren, Wei Commander"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
          life.subtractLife(3);

          AllZone.GameAction.drawCard(card.getController());
        }//resolve()
      };//SpellAbility
      Command intoPlay = new Command()
      {

		private static final long serialVersionUID = -6954568998599730697L;

		public void execute()
        {
          ability.setStackDescription("Cao Ren, Wei Commander - " +card.getController() +" loses 3 life");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END ************************** 


    //*************** START *********** START **************************
    if(cardName.equals("Anger"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
        }
      };
      Command destroy = new Command()
      {
		private static final long serialVersionUID = 1707519783018941582L;

		public void execute()
        {
          ability.setStackDescription(card.getName() +" - " +card.getOwner() +" creatures have Haste.");
          AllZone.Stack.add(ability);
        }
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Valor"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
        }
      };
      Command destroy = new Command()
      {
		private static final long serialVersionUID = -3009968608543593584L;

		public void execute()
        {
          ability.setStackDescription(card.getName() +" - " +card.getOwner() +" creatures have First Strike.");
          AllZone.Stack.add(ability);
        }
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Wonder"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
        }
      };
      Command destroy = new Command()
      {
		private static final long serialVersionUID = 340877499423908818L;

		public void execute()
        {
          ability.setStackDescription(card.getName() +" - " +card.getOwner() +" creatures have Flying.");
          AllZone.Stack.add(ability);
        }
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Kokusho, the Evening Star"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());

          PlayerLife opp = AllZone.GameAction.getPlayerLife(opponent);
          PlayerLife my = AllZone.GameAction.getPlayerLife(card.getController());

          opp.subtractLife(5);
          my.addLife(5);
        }
      };
      Command destroy = new Command()
      {
		private static final long serialVersionUID = -2648843419728951661L;

		public void execute()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          ability.setStackDescription("Kokusho, the Evening Star - " +opponent +" loses 5 life and " +card.getController() +" gains 5 life");
          AllZone.Stack.add(ability);
        }
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************






    //*************** START *********** START **************************
    if(cardName.equals("Symbiotic Elf"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          makeToken();
          makeToken();
        }
        void makeToken()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Insect");
          c.setImageName("G 1 1 Insect");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Insect");
          c.setBaseAttack(1);
          c.setBaseDefense(1);

          play.add(c);
        }//makeToken()
      };//SpellAbility

      Command destroy = new Command()
      {
		private static final long serialVersionUID = -7121390569051656027L;

		public void execute()
        {
          ability.setStackDescription("Symbiotic Elf - " +card.getController() +" puts two 1/1 tokens into play ");
          AllZone.Stack.add(ability);
        }
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Chittering Rats"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());

          PlayerZone hand    = AllZone.getZone(Constant.Zone.Hand   , opponent);
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, opponent);

          if(hand.size() == 0)
            return;

          //randomly move card from hand to top of library
          int index = MyRandom.random.nextInt(hand.size());
          Card card = hand.get(index);

          hand.remove(card);
          library.add(card, 0);
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 160195797163952303L;

		public void execute()
        {
          ability.setStackDescription("Chittering Rats - Opponent randomly puts a card from his hand on top of his library.");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Kemuri-Onna"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          if(Constant.Player.Human.equals(opponent))
            AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
          else//computer
            AllZone.GameAction.discardRandom(opponent);
        }//resolve()
      };//SpellAbility
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -6451753440468941341L;

		public void execute()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          ability.setStackDescription(card.getName() +" - " +opponent +" discards a card");

          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Highway Robber") || cardName.equals("Dakmor Ghoul"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          AllZone.GameAction.getPlayerLife(opponent).subtractLife(2);

          AllZone.GameAction.getPlayerLife(card.getController()).addLife(2);
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 321989007584083996L;

		public void execute()
        {
          ability.setStackDescription("Highway Robber - " +card.getController() +" gains 2 life and opponent loses 2 life.");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Serpent Warrior"))
    {
      SpellAbility summoningSpell = new Spell_Permanent(card)
      {
		private static final long serialVersionUID = 1937549779526559727L;

		public boolean canPlayAI()
        {
          return AllZone.Computer_Life.getLife()>3;
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(summoningSpell);

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {

          AllZone.GameAction.getPlayerLife(card.getController()).subtractLife(3);
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 2334517567512130479L;

		public void execute()
        {
          ability.setStackDescription("Serpent Warrior - "
                                      +card.getController() +" loses 3 life");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************

  //*************** START *********** START **************************
    if(cardName.equals("Eviscerator"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          AllZone.GameAction.getPlayerLife(card.getController()).subtractLife(5);
        }
        public boolean canPlayAI()
        {
          return 8 < AllZone.Computer_Life.getLife();
        }
      };
      Command intoPlay = new Command()
      {

		private static final long serialVersionUID = -221296021551561668L;

		public void execute()
        {
          ability.setStackDescription("Eviscerator - " +card.getController() +" loses 5 life");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Foul Imp"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          AllZone.GameAction.getPlayerLife(card.getController()).subtractLife(2);
        }
        public boolean canPlayAI()
        {
          return 4 < AllZone.Computer_Life.getLife();
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -5371716833341661084L;

		public void execute()
        {
          ability.setStackDescription("Foul Imp - " +card.getController() +" loses 2 life");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Drekavac"))
    {
      final Input discard = new Input()
      {
		private static final long serialVersionUID = -6392468000100283596L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Discard from your hand a non-creature card");
          ButtonUtil.disableAll();
        }
        public void selectCard(Card c, PlayerZone zone)
        {
          if(zone.is(Constant.Zone.Hand))
          {
            AllZone.GameAction.discard(c);
            if(c.isCreature())
              AllZone.GameAction.sacrifice(card);
            stop();
          }
        }
      };//Input

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          if(card.getController().equals(Constant.Player.Human))
          {
            if(AllZone.Human_Hand.getCards().length == 0)
              AllZone.GameAction.sacrifice(card);
            else
              AllZone.InputControl.setInput(discard);
          }
          else
          {
            CardList list = new CardList(AllZone.Computer_Hand.getCards());
            list = list.filter(new CardListFilter()
            {
              public boolean addCard(Card c)
              {
                return (!c.isCreature());
              }
            });
            AllZone.GameAction.discard(list.get(0));
          }//else
        }//resolve()
      };//SpellAbility
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 9202753910259054021L;

		public void execute()
        {
          ability.setStackDescription(card.getController() +" sacrifices Drekavac unless he discards a non-creature card");
          AllZone.Stack.add(ability);
        }
      };
      SpellAbility spell = new Spell_Permanent(card)
      {
		private static final long serialVersionUID = -2940969025405788931L;

		//could never get the AI to work correctly
        //it always played the same card 2 or 3 times
        public boolean canPlayAI() {return false;}

        public boolean canPlay()
        {
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          CardList list = new CardList(hand.getCards());
          list.remove(card);
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (!c.isCreature());
            }
          });
          return list.size() != 0;
        }//canPlay()
      };
      card.addComesIntoPlayCommand(intoPlay);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Minotaur Explorer"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          if(hand.getCards().length == 0)
            AllZone.GameAction.sacrifice(card);
          else
            AllZone.GameAction.discardRandom(card.getController());
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 4986114285467649619L;

		public void execute()
        {
          ability.setStackDescription(card.getController() +" - discards at random or sacrifices Minotaur Explorer");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Goretusk Firebeast"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          AllZone.GameAction.getPlayerLife(opponent).subtractLife(4);
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 2977308349468915040L;

		public void execute()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          ability.setStackDescription("Goretusk Firebeast - deals 4 damage to " +opponent);
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Goblin Ringleader"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone libraryZone = AllZone.getZone(Constant.Zone.Library, card.getController());
          PlayerZone hand        = AllZone.getZone(Constant.Zone.Hand   , card.getController());

          //get top 4 cards of the library
          CardList top = new CardList();
          Card[] library = libraryZone.getCards();
          for(int i = 0; i < 4 && i < library.length; i++)
            top.add(library[i]);

          //put top 4 cards on bottom of library
          for(int i = 0; i < top.size(); i++)
          {
            libraryZone.remove(top.get(i));
            libraryZone.add(top.get(i));
          }

          CardList goblin = top.getType("Goblin");

          for(int i = 0; i < goblin.size(); i++)
            AllZone.GameAction.moveTo(hand, goblin.get(i));
        }//resolve()
      };//SpellAbility
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -7538870520237796620L;

		public void execute()
        {
          AllZone.Stack.add(ability);
        }
      };
      ability.setStackDescription("Goblin Ringleader - reveal the top four cards of your library. Put all Goblin cards revealed this way into your hand and the rest on the bottom of your library.");
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Sylvan Messenger"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone libraryZone = AllZone.getZone(Constant.Zone.Library, card.getController());
          PlayerZone hand        = AllZone.getZone(Constant.Zone.Hand   , card.getController());

          //get top 4 cards of the library
          CardList top = new CardList();
          Card[] library = libraryZone.getCards();
          for(int i = 0; i < 4 && i < library.length; i++)
            top.add(library[i]);

          //put top 4 cards on bottom of library
          for(int i = 0; i < top.size(); i++)
          {
            libraryZone.remove(top.get(i));
            libraryZone.add(top.get(i));
          }

          CardList goblin = top.getType("Elf");

          for(int i = 0; i < goblin.size(); i++)
            AllZone.GameAction.moveTo(hand, goblin.get(i));
        }//resolve()
      };//SpellAbility
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 4757054648163014149L;

		public void execute()
        {
          AllZone.Stack.add(ability);
        }
      };
      ability.setStackDescription("Sylvan Messenger - reveal the top four cards of your library. Put all Elf cards revealed this way into your hand and the rest on the bottom of your library.");
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    

    //*************** START *********** START **************************
    if(cardName.equals("Child of Alara"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          
          
          for(int i = 0; i < list.size(); i++)
            if(!list.get(i).getType().contains("Land"))
            {
            	Card c = list.get(i);
            	AllZone.GameAction.destroyNoRegeneration(c);
            }
        }
      };
      Command destroy = new Command()
      {
		private static final long serialVersionUID = -2937565366066183385L;

		public void execute()
        {
          AllZone.Stack.add(ability);
        }
      };
      ability.setStackDescription("Child of Alara - Destroy all non-land permanents, they can't be regenerated");
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Ryusei, the Falling Star"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.getType("Creature");
          for(int i = 0; i < list.size(); i++)
            if(! list.get(i).getKeyword().contains("Flying") && CardFactoryUtil.canDamage(card, list.get(i)))
            	list.get(i).addDamage(5);
        }
      };
      Command destroy = new Command()
      {
		private static final long serialVersionUID = -6585074939675844265L;

		public void execute()
        {
          AllZone.Stack.add(ability);
        }
      };
      ability.setStackDescription("Ryusei, the Falling Star - deals 5 damage to each creature without flying");
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************
    
    
    //*************** START *********** START **************************
    if(cardName.equals("Sleeper Agent"))
    {
    	 final SpellAbility ability = new Ability(card, "0")
         {
    		 public void resolve(){
			    @SuppressWarnings("unused") // opponent
				String opponent = card.getController();
    			((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
			    ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);
			
			    PlayerZone from = AllZone.getZone(card);
			    from.remove(card);
			   
			    card.setController(AllZone.GameAction.getOpponent(card.getOwner()));
			
			    PlayerZone to = AllZone.getZone(Constant.Zone.Play, AllZone.GameAction.getOpponent(card.getOwner()));
			    to.add(card);
			    System.out.println("cards controller = " + card.getController());
			
			    ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
			    ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
    		 }
         };
         
         ability.setStackDescription("When Sleeper Agent comes into play, target opponent gains control of it.");
         Command intoPlay = new Command()
         {
		   private static final long serialVersionUID = -3934471871041458847L;

		   public void execute()
           {
             AllZone.Stack.add(ability);

           }//execute()
         };
         card.addComesIntoPlayCommand(intoPlay);

    }//*************** END ************ END **************************

    //*************** START *********** START **************************
    if(cardName.equals("Flametongue Kavu"))
    {
      final CommandReturn getCreature = new CommandReturn()
      {
        //get target card, may be null
        public Object execute()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(4, card, true);
          CardListUtil.sortAttack(list);
          CardListUtil.sortFlying(list);

          if(list.size() != 0)
          {
            Card c = list.get(0);
            if(3 <= c.getNetAttack() ||
              (2 <= c.getNetAttack() && c.getKeyword().contains("Flying")))
              return c;
          }
          if((AllZone.Computer_Life.getLife() < 10) &&
             (CardFactoryUtil.AI_getHumanCreature(card, true).size() != 0))
          {
            list = CardFactoryUtil.AI_getHumanCreature(card, true);
            CardListUtil.sortAttack(list);
            CardListUtil.sortFlying(list);

            return list.get(0);
          }
          return null;
        }//execute()
      };//CommandReturn

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canDamage(card, getTargetCard()) && CardFactoryUtil.canTarget(card,getTargetCard()) )
            AllZone.GameAction.addDamage(getTargetCard(), 4);
          }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -1920425335456952853L;

		public void execute()
        {
          if(card.getController().equals(Constant.Player.Human))
          {
            AllZone.InputControl.setInput(CardFactoryUtil.input_targetCreature(ability));
            ButtonUtil.disableAll();
          }
          else//computer
          {
            Object o = getCreature.execute();
            if(o != null)//should never happen, but just in case
            {
              ability.setTargetCard((Card)o);
              AllZone.Stack.add(ability);
            }
            else {
              ability.setTargetCard(card);
              AllZone.Stack.add(ability);
            }
          }//else
        }//execute()
      };
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = 5741146386242415357L;

		public boolean canPlayAI()
        {
          Object o = getCreature.execute();

          return (o != null) && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Shriekmaw"))
    {
      final CommandReturn getCreature = new CommandReturn()
      {
        //get target card, may be null
        public Object execute()
        {
          CardList nonblack = CardFactoryUtil.AI_getHumanCreature(card, true);
          nonblack = nonblack.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return(!c.isArtifact() && !CardUtil.getColors(c).contains(Constant.Color.Black));
            }
          });

          CardList list = new CardList(nonblack.toArray());
          CardListUtil.sortAttack(list);
          CardListUtil.sortFlying(list);

          if(list.size() != 0)
          {
            Card c = list.get(0);
            if(2 <= c.getNetAttack() && c.getKeyword().contains("Flying"))
              return c;
          }

          if((AllZone.Computer_Life.getLife() < 10) && list.size() != 0)
          {
            CardListUtil.sortAttack(list);

            if(MyRandom.percentTrue(50))
              CardListUtil.sortFlying(list);

            return list.get(0);
          }
          return null;
        }//execute()
      };//CommandReturn

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = getTargetCard();

          if(AllZone.GameAction.isCardInPlay(c) &&  CardFactoryUtil.canTarget(card,c) &&
             !CardUtil.getColors(c).contains(Constant.Color.Black) &&
             !c.isArtifact())
          {
            AllZone.GameAction.destroy(c);
          }
        }//resolve()
      };//SpellAbility
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -70141932446179740L;

		public void execute()
        {
          Input target = new Input()
          {
			private static final long serialVersionUID = 2634600975568025031L;
			
			public void showMessage()
            {
              AllZone.Display.showMessage("Select target nonartifact, nonblack creature to destroy");
              ButtonUtil.disableAll();
            }
            public void selectCard(Card card, PlayerZone zone)
            {
              if(!CardFactoryUtil.canTarget(ability, card)){
              	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
              }
              else if(card.isCreature() && zone.is(Constant.Zone.Play) &&
                 !card.isArtifact() && !CardUtil.getColors(card).contains(Constant.Color.Black))
              {
                ability.setTargetCard(card);
                AllZone.Stack.add(ability);
                stop();
              }
            }
          };//Input target


          if(card.getController().equals(Constant.Player.Human))
          {
            //get all creatures
            CardList list = new CardList();
            list.addAll(AllZone.Human_Play.getCards());
            list.addAll(AllZone.Computer_Play.getCards());
            list = list.getType("Creature");

            list = list.filter(new CardListFilter()
            {
              public boolean addCard(Card c)
              {
                return(!c.isArtifact() && !CardUtil.getColors(c).contains(Constant.Color.Black));
              }
            });

            if(list.size() != 0)
              AllZone.InputControl.setInput(target);
//              AllZone.InputControl.setInput(CardFactoryUtil.input_targetCreature(ability));
          }
          else//computer
          {
            Object o = getCreature.execute();
            if(o != null)//should never happen, but just in case
            {
              ability.setTargetCard((Card)o);
              AllZone.Stack.add(ability);
            }
          }//else
        }//execute()
      };
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = -7508374608705757486L;

		public boolean canPlayAI()
        {
          Object o = getCreature.execute();

          return (o != null) && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });

      card.addSpellAbility(new Spell_Evoke(card, "1 B")
      {
		private static final long serialVersionUID = 6838065487515852527L;

		public boolean canPlayAI()
        {
          Object o = getCreature.execute();

          return (o != null) && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Briarhorn"))
    {
      final CommandReturn getCreature = new CommandReturn()
      {
        //get target card, may be null
        public Object execute()
        {
          Combat combat = ComputerUtil.getAttackers();
          Card[] c = combat.getAttackers();

          if(c.length == 0)
          {
            CardList list = new CardList();
            list.addAll(AllZone.Computer_Play.getCards());
            list = list.filter(new CardListFilter()
            {
              public boolean addCard(Card c)
              {
                return(c.isCreature() && !c.hasSickness());
              }
            });

            if(list.size() == 0)
              return card;
            else
            {
              CardListUtil.sortAttack(list);
              CardListUtil.sortFlying(list);

              for(int i = 0; i < list.size(); i++)
                if(list.get(i).isUntapped())
                  return list.get(i);

              return list.get(0);
            }

          }

          return c[0];
        }//execute()
      };//CommandReturn

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          final Card c = getTargetCard();

          if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card,c))
          {
            c.addTempAttackBoost(3);
            c.addTempDefenseBoost(3);

            AllZone.EndOfTurn.addUntil(new Command()
            {
			  private static final long serialVersionUID = -5417966443737481535L;

			  public void execute()
              {
                c.addTempAttackBoost(-3);
                c.addTempDefenseBoost(-3);
              }
            });
          }//if
        }//resolve()
      };//SpellAbility
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -5497111036332352337L;

		public void execute()
        {
          if(card.getController().equals(Constant.Player.Human))
          {
              AllZone.InputControl.setInput(CardFactoryUtil.input_targetCreature(ability));
          }
          else//computer
          {
            Object o = getCreature.execute();
            if(o != null)//should never happen, but just in case
            {
              ability.setTargetCard((Card)o);
              AllZone.Stack.add(ability);
            }
          }//else
        }//execute()
      };
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = -681505091538444209L;

		public boolean canPlayAI()
        {
          Object o = getCreature.execute();

          return (o != null) && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });

      card.addSpellAbility(new Spell_Evoke(card, "1 G")
      {
		private static final long serialVersionUID = 8565746177492779899L;
		
		public boolean canPlayAI()
        {
          return false;
        }
        //because this card has Flash
        public boolean canPlay() 
        {
        	if (!AllZone.GameAction.isCardInPlay(card))
        		return true;
        	else
        		return false;
        }
      });
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Inner-Flame Acolyte"))
    {
      final CommandReturn getCreature = new CommandReturn()
      {
        //get target card, may be null
        public Object execute()
        {
          Combat combat = ComputerUtil.getAttackers();
          Card[] c = combat.getAttackers();
          CardList list = new CardList();

          if(c.length == 0)
          {
            list.addAll(AllZone.Computer_Play.getCards());
            list = list.filter(new CardListFilter()
            {
              public boolean addCard(Card c)
              {
                return c.isCreature();
              }
            });

            if(list.size() == 0)
              return card;
            else
            {
              CardListUtil.sortAttack(list);
              CardListUtil.sortFlying(list);

              for(int i = 0; i < list.size(); i++)
                if(list.get(i).isUntapped())
                  return list.get(i);

              return list.get(0);
            }
          }

          return c[0];
        }//execute()
      };//CommandReturn

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          final Card c = getTargetCard();

          if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card,c) )
          {
            c.addTempAttackBoost(2);
            c.addExtrinsicKeyword("Haste");

            AllZone.EndOfTurn.addUntil(new Command()
            {
			  private static final long serialVersionUID = -6478147896119509688L;

			  public void execute()
              {
                c.addTempAttackBoost(-2);
                c.removeExtrinsicKeyword("Haste");
              }
            });
          }//if
        }//resolve()
      };//SpellAbility
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -4514610171270596654L;

		public void execute()
        {
          if(card.getController().equals(Constant.Player.Human))
          {
              AllZone.InputControl.setInput(CardFactoryUtil.input_targetCreature(ability));
          }
          else//computer
          {
            Object o = getCreature.execute();
            if(o != null)//should never happen, but just in case
            {
              ability.setTargetCard((Card)o);
              AllZone.Stack.add(ability);
            }
          }//else
        }//execute()
      };
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = 7153795935713327863L;

		public boolean canPlayAI()
        {
          Object o = getCreature.execute();

          return (o != null) && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });

      card.addSpellAbility(new Spell_Evoke(card, "R")
      {
		private static final long serialVersionUID = 8173305091293824506L;

		public boolean canPlayAI()
        {
          return false;
        }
      });
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Timetwister"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 505983020365091226L;
		
		public void resolve()
        {
          discardDraw7(Constant.Player.Human);
          discardDraw7(Constant.Player.Computer);
        }//resolve()

        void discardDraw7(String player)
        {
          // Discard hand into graveyard
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, player);
          Card[] c = hand.getCards();
          for(int i = 0; i < c.length; i++)
            AllZone.GameAction.discard(c[i]);

          // Move graveyard into library
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, player);
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, player);
          Card[] g = grave.getCards();
          for (int i = 0; i < g.length; i++)
          {
            grave.remove(g[i]);
            library.add(g[i],0);
          }

          // Shuffle library
          AllZone.GameAction.shuffle(player);

          // Draw seven cards
          for(int i = 0; i < 7; i++)
            AllZone.GameAction.drawCard(player);
          
          library.remove(card);
          grave.add(card);
        }

        // Simple, If computer has two or less playable cards remaining in hand play Timetwister
        public boolean canPlayAI()
        {
          Card[] c = removeLand(AllZone.Computer_Hand.getCards());
          return 2 >= c.length;
        }
        Card[] removeLand(Card[] in)
        {
          CardList c = new CardList(in);
          c = c.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return !c.isLand();
            }
          });
          return c.toArray();
        }//removeLand()

      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Slaughterhouse Bouncer"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canDamage(card, getTargetCard()) && CardFactoryUtil.canTarget(card,getTargetCard()) )
            getTargetCard().addDamage(3);
        }
      };
      Command destroy = new Command()
      {
		private static final long serialVersionUID = 1619442728548153928L;

		public void execute()
        {
          //check to see if any other creatures in play
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.getType("Creature");

          //check to see if any cards in hand
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          if(hand.getCards().length == 0 && list.size() != 0)
          {
            if(card.getController().equals(Constant.Player.Human))
            {
              AllZone.InputControl.setInput(CardFactoryUtil.input_targetCreature(ability));
              ButtonUtil.disableAll();
            }
            else//computer
            {
              //1.try to get human creature with defense of 3
              list = CardFactoryUtil.AI_getHumanCreature(card, true);
              list = list.filter(new CardListFilter()
              {
                public boolean addCard(Card c) {return c.getNetDefense() == 3;}
              });
              //2.try to get human creature with defense of 2 or less
              if(list.isEmpty())
                list = CardFactoryUtil.AI_getHumanCreature(2, card, true);
              //3.get any computer creature
              if(list.isEmpty())
              {
                list = new CardList(AllZone.Computer_Play.getCards());
                list = list.getType("Creature");
              }
              list.shuffle();
              ability.setTargetCard(list.get(0));
              AllZone.Stack.add(ability);
            }
          }//if ok to play
        }//execute()
      };//Command
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Undying Beast"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          card.setDamage(0);
          card.setAssignedDamage(0);
          card.untap();

          //moves card to top of library
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getOwner());
          library.add(card, 0);
        }
      };
      Command destroy = new Command()
      {
		private static final long serialVersionUID = -318081458847722674L;

		public void execute()
        {
          if(card.isToken())
            return;

          //remove from graveyard
          PlayerZone grave = AllZone.getZone(card);
          grave.remove(card);

          ability.setStackDescription("Put Undying Beast on top of its owner's library.");
          AllZone.Stack.add(ability);
        }
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Fire Imp") || cardName.equals("Corrupt Eunuchs"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canDamage(card, getTargetCard()) && CardFactoryUtil.canTarget(card,getTargetCard()) )
            getTargetCard().addDamage(2);
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -7639628386947162984L;

		public void execute()
        {
          if(card.getController().equals(Constant.Player.Human))
          {
            AllZone.InputControl.setInput(CardFactoryUtil.input_targetCreature(ability));
            ButtonUtil.disableAll();
          }
          else//computer
          {
            CardList list = CardFactoryUtil.AI_getHumanCreature(2, card, true);
            CardListUtil.sortAttack(list);
            CardListUtil.sortFlying(list);

            if(list.isEmpty())
            {
              list = CardFactoryUtil.AI_getHumanCreature(card, true);
              list.shuffle();
            }
            
            if (list.size() > 0)
            	ability.setTargetCard(list.get(0));
            else 
            	ability.setTargetCard(card);
            
            AllZone.Stack.add(ability);
          }//else
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = 1731831041621831246L;

		public boolean canPlayAI()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(card, true);

          return (list.size() > 0) && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });

    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Man-o'-War") || cardName.equals("Sun Ce, Young Conquerer"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = getTargetCard();
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, c.getOwner());

          if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card,getTargetCard()) )
          {
            AllZone.getZone(c).remove(c);

            if(! c.isToken())
            {
              Card newCard = AllZone.CardFactory.getCard(c.getName(), c.getOwner());
              hand.add(newCard);
            }
          }
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -7628289586347295144L;

		public void execute()
        {
          if(card.getController().equals(Constant.Player.Human))
          {
            AllZone.InputControl.setInput(CardFactoryUtil.input_targetCreature(ability));
            ButtonUtil.disableAll();
          }
          else//computer
          {
            Card human = CardFactoryUtil.AI_getBestCreature(CardFactoryUtil.AI_getHumanCreature(card, true));
            ability.setTargetCard(human);
            
            
            if (human == null)
            	ability.setTargetCard(card);
                        
            AllZone.Stack.add(ability);
          }//else
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = 2458286917800051358L;

		public boolean canPlayAI()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(card, true);

          return (list.size() > 0) && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Keening Banshee"))
    {
      
      final SpellAbility ability = new Ability(card, "0")
      {
        
        public void resolve()
        {
          final Card c = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card,c) )
          {
        	c.addTempAttackBoost(-2);
          	c.addTempDefenseBoost(-2);

          	AllZone.EndOfTurn.addUntil(new Command()
          	{
				private static final long serialVersionUID = 8479364459667467780L;

				public void execute()
          		{
          			c.addTempAttackBoost(2);
          			c.addTempDefenseBoost(2);
          		}
          	});
          }
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 6283666887577455663L;

		public void execute()
        {
          if(card.getController().equals(Constant.Player.Human))
          {
            AllZone.InputControl.setInput(CardFactoryUtil.input_targetCreature(ability));
            ButtonUtil.disableAll();
          }
          else//computer
          {
            CardList list = CardFactoryUtil.AI_getHumanCreature(2, card, true);
            CardListUtil.sortAttack(list);
            CardListUtil.sortFlying(list);

            if(list.isEmpty())
            {
              list = CardFactoryUtil.AI_getHumanCreature(card, true);
              list.shuffle();
            }

            ability.setTargetCard(list.get(0));
            AllZone.Stack.add(ability);
          }//else
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = -1893090545602255371L;

		public boolean canPlayAI()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(card, true);

          return (list.size() > 0) && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });

    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Dragon Roost"))
    {
      final SpellAbility ability = new Ability(card, "5 R R")
      {
        public void resolve()
        {
          Card c = new Card();
          
          c.setName("Dragon");
          c.setImageName("R 5 5 Dragon");
          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setManaCost("R");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Dragon");
          c.setBaseAttack(5);
          c.setBaseDefense(5);
          c.addIntrinsicKeyword("Flying");

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//resolve()
      };
      ability.setDescription("5RR: Put a 5/5 red Dragon creature token with flying into play.");
      ability.setStackDescription("Dragon Roost - Put a 5/5 red Dragon creature token with flying into play.");
      card.addSpellAbility(ability);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("The Hive"))
    {
      final SpellAbility ability = new Ability_Tap(card, "5")
      {
		private static final long serialVersionUID = -1091111822316858416L;

		public void resolve()
        {
          Card c = new Card();
          c.setName("Wasp");
          c.setImageName("C 1 1 Wasp");

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setManaCost("");
          c.setToken(true);

          c.addType("Artifact");
          c.addType("Creature");
          c.addType("Insect");

          c.setBaseAttack(1);
          c.setBaseDefense(1);
          c.addIntrinsicKeyword("Flying");

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//resolve()
      };
      ability.setDescription("5, tap: Put a 1/1 Insect artifact creature token with flying named Wasp into play.");
      ability.setStackDescription("The Hive - Put a 1/1 token with flying into play.");
      card.addSpellAbility(ability);
    }//*************** END ************ END **************************

  //*************** START *********** START **************************
    if(cardName.equals("Mobilization"))
    {
    	final SpellAbility ability = new Ability(card, "2 W")
        {
          public void resolve()
          {
            Card c = new Card();
            c.setName("Soldier");
            c.setImageName("W 1 1 Soldier");

            c.setOwner(card.getController());
            c.setController(card.getController());

            c.setManaCost("W");
            c.setToken(true);

            c.addType("Creature");
            c.addType("Soldier");

            c.setBaseAttack(1);
            c.setBaseDefense(1);

            PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
            play.add(c);
          }//resolve()
        };
        ability.setDescription("2W: Put a 1/1 white Soldier creature token into play.");
        ability.setStackDescription("Mobilization - Put a 1/1 Soldier token into play.");
        card.addSpellAbility(ability);
    	
    	
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Ant Queen"))
    {
    	final SpellAbility ability = new Ability(card, "1 G")
        {
          public void resolve()
          {
            Card c = new Card();
            c.setName("Insect");
            c.setImageName("G 1 1 Insect");

            c.setOwner(card.getController());
            c.setController(card.getController());

            c.setManaCost("G");
            c.setToken(true);

            c.addType("Creature");
            c.addType("Insect");

            c.setBaseAttack(1);
            c.setBaseDefense(1);

            PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
            play.add(c);
          }//resolve()
        };
        ability.setDescription("1 G: Put a 1/1 green Insect creature token onto the battlefield.");
        ability.setStackDescription(card.getName() +  " - Put a 1/1 green Insect token onto the battlefield.");
        card.addSpellAbility(ability);
    	
    	
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Centaur Glade"))
    {
      final SpellAbility ability = new Ability(card, "2 G G")
      {
        public void resolve()
        {
          Card c = new Card();
          c.setName("Centaur");
          c.setImageName("G 3 3 Centaur");

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Centaur");

          c.setBaseAttack(3);
          c.setBaseDefense(3);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//resolve()
      };
      ability.setDescription("2GG: Put a 3/3 green Centaur creature token into play.");
      ability.setStackDescription("Centaur Glade - Put a 3/3 token into play.");
      card.addSpellAbility(ability);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Eternal Witness"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          if(AllZone.GameAction.isCardInZone(getTargetCard(), grave))
          {
            PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
            AllZone.GameAction.moveTo(hand, getTargetCard());
          }
        }//resolve()
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 1658050744890095441L;

		public void execute()
        {
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());

          if(grave.getCards().length == 0)
            return;

          if(card.getController().equals(Constant.Player.Human))
          {
            Object o = AllZone.Display.getChoiceOptional("Select target card", grave.getCards());
            if(o != null)
            {
              ability.setTargetCard((Card)o);
              AllZone.Stack.add(ability);
            }
          }
          else//computer
          {
            CardList list = new CardList(grave.getCards());
            Card best = CardFactoryUtil.AI_getBestCreature(list);

            if(best == null)
            {
              list.shuffle();
              best = list.get(0);
            }
            ability.setTargetCard(best);
            AllZone.Stack.add(ability);
          }
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Gravedigger"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          if(AllZone.GameAction.isCardInZone(getTargetCard(), grave))
          {
            PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
            AllZone.GameAction.moveTo(hand, getTargetCard());
          }
        }//resolve()
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -7433708170033536384L;

		public void execute()
        {
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          CardList list = new CardList(grave.getCards());
          list = list.getType("Creature");

          if(list.isEmpty())
            return;

          if(card.getController().equals(Constant.Player.Human))
          {
            Object o = AllZone.Display.getChoiceOptional("Select target card", list.toArray());
            if(o != null)
            {
              ability.setTargetCard((Card)o);
              AllZone.Stack.add(ability);
            }
          }//if
          else//computer
          {
            Card best = CardFactoryUtil.AI_getBestCreature(list);
            ability.setTargetCard(best);
            AllZone.Stack.add(ability);
          }
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Strongarm Thug"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          if(AllZone.GameAction.isCardInZone(getTargetCard(), grave))
          {
            PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
            AllZone.GameAction.moveTo(hand, getTargetCard());
          }
        }//resolve()
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 4519970074391756730L;

		public void execute()
        {
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          CardList list = new CardList(grave.getCards());
          list = list.getType("Mercenary");

          if(list.isEmpty())
            return;

          if(card.getController().equals(Constant.Player.Human))
          {
            Object o = AllZone.Display.getChoiceOptional("Select target card", list.toArray());
            if(o != null)
            {
              ability.setTargetCard((Card)o);
              AllZone.Stack.add(ability);
            }
          }//if
          else//computer
          {
            Card best = CardFactoryUtil.AI_getBestCreature(list);
            ability.setTargetCard(best);
            AllZone.Stack.add(ability);
          }
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************

    //*************** START *********** START ************************
    if (cardName.equals("Aedun Oakenshield"))
    {
    	final Ability_Tap ability = new Ability_Tap(card, "B R G")
        {
			private static final long serialVersionUID = -7913968639880781838L;
			public boolean canPlayAI() {return getGraveCreatures().size() != 0;}
	
	          public void chooseTargetAI()
	          {
	            CardList grave = getGraveCreatures();
	            Card target = CardFactoryUtil.AI_getBestCreature(grave);
	            setTargetCard(target);
	          }
	
	          public void resolve()
	          {
	            if(card.getController().equals(Constant.Player.Human))
	            {
	              Card c = (Card) AllZone.Display.getChoice("Select card", getGraveCreatures().toArray());
	              setTargetCard(c);
	            }
	
	            PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
	            PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
	
	            if(AllZone.GameAction.isCardInZone(getTargetCard(), grave))
	               AllZone.GameAction.moveTo(hand, getTargetCard());
	          }//resolve()
	          public boolean canPlay()
	          {
	            return getGraveCreatures().size() != 0;
	          }
	          CardList getGraveCreatures()
	          {
	            PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
	            CardList list = new CardList(grave.getCards());
	            list = list.getType("Creature");
	            return list;
	          }
        };//SpellAbility
        ability.setDescription("B R G, Tap: Return target creature card from your graveyard to your hand.");
        ability.setStackDescription(cardName + " - return target creature from your graveyard to your hand.");
        
        card.clearSpellAbility();
        card.addSpellAbility(ability);
    
    
  	}//*************** END ************ END **************************

    //*************** START *********** START **************************
    if(cardName.equals("Raise Dead") || cardName.equals("Disentomb") || cardName.equals("Return to Battle") ||
       cardName.equals("Recover"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -5822375745105110975L;
		public boolean canPlayAI() {return getGraveCreatures().size() != 0;}

        public void chooseTargetAI()
        {
          CardList grave = getGraveCreatures();
          Card target = CardFactoryUtil.AI_getBestCreature(grave);
          setTargetCard(target);
        }

        public void resolve()
        {
          if(card.getController().equals(Constant.Player.Human))
          {
            Card c = (Card) AllZone.Display.getChoice("Select card", getGraveCreatures().toArray());
            setTargetCard(c);
          }

          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());

          if(AllZone.GameAction.isCardInZone(getTargetCard(), grave))
             AllZone.GameAction.moveTo(hand, getTargetCard());
        }//resolve()
        public boolean canPlay()
        {
          return getGraveCreatures().size() != 0;
        }
        CardList getGraveCreatures()
        {
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          CardList list = new CardList(grave.getCards());
          list = list.getType("Creature");
          return list;
        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Anarchist"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          if(AllZone.GameAction.isCardInZone(getTargetCard(), grave))
          {
            PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
            AllZone.GameAction.moveTo(hand, getTargetCard());
          }
        }//resolve()
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -7459412502903144952L;

		public void execute()
        {
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          CardList sorcery = new CardList(grave.getCards());
          sorcery = sorcery.getType("Sorcery");

          String controller = card.getController();

          if(sorcery.size() == 0)
            return;

          if(controller.equals(Constant.Player.Human))
          {
            Object o = AllZone.Display.getChoiceOptional("Select target card", sorcery.toArray());
            if(o != null)
            {
              ability.setTargetCard((Card)o);
              AllZone.Stack.add(ability);
            }
          }
          else //computer
          {
            sorcery.shuffle();
            ability.setTargetCard(sorcery.get(0));
            AllZone.Stack.add(ability);
          }

        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Penumbra Kavu"))
    {
      final Ability ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());
          
          c.setName("Kavu");
          c.setImageName("B 3 3 Kavu");
          c.setManaCost("B");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Kavu");
          c.setBaseAttack(3);
          c.setBaseDefense(3);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//resolve()
      };//Ability

      Command destroy = new Command()
      {
		private static final long serialVersionUID = 1281791927604583468L;

		public void execute()
        {
          ability.setStackDescription(card.getController() +" puts a 3/3 creature into play from Penumbra Kavu");
          AllZone.Stack.add(ability);
        }
      };

      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Penumbra Bobcat"))
    {
      final Ability ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Cat");
          c.setImageName("B 2 1 Cat");
          c.setManaCost("B");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Cat");
          c.setBaseAttack(2);
          c.setBaseDefense(1);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//resolve()
      };//Ability

      Command destroy = new Command()
      {
		private static final long serialVersionUID = -8057009255325020247L;

		public void execute()
        {
          ability.setStackDescription(card.getController() +" puts a 2/1 creature into play from Penumbra Bobcat");
          AllZone.Stack.add(ability);
        }
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Penumbra Spider"))
    {
      final Ability ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Spider");
          c.setImageName("B 2 4 Spider");
          c.setManaCost("B");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Spider");
          c.setBaseAttack(2);
          c.setBaseDefense(4);
          c.addIntrinsicKeyword("Reach");

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//resolve()
      };//Ability

      Command destroy = new Command()
      {
		private static final long serialVersionUID = 9186718803540678064L;

		public void execute()
        {
          ability.setStackDescription(card.getController() +" puts a 2/4 Black Spider creature into play from Penumbra Spider");
          AllZone.Stack.add(ability);
        }
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Penumbra Wurm"))
    {
      final Ability ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Wurm");
          c.setImageName("B 6 6 Wurm");
          c.setManaCost("B");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Wurm");
          c.setBaseAttack(6);
          c.setBaseDefense(6);
          c.addIntrinsicKeyword("Trample");

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//resolve()
      };//Ability

      Command destroy = new Command()
      {
		private static final long serialVersionUID = -8819664543962631239L;

		public void execute()
        {
          ability.setStackDescription(card.getController() +" puts a 6/6 Black Wurm creature with trample into play from Penumbra Wurm");
          AllZone.Stack.add(ability);
        }
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Aven Fisher") || cardName.equals("Riptide Crab"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());
        }
      };
      Command destroy = new Command()
      {
		private static final long serialVersionUID = -2786138225183288814L;

		public void execute()
        {
          ability.setStackDescription(card.getName() + " - " + card.getController() +" draws a card");
          AllZone.Stack.add(ability);
        }
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Peregrine Drake"))
    {
      final Input untap = new Input()
      {
		private static final long serialVersionUID = 2287264826189281795L;
		
		int stop = 5;
        int count = 0;

        public void showMessage()
        {
          AllZone.Display.showMessage("Select a land to untap");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if(card.isLand() && zone.is(Constant.Zone.Play))
          {
            card.untap();
            count++;
            if(count == stop)
              stop();
          }
        }//selectCard()
      };

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          if(card.getController().equals("Human"))
            AllZone.InputControl.setInput(untap);
          else
          {
            CardList list = new CardList(AllZone.Computer_Play.getCards());
            list = list.filter(new CardListFilter()
            {
              public boolean addCard(Card c)
              {
                return c.isLand() && c.isTapped();
              }
            });
            for(int i = 0; i < 5 && i < list.size(); i++)
              list.get(i).untap();
          }//else
        }//resolve()
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 3208277692165539396L;

		public void execute()
        {
          ability.setStackDescription(card.getController() +" untaps up to 5 lands.");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
  
    //*************** START *********** START **************************
    if(cardName.equals("Cloud of Faeries"))
    {
      final Input untap = new Input()
      {
		private static final long serialVersionUID = -2167059918040912025L;
		
		int stop = 2;
        int count = 0;

        public void showMessage()
        {
          AllZone.Display.showMessage("Select a land to untap");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if(card.isLand() && zone.is(Constant.Zone.Play))
          {
            card.untap();
            count++;
            if(count == stop)
              stop();
          }
        }//selectCard()
      };

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          if(card.getController().equals("Human"))
            AllZone.InputControl.setInput(untap);
          else
          {
            CardList list = new CardList(AllZone.Computer_Play.getCards());
            list = list.filter(new CardListFilter()
            {
              public boolean addCard(Card c)
              {
                return c.isLand() && c.isTapped();
              }
            });
            for(int i = 0; i < 2 && i < list.size(); i++)
            {
              list.get(i).untap();
            }
          }//else
        }//resolve()
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 7222997838166323277L;

		public void execute()
        {
          ability.setStackDescription(card.getController() +" untaps up to 2 lands.");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);

      //add cycling
      card.addSpellAbility(CardFactoryUtil.ability_cycle(card, "2"));
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Vodalian Merchant"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());

          if(card.getController().equals("Human"))
            AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
          else
            AllZone.GameAction.discardRandom("Computer");
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -8924243774757009091L;

		public void execute()
        {
          ability.setStackDescription(card.getController() +" draws a card, then discards a card");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Whirlpool Rider"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          //shuffle hand into library, then shuffle library
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          PlayerZone hand    = AllZone.getZone(Constant.Zone.Hand   , card.getController());
          Card c[] = hand.getCards();
          for(int i = 0; i < c.length; i++)
              AllZone.GameAction.moveTo(library, c[i]);
          AllZone.GameAction.shuffle(card.getController());

          //draw same number of cards as before
          for(int i = 0; i < c.length; i++)
            AllZone.GameAction.drawCard(card.getController());
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 6290392806910817877L;

		public void execute()
        {
          ability.setStackDescription(card.getController() +" shuffles the cards from his hand into his library, then draws that many cards.");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Sky Swallower"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          String opp = AllZone.GameAction.getOpponent(card.getController());
          PlayerZone oppPlay = AllZone.getZone(Constant.Zone.Play, opp);
          PlayerZone myPlay = AllZone.getZone(Constant.Zone.Play, card.getController());

          CardList list = new CardList(myPlay.getCards());
          list.remove(card);//doesn't move Sky Swallower
          while(! list.isEmpty())
          {
        	((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
	        ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);
            //so "comes into play" abilities don't trigger
            ///list.get(0).addComesIntoPlayCommand(Command.Blank);

            oppPlay.add(list.get(0));
            myPlay.remove(list.get(0));

            list.get(0).setController(opp);
            list.remove(0);
            
            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
	        ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
          }
        }//resolve()
      };

      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -453410206437839334L;

		public void execute()
        {
          ability.setStackDescription(AllZone.GameAction.getOpponent(card.getController()) +" gains control of all other permanents you control");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Terror"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 8809370679594989382L;
		
		public boolean canPlayAI()
        {
          return (getCreature().size() != 0) && (AllZone.Phase.getTurn() > 4);
        }
        public void chooseTargetAI()
        {
          Card best = CardFactoryUtil.AI_getBestCreature(getCreature());
          setTargetCard(best);
        }
        CardList getCreature()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(card, true);
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (! CardUtil.getColors(c).contains(Constant.Color.Black)) &&
                     (! c.getType().contains("Artifact"))                     &&
                     (2 < c.getNetAttack());
            }
          });
          return list;
        }//getCreature()
        public void resolve()
        {
          if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
        	  AllZone.GameAction.destroyNoRegeneration(getTargetCard());
        }//resolve()
      };

      Input runtime = new Input()
      {
		private static final long serialVersionUID = -1750678113925588670L;

		public void showMessage()
        {
          CardList choice = new CardList();
          choice.addAll(AllZone.Human_Play.getCards());
          choice.addAll(AllZone.Computer_Play.getCards());

          choice = choice.getType("Creature");
          choice = choice.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (! CardUtil.getColors(c).contains(Constant.Color.Black)) &&
                     (! c.getType().contains("Artifact"));
            }
          });

          stopSetNext(CardFactoryUtil.input_targetSpecific(spell, choice, "Select target non-artifact, non-black creature to destroy.", true));
        }
      };

      card.clearSpellAbility();
      spell.setBeforePayMana(runtime);
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Expunge"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 5773953475935635628L;
		
		public boolean canPlayAI()
        {
          return (getCreature().size() != 0) && (AllZone.Phase.getTurn() > 4);
        }
        public void chooseTargetAI()
        {
          Card best = CardFactoryUtil.AI_getBestCreature(getCreature());
          setTargetCard(best);
        }
        CardList getCreature()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(card, true);
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (! CardUtil.getColors(c).contains(Constant.Color.Black)) &&
                     (! c.getType().contains("Artifact"))                     &&
                     (2 < c.getNetAttack());
            }
          });
          return list;
        }//getCreature()
        public void resolve()
        {
          AllZone.GameAction.destroyNoRegeneration(getTargetCard());
        }//resolve()
      };

      Input runtime = new Input()
      {
		private static final long serialVersionUID = 3015711791310250186L;

		public void showMessage()
        {
          CardList choice = new CardList();
          choice.addAll(AllZone.Human_Play.getCards());
          choice.addAll(AllZone.Computer_Play.getCards());

          choice = choice.getType("Creature");
          choice = choice.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (! CardUtil.getColors(c).contains(Constant.Color.Black)) &&
                     (! c.getType().contains("Artifact"));
            }
          });

          stopSetNext(CardFactoryUtil.input_targetSpecific(spell, choice, "Select target non-artifact, non-black creature to destroy.", true));
        }
      };

      card.clearSpellAbility();
      spell.setBeforePayMana(runtime);

      spell.setDescription(card.getText());
      card.addSpellAbility(spell);


      card.addSpellAbility(CardFactoryUtil.ability_cycle(card, "2"));
    }//*************** END ************ END **************************






    //*************** START *********** START **************************
    if(cardName.equals("Pongify"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -7657135492744577568L;
		
		public boolean canPlayAI()
        {
          return (getCreature().size() != 0) && (AllZone.Phase.getTurn() > 4);
        }
        public void chooseTargetAI()
        {
          Card best = CardFactoryUtil.AI_getBestCreature(getCreature());
          setTargetCard(best);
        }
        CardList getCreature()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(card, true);
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (3 < c.getNetAttack());
            }
          });
          return list;
        }//getCreature()
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card,getTargetCard()) )
          {
            PlayerZone play = AllZone.getZone(getTargetCard());
            makeToken(play, getTargetCard().getController());

            AllZone.GameAction.destroyNoRegeneration(getTargetCard());
          }
        }//resolve()
        void makeToken(PlayerZone play, String controller)
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(controller);

          c.setName("Ape");
          c.setImageName("G 3 3 Ape");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Ape");
          c.setBaseAttack(3);
          c.setBaseDefense(3);

          play.add(c);
        }
      };//SpellAbility

      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Devour in Shadow"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 215990562522519924L;
		
		public boolean canPlayAI()
        {
          return (getCreature().size() != 0) && (AllZone.Phase.getTurn() > 4);
        }
        public void chooseTargetAI()
        {
          Card best = CardFactoryUtil.AI_getBestCreature(getCreature());
          setTargetCard(best);

          if(AllZone.Computer_Life.getLife() <= best.getNetDefense())
          {
            CardList human = CardFactoryUtil.AI_getHumanCreature(AllZone.Computer_Life.getLife() - 1, card, true);
            CardListUtil.sortAttack(human);

            if(0 < human.size())
              setTargetCard(human.get(0));
          }
        }
        CardList getCreature()
        {
          return CardFactoryUtil.AI_getHumanCreature(card, true);
        }//getCreature()
        public void resolve()
        {
          if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
          {
	          AllZone.GameAction.destroyNoRegeneration(getTargetCard());
	
	          PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
	          life.subtractLife(getTargetCard().getNetDefense());
          }
        }//resolve()
      };

      card.clearSpellAbility();
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Terminate"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 3334967250557638367L;
		
		public boolean canPlayAI()
        {
          return (getCreature().size() != 0) && (AllZone.Phase.getTurn() > 4);
        }
        public void chooseTargetAI()
        {
          Card best = CardFactoryUtil.AI_getBestCreature(getCreature());
          setTargetCard(best);

          CardList human = CardFactoryUtil.AI_getHumanCreature(AllZone.Computer_Life.getLife() - 1, card, true);
          CardListUtil.sortAttack(human);

          if(0 < human.size())
            setTargetCard(human.get(0));
          
        }
        CardList getCreature()
        {
          return CardFactoryUtil.AI_getHumanCreature(card, true);
        }//getCreature()
        public void resolve()
        {
          if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
        	  AllZone.GameAction.destroyNoRegeneration(getTargetCard());
        }//resolve()
      };

      card.clearSpellAbility();
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Kinsbaile Borderguard"))
    {
    	final SpellAbility ability = new Ability(card, "0")
        {
          public void resolve()
          {
             card.addCounter(Counters.P1P1, countKithkin());
             //System.out.println("all counters: " +card.sumAllCounters());
          }//resolve()
          
          public int countKithkin()
          {
        	  PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
        	  CardList kithkin = new CardList(play.getCards());
        	  kithkin = kithkin.filter(new CardListFilter()        	  
        	  {

				public boolean addCard(Card c)
				{
					return (c.getType().contains("Kithkin") || c.getKeyword().contains("Changeling"))&& !c.equals(card);
				}
        		  
        	  });
        	  return kithkin.size();
        	  
          }
          @SuppressWarnings("unused") // makeToken
		  public void makeToken()
          {
        	  Card c = new Card();

              c.setOwner(card.getController());
              c.setController(card.getController());

              c.setName("Kithkin Soldier");
              c.setImageName("W 1 1 Kithkin Soldier");
              c.setManaCost("W");
              c.setToken(true);

              c.addType("Creature");
              c.addType("Kithkin");
              c.addType("Soldier");

              c.setBaseAttack(1);
              c.setBaseDefense(1);

              PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
              play.add(c);
          }
        };
        Command intoPlay = new Command()
        {
		  private static final long serialVersionUID = -7067218066522935060L;

		  public void execute()
          {
            ability.setStackDescription("Kinsbaile Borderguard comes into play with a +1/+1 counter on it for each other Kithkin you control.");
            AllZone.Stack.add(ability);
          }
        };
        
        final SpellAbility ability2 = new Ability(card, "0")
        {
          public void resolve()
          {
             for (int i=0;i<card.sumAllCounters();i++)
             {
            	 makeToken();
             }
          }//resolve()
          
          public void makeToken()
          {
        	  Card c = new Card();

              c.setOwner(card.getController());
              c.setController(card.getController());

              c.setName("Kithkin Soldier");
              c.setImageName("W 1 1 Kithkin Soldier");
              c.setManaCost("W");
              c.setToken(true);

              c.addType("Creature");
              c.addType("Kithkin");
              c.addType("Soldier");

              c.setBaseAttack(1);
              c.setBaseDefense(1);

              PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
              play.add(c);
          }
          
        };
        
        Command destroy = new Command()
        {
		  private static final long serialVersionUID = 304026662487997331L;

		  public void execute()
          {
            ability2.setStackDescription("When Kinsbaile Borderguard is put into a graveyard from play, put a 1/1 white Kithkin Soldier creature token into play for each counter on it.");
            AllZone.Stack.add(ability2);
          }
        };
        
        
        card.addComesIntoPlayCommand(intoPlay);
        card.addDestroyCommand(destroy);
    	
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Nova Chaser") || cardName.equals("Supreme Exemplar"))
    {
      final CommandReturn getCreature = new CommandReturn()
      {
        public Object execute()
        {
          //get all creatures
          CardList list = new CardList();
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          list.addAll(play.getCards());
          
          list = list.filter(new CardListFilter(){
			public boolean addCard(Card c) {
				return c.getType().contains("Elemental") || c.getKeyword().contains("Changeling");
			}
          });

          return list;
        }
      };//CommandReturn

      final SpellAbility abilityComes = new Ability(card, "0")
      {
        public void resolve()
        {
          if (getTargetCard() == null || getTargetCard() == card)
        	  AllZone.GameAction.sacrifice(card);
          
          else if(AllZone.GameAction.isCardInPlay(getTargetCard()))
          {
        	/*
            PlayerZone play = AllZone.getZone(getTargetCard());
            PlayerZone removed = AllZone.getZone(Constant.Zone.Removed_From_Play, getTargetCard().getController());
            play.remove(getTargetCard());
            removed.add(getTargetCard());
            */
        	AllZone.GameAction.removeFromGame(getTargetCard());  
          }
        }//resolve()
      };

      final Input inputComes = new Input()
      {
		private static final long serialVersionUID = -6066115143834426784L;

		public void showMessage()
        {
          CardList choice = (CardList)getCreature.execute();

          stopSetNext(CardFactoryUtil.input_targetSpecific(abilityComes, choice, "Select Elemental to remove from the game", false));
          ButtonUtil.disableAll();
        }

      };
      Command commandComes = new Command()
      {
		private static final long serialVersionUID = -3498068247359658023L;

		public void execute()
        {
          CardList creature = (CardList)getCreature.execute();
          String s = card.getController();
          if(creature.size() == 0) {
        	  AllZone.GameAction.sacrifice(card);
        	  return;
          }
          else if(s.equals(Constant.Player.Human))
            AllZone.InputControl.setInput(inputComes);
          else //computer
          {
            Card target;
            //must target computer creature
            CardList computer = new CardList(AllZone.Computer_Play.getCards());
            computer = computer.getType("Elemental");
            computer.remove(card);

            computer.shuffle();
            if (computer.size()!= 0) {
            	  target = computer.get(0);
            	  abilityComes.setTargetCard(target);
            	  AllZone.Stack.add(abilityComes);
            }
          }//else
        }//execute()
      };//CommandComes
      Command commandLeavesPlay = new Command()
      {
		private static final long serialVersionUID = 4236503599017025393L;

		public void execute()
        {
          //System.out.println(abilityComes.getTargetCard().getName());
          Object o = abilityComes.getTargetCard();
          
          if(o == null || ((Card)o).isToken()|| !AllZone.GameAction.isCardRemovedFromGame((Card)o) )
            return;

          SpellAbility ability = new Ability(card, "0")
          {
            public void resolve()
            {
              //copy card to reset card attributes like attack and defense
              Card c = abilityComes.getTargetCard();
              if(! c.isToken())
              {
                c = AllZone.CardFactory.copyCard(c);
                c.setController(c.getOwner());

                PlayerZone play = AllZone.getZone(Constant.Zone.Play, c.getOwner());
                PlayerZone removed = AllZone.getZone(Constant.Zone.Removed_From_Play, c.getOwner());
                removed.remove(c);
                play.add(c);
                
              }
            }//resolve()
          };//SpellAbility
          ability.setStackDescription(card.getName() + " - returning creature to play");
          AllZone.Stack.add(ability);
        }//execute()
      };//Command

      card.addComesIntoPlayCommand(commandComes);
      card.addLeavesPlayCommand(commandLeavesPlay);
      
      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = -62128538015338896L;

		public boolean canPlayAI()
        {
          Object o = getCreature.execute();
          if (o == null)
        	  return false;
          
          CardList cl = (CardList)getCreature.execute();
          return (o != null) && cl.size() > 0 && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Wren's Run Packmaster"))
    {
      final CommandReturn getCreature = new CommandReturn()
      {
        public Object execute()
        {
          //get all creatures
          CardList list = new CardList();
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          list.addAll(play.getCards());
          
          list = list.filter(new CardListFilter(){
			public boolean addCard(Card c) {
				return c.getType().contains("Elf") || c.getKeyword().contains("Changeling");
			}
          });

          return list;
        }
      };//CommandReturn

      final SpellAbility abilityComes = new Ability(card, "0")
      {
        public void resolve()
        {
          if (getTargetCard() == null || getTargetCard() == card)
        	  AllZone.GameAction.sacrifice(card);
          
          else if(AllZone.GameAction.isCardInPlay(getTargetCard()))
          {
        	/*
            PlayerZone play = AllZone.getZone(getTargetCard());
            PlayerZone removed = AllZone.getZone(Constant.Zone.Removed_From_Play, getTargetCard().getController());
            play.remove(getTargetCard());
            removed.add(getTargetCard());
            */
        	AllZone.GameAction.removeFromGame(getTargetCard());  
          }
        }//resolve()
      };

      final Input inputComes = new Input()
      {
		private static final long serialVersionUID = 5210700665533271691L;

		public void showMessage()
        {
          CardList choice = (CardList)getCreature.execute();

          stopSetNext(CardFactoryUtil.input_targetSpecific(abilityComes, choice, "Select Elf to remove from the game", false));
          ButtonUtil.disableAll(); //target this card means: sacrifice this card
        }
      };
      Command commandComes = new Command()
      {

		private static final long serialVersionUID = -3580408066322945328L;

		public void execute()
        {
          CardList creature = (CardList)getCreature.execute();
          String s = card.getController();
          if(creature.size() == 0) {
        	  AllZone.GameAction.sacrifice(card);
        	  return;
          }
          else if(s.equals(Constant.Player.Human))
            AllZone.InputControl.setInput(inputComes);
          else //computer
          {
            Card target;
            //must target computer creature
            CardList computer = new CardList(AllZone.Computer_Play.getCards());
            computer = computer.getType("Elf");
            computer.remove(card);

            computer.shuffle();
            if (computer.size()!= 0) {
            	  target = computer.get(0);
            	  abilityComes.setTargetCard(target);
            	  AllZone.Stack.add(abilityComes);
            }
          }//else
        }//execute()
      };//CommandComes
      Command commandLeavesPlay = new Command()
      {

		private static final long serialVersionUID = -5903638227914705191L;

		public void execute()
        {
          //System.out.println(abilityComes.getTargetCard().getName());
          Object o = abilityComes.getTargetCard();
          
          if(o == null || ((Card)o).isToken()|| !AllZone.GameAction.isCardRemovedFromGame((Card)o) )
            return;

          SpellAbility ability = new Ability(card, "0")
          {
            public void resolve()
            {
              //copy card to reset card attributes like attack and defense
              Card c = abilityComes.getTargetCard();
              if(! c.isToken())
              {
                c = AllZone.CardFactory.copyCard(c);
                c.setController(c.getOwner());

                PlayerZone play = AllZone.getZone(Constant.Zone.Play, c.getOwner());
                PlayerZone removed = AllZone.getZone(Constant.Zone.Removed_From_Play, c.getOwner());
                removed.remove(c);
                play.add(c);
                
              }
            }//resolve()
          };//SpellAbility
          ability.setStackDescription(card.getName() + " - returning creature to play");
          AllZone.Stack.add(ability);
        }//execute()
      };//Command
      
      
      final SpellAbility a1 = new Ability(card, "2 G")
      {
    	public boolean canPlayAI()
    	{
    		return MyRandom.random.nextBoolean();
    	}
    	public boolean canPlay()
    	{
    		SpellAbility sa;
            //this is a hack, check the stack to see if this card has an ability on the stack
            //if so, we can't use the ability
            for (int i=0; i<AllZone.Stack.size(); i++)
            {
            	sa = AllZone.Stack.peek(i);
            	if (sa.getSourceCard().equals(card))
            			return false;
            }
            return AllZone.GameAction.isCardInPlay(card);
    		
    	}
        public void resolve()
        {
          makeToken();
        }
        void makeToken()
        {
          Card c = new Card();

          c.setName("Wolf");
          c.setImageName("G 2 2 Wolf");

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setManaCost("G");
          c.setToken(true);
         
          c.addType("Creature");
          c.addType("Wolf");
          c.setBaseAttack(2);
          c.setBaseDefense(2);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//makeToken()
      };//SpellAbility
      
      a1.setDescription("2 G: Put a 2/2 green Wolf creature token into play.");
      a1.setStackDescription("Put a 2/2 Wolf into play.");
      
      card.clearSpellAbility();
      
      card.addComesIntoPlayCommand(commandComes);
      card.addLeavesPlayCommand(commandLeavesPlay);
      
      

      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = 2583297503017070549L;

		public boolean canPlayAI()
        {
          Object o = getCreature.execute();
          if (o == null)
        	  return false;
          
          CardList cl = (CardList)getCreature.execute();
          return (o != null) && cl.size() > 0 && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });
      
      card.addSpellAbility(a1);
      a1.setBeforePayMana(new Input_PayManaCost(a1));
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    if(cardName.equals("Changeling Berserker") || cardName.equals("Changeling Hero") || cardName.equals("Changeling Titan"))
    {
      final CommandReturn getCreature = new CommandReturn()
      {
        public Object execute()
        {
          //get all creatures
          CardList list = new CardList();
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          list.addAll(play.getCards());
          
          list = list.filter(new CardListFilter(){
			public boolean addCard(Card c) {
				return c.getType().contains("Creature");
			}
          });

          return list;
        }
      };//CommandReturn

      final SpellAbility abilityComes = new Ability(card, "0")
      {
        public void resolve()
        {
          if (getTargetCard() == null || getTargetCard() == card)
        	  AllZone.GameAction.sacrifice(card);
          
          else if(AllZone.GameAction.isCardInPlay(getTargetCard()) )
          {
        	/*
            PlayerZone play = AllZone.getZone(getTargetCard());
            PlayerZone removed = AllZone.getZone(Constant.Zone.Removed_From_Play, getTargetCard().getController());
            play.remove(getTargetCard());
            removed.add(getTargetCard());
            */
        	AllZone.GameAction.removeFromGame(getTargetCard());  
          }
        }//resolve()
      };

      final Input inputComes = new Input()
      {

		private static final long serialVersionUID = 5210700665533271691L;

		public void showMessage()
        {
          CardList choice = (CardList)getCreature.execute();

          stopSetNext(CardFactoryUtil.input_targetSpecific(abilityComes, choice, "Select creature to remove from the game", false));
          ButtonUtil.disableAll(); 
        }
      };
      Command commandComes = new Command()
      {

		private static final long serialVersionUID = -3580408066322945328L;

		public void execute()
        {
          CardList creature = (CardList)getCreature.execute();
          String s = card.getController();
          if(creature.size() == 0) {
        	  AllZone.GameAction.sacrifice(card);
        	  return;
          }
          else if(s.equals(Constant.Player.Human))
            AllZone.InputControl.setInput(inputComes);
          else //computer
          {
            Card target;
            //must target computer creature
            CardList computer = new CardList(AllZone.Computer_Play.getCards());
            computer = computer.getType("Creature");
            computer.remove(card);

            computer.shuffle();
            if (computer.size()!= 0) {
            	  target = computer.get(0);
            	  abilityComes.setTargetCard(target);
            	  AllZone.Stack.add(abilityComes);
            }
          }//else
        }//execute()
      };//CommandComes
      Command commandLeavesPlay = new Command()
      {

		private static final long serialVersionUID = -5903638227914705191L;

		public void execute()
        {
          //System.out.println(abilityComes.getTargetCard().getName());
          Object o = abilityComes.getTargetCard();
          
          if(o == null || ((Card)o).isToken()|| !AllZone.GameAction.isCardRemovedFromGame((Card)o) )
            return;

          SpellAbility ability = new Ability(card, "0")
          {
            public void resolve()
            {
              //copy card to reset card attributes like attack and defense
              Card c = abilityComes.getTargetCard();
              if(! c.isToken())
              {
                c = AllZone.CardFactory.copyCard(c);
                c.setController(c.getOwner());

                PlayerZone play = AllZone.getZone(Constant.Zone.Play, c.getOwner());
                PlayerZone removed = AllZone.getZone(Constant.Zone.Removed_From_Play, c.getOwner());
                removed.remove(c);
                play.add(c);
                
              }
            }//resolve()
          };//SpellAbility
          ability.setStackDescription(card.getName() + " - returning creature to play");
          AllZone.Stack.add(ability);
        }//execute()
      };//Command

      card.addComesIntoPlayCommand(commandComes);
      card.addLeavesPlayCommand(commandLeavesPlay);
      
      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {

		private static final long serialVersionUID = 2583297503017070549L;

		public boolean canPlayAI()
        {
          Object o = getCreature.execute();
          if (o == null)
        	  return false;
          
          CardList cl = (CardList)getCreature.execute();
          return (o != null) && cl.size() > 0 && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    if(cardName.equals("Devout Lightcaster"))
    {
      final CommandReturn getBlackPerm = new CommandReturn()
      {
        public Object execute()
        {
          //get all creatures
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.filter(new CardListFilter(){
			public boolean addCard(Card c) {
				return c.isPermanent() && CardFactoryUtil.canTarget(card,c) && CardUtil.getColor(c).equals(Constant.Color.Black);
			}
          });

          return list;
        }
      };//CommandReturn

      final SpellAbility abilityComes = new Ability(card, "0")
      {
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card,getTargetCard()) )
          {

        	AllZone.GameAction.removeFromGame(getTargetCard());  
          }
        }//resolve()
      };

      final Input inputComes = new Input()
      {
		private static final long serialVersionUID = 3762167908738465100L;

		public void showMessage()
        {
          CardList choice = (CardList)getBlackPerm.execute();

          stopSetNext(CardFactoryUtil.input_targetSpecific(abilityComes, choice, "Select target black permanent to remove from the game", true));
          ButtonUtil.disableAll();//to disable the Cancel button
        }
      };
      Command commandComes = new Command()
      {
	
		private static final long serialVersionUID = 3878683618127503416L;

		public void execute()
        {
          CardList creature = (CardList)getBlackPerm.execute();
          String s = card.getController();
          if(creature.size() == 0)
            return;
          else if(s.equals(Constant.Player.Human))
            AllZone.InputControl.setInput(inputComes);
          else //computer
          {
            Card target;

            //try to target human permanent
            PlayerZone hum = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
            CardList human = new CardList(hum.getCards());
            human = human.filter(new CardListFilter()
            {
				public boolean addCard(Card c) {
					return c.isPermanent() && CardUtil.getColor(c).equals(Constant.Color.Black);
				}
            	
            });
            //target = CardFactoryUtil.AI_getBestCreature(human);//returns null if list is empty
            human.shuffle();
            target = null;
            if (human.size()!=0)
            	target = human.get(0);

            if(target == null)
            {
              //must target computer creature
              CardList computer = new CardList(AllZone.Computer_Play.getCards());
              computer = computer.filter(new CardListFilter()
              {
				public boolean addCard(Card c) {
					return c.isPermanent() && CardUtil.getColor(c).equals(Constant.Color.Black);
				}
            	  
              });

              computer.shuffle();
              if (computer.size()!= 0)
            	  target = computer.get(0);
            }
            abilityComes.setTargetCard(target);
            AllZone.Stack.add(abilityComes);
          }//else
        }//execute()
      };//CommandComes
      
      card.addComesIntoPlayCommand(commandComes);
      
      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {

		private static final long serialVersionUID = -9059177006257139430L;

		public boolean canPlayAI()
        {
          Object o = getBlackPerm.execute();
          if (o == null)
        	  return false;
          
          CardList cl = (CardList)getBlackPerm.execute();
          return (o != null) && cl.size() > 0 && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });
    }//*************** END ************ END **************************
    

    //*************** START *********** START **************************
    if(cardName.equals("Faceless Butcher"))
    {
      final CommandReturn getCreature = new CommandReturn()
      {
        public Object execute()
        {
          //get all creatures
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.filter(new CardListFilter(){
			public boolean addCard(Card c) {
				return c.isCreature() && CardFactoryUtil.canTarget(card,c);
			}
          });
          
          //remove "this card"
          list.remove(card);

          return list;
        }
      };//CommandReturn

      final SpellAbility abilityComes = new Ability(card, "0")
      {
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card,getTargetCard()) )
          {
        	/*
            PlayerZone play = AllZone.getZone(getTargetCard());
            PlayerZone removed = AllZone.getZone(Constant.Zone.Removed_From_Play, getTargetCard().getController());
            play.remove(getTargetCard());
            removed.add(getTargetCard());
            */
        	AllZone.GameAction.removeFromGame(getTargetCard());  
          }
        }//resolve()
      };

      final Input inputComes = new Input()
      {
		private static final long serialVersionUID = -1932054059769056049L;

		public void showMessage()
        {
          CardList choice = (CardList)getCreature.execute();

          stopSetNext(CardFactoryUtil.input_targetSpecific(abilityComes, choice, "Select target creature to remove from the game", true));
          ButtonUtil.disableAll();//to disable the Cancel button
        }
      };
      Command commandComes = new Command()
      {
		private static final long serialVersionUID = -5675532512302863456L;

		public void execute()
        {
          CardList creature = (CardList)getCreature.execute();
          String s = card.getController();
          if(creature.size() == 0)
            return;
          else if(s.equals(Constant.Player.Human))
            AllZone.InputControl.setInput(inputComes);
          else //computer
          {
            Card target;

            //try to target human creature
            CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
            target = CardFactoryUtil.AI_getBestCreature(human);//returns null if list is empty

            if(target == null)
            {
              //must target computer creature
              CardList computer = new CardList(AllZone.Computer_Play.getCards());
              computer = computer.getType("Creature");
              computer.remove(card);

              computer.shuffle();
              if (computer.size()!= 0)
            	  target = computer.get(0);
            }
            abilityComes.setTargetCard(target);
            AllZone.Stack.add(abilityComes);
          }//else
        }//execute()
      };//CommandComes
      Command commandLeavesPlay = new Command()
      {
		private static final long serialVersionUID = 5518706316791622193L;

		public void execute()
        {
          //System.out.println(abilityComes.getTargetCard().getName());
          Object o = abilityComes.getTargetCard();
          
          if(o == null || ((Card)o).isToken()|| !AllZone.GameAction.isCardRemovedFromGame((Card)o) )
            return;

          SpellAbility ability = new Ability(card, "0")
          {
            public void resolve()
            {
              //copy card to reset card attributes like attack and defense
              Card c = abilityComes.getTargetCard();
              if(! c.isToken())
              {
                c = AllZone.CardFactory.copyCard(c);
                c.setController(c.getOwner());

                PlayerZone play = AllZone.getZone(Constant.Zone.Play, c.getOwner());
                PlayerZone removed = AllZone.getZone(Constant.Zone.Removed_From_Play, c.getOwner());
                removed.remove(c);
                play.add(c);
                
              }
            }//resolve()
          };//SpellAbility
          ability.setStackDescription("Faceless Butcher - returning creature to play");
          AllZone.Stack.add(ability);
        }//execute()
      };//Command

      card.addComesIntoPlayCommand(commandComes);
      card.addLeavesPlayCommand(commandLeavesPlay);
      
      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {

		private static final long serialVersionUID = -62128538015338896L;

		public boolean canPlayAI()
        {
          Object o = getCreature.execute();
          if (o == null)
        	  return false;
          
          CardList cl = (CardList)getCreature.execute();
          return (o != null) && cl.size() > 0 && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });
    }//*************** END ************ END **************************

    
  //*************** START *********** START **************************
    if(cardName.equals("Oblivion Ring"))
    {
      final CommandReturn getPerm = new CommandReturn()
      {
        public Object execute()
        {
          //get all creatures
          CardList tempList = new CardList();
          tempList.addAll(AllZone.Human_Play.getCards());
          tempList.addAll(AllZone.Computer_Play.getCards());
          
          CardList list = new CardList();
          
          for(int i=0;i < tempList.size(); i++)
          {
        	  if(tempList.get(i).isPermanent() && !tempList.get(i).isLand() && CardFactoryUtil.canTarget(card, tempList.get(i)) )
        		  list.add(tempList.get(i));
          }

          //remove "this card"
          list.remove(card);

          return list;
        }
      };//CommandReturn

      final SpellAbility abilityComes = new Ability(card, "0")
      {
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card,getTargetCard()) )
          {
            AllZone.GameAction.removeFromGame(getTargetCard());
          }
        }//resolve()
      };

      final Input inputComes = new Input()
      {
		private static final long serialVersionUID = -3613946694360326887L;

		public void showMessage()
        {
          CardList choice = (CardList)getPerm.execute();

          stopSetNext(CardFactoryUtil.input_targetSpecific(abilityComes, choice, "Select target permanent to remove from the game", true));
          ButtonUtil.disableAll();//to disable the Cancel button
        }
      };
      Command commandComes = new Command()
      {
		private static final long serialVersionUID = -6250376920501373535L;

		public void execute()
        {
          CardList perm = (CardList)getPerm.execute();
          String s = card.getController();
          if(perm.size() == 0)
            return;
          else if(s.equals(Constant.Player.Human))
            AllZone.InputControl.setInput(inputComes);
          else //computer
          {
            Card target;

            //try to target human creature
            CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
            target = CardFactoryUtil.AI_getBestCreature(human);//returns null if list is empty
            
            // try to target human permanent
            if (target == null)
            {
            	int convertedCost = 0;
            	CardList tempList = new CardList();
                tempList.addAll(AllZone.Human_Play.getCards());
                
                @SuppressWarnings("unused") // list
				CardList list = new CardList();
                for (int i=0;i<tempList.size();i++)
                {
                	if(tempList.get(i).isPermanent() && !tempList.get(i).isLand() && CardFactoryUtil.canTarget(card, tempList.get(i)) &&
                	   (CardUtil.getConvertedManaCost(tempList.get(i).getManaCost()) > convertedCost))
                	{
                		target = tempList.get(i);
                		convertedCost = CardUtil.getConvertedManaCost(tempList.get(i).getManaCost());
                	}
                }
            }
            
            //target something cheaper (manacost 0?) instead:
            if (target == null)
            {
            	CardList humanPerms = new CardList();
            	humanPerms.addAll(AllZone.Human_Play.getCards());
            	humanPerms = humanPerms.filter(new CardListFilter() {
					public boolean addCard(Card c) {
						return c.isPermanent() && !c.isLand() && CardFactoryUtil.canTarget(card, c);
					}
            	});
            	
            	if (humanPerms.size()>0)
            		target = humanPerms.get(0);
            }

            if(target == null)
            {
              //must target computer creature
              CardList computer = new CardList(AllZone.Computer_Play.getCards());
              computer = computer.getType("Creature");
              computer.remove(card);

              computer.shuffle();
              if (computer.size() != 0)
            	  target = computer.get(0);
              else
            	  target = card;
            }
            abilityComes.setTargetCard(target);
            AllZone.Stack.add(abilityComes);
          }//else
        }//execute()
      };//CommandComes
      Command commandLeavesPlay = new Command()
      {
		private static final long serialVersionUID = 6997038208952910355L;

		public void execute()
        {
          Object o = abilityComes.getTargetCard();
          if(o == null || ((Card)o).isToken() || !AllZone.GameAction.isCardRemovedFromGame((Card)o) )
            return;

          SpellAbility ability = new Ability(card, "0")
          {
            public void resolve()
            {
              //copy card to reset card attributes like attack and defense
              Card c = abilityComes.getTargetCard();
              if(! c.isToken())
              {
                c = AllZone.CardFactory.copyCard(c);
                c.setController(c.getOwner());

                PlayerZone play = AllZone.getZone(Constant.Zone.Play, c.getOwner());
                play.add(c);
              }
            }//resolve()
          };//SpellAbility
          ability.setStackDescription("Oblivion Ring - returning permanent to play.");
          AllZone.Stack.add(ability);
        }//execute()
      };//Command

      card.addComesIntoPlayCommand(commandComes);
      card.addLeavesPlayCommand(commandLeavesPlay);
      
      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = -3250095291930182087L;

		public boolean canPlayAI()
        {
          Object o = getPerm.execute();
          if (o == null)
        	  return false;
          
          CardList cl = (CardList)getPerm.execute();
          return (o != null) && cl.size() > 0 && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });

    }//*************** END ************ END **************************



  /*
  //*************** START *********** START **************************
    else if(cardName.equals("Oblivion Ring"))
    {
      final SpellAbility enchantment = new Spell(card)
      {
    	public void resolve()
    	{
    	  if(AllZone.GameAction.isCardInPlay(getTargetCard()))
    	  {
    		PlayerZone play = AllZone.getZone(getTargetCard());
    		play.remove(getTargetCard());

    		//put permanent into play
    		Card c = getSourceCard();
    		AllZone.getZone(Constant.Zone.Play, c.getController()).add(c);
    	  }
    	}//resolve()

    	public boolean canPlayAI()
    	{
    	  //try to target human creature
    	  CardList human = CardFactoryUtil.AI_getHumanCreature();
    	  Card target = CardFactoryUtil.AI_getBestCreature(human);//returns null if list is empty

    	  if(target == null)
    		return false;
    	  else
    	  {
    		setTargetCard(target);
    		return true;
    	  }
    	}//canPlayAI()
      };//SpellAbility enchantment


      final Input target = new Input()
      {
    	//showMessage() is always the first method called
    	public void showMessage()
    	{
    	  AllZone.Display.showMessage("Select non-land to remove from the game.");
    	  ButtonUtil.enableOnlyCancel();
    	}
    	public void selectButtonCancel() {stop();}

    	public void selectCard(Card c, PlayerZone zone)
    	{
    	  if(zone.is(Constant.Zone.Play) && !c.isLand())
    	  {
    		enchantment.setTargetCard(c);

    		stopSetNext(new Input_PayManaCost(enchantment));
    	  }
    	}
      };//Input target

      Command commandDestroy = new Command()
      {
    	public void execute()
    	{
    	  Object o = enchantment.getTargetCard();
    	  if(o == null || ((Card)o).isToken())
    		return;

    	  SpellAbility ability = new Ability(card, "0")
    	  {
    		public void resolve()
    		{
    		  //copy card to reset card attributes like attack and defense
    		  Card c = enchantment.getTargetCard();
    		  if(! c.isToken())
    		  {
    			c = AllZone.CardFactory.copyCard(c);
    			c.setController(c.getOwner());

    			PlayerZone play = AllZone.getZone(Constant.Zone.Play, c.getOwner());
    			play.add(c);
    		  }
    		}//resolve()
    	  };//SpellAbility
    	  ability.setStackDescription(card.getName() +" - returning creature to play");
    	  AllZone.Stack.add(ability);
    	}//execute()
      };//Command
      card.setDestroy(commandDestroy);

      card.clearSpellAbility();
      card.addSpellAbility(enchantment);

      enchantment.setBeforePayMana(target);
    }//*************** END ************ END **************************

	*/

    //*************** START *********** START **************************
    else if(cardName.equals("Oubliette"))
    {
      final SpellAbility enchantment = new Spell(card)
      {
		private static final long serialVersionUID = -6751177094537759827L;

		public void resolve()
    	{
    	  if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card,getTargetCard()))
    	  {
    		AllZone.GameAction.removeFromGame(getTargetCard());

    		//put permanent into play
    		Card c = getSourceCard();
    		AllZone.getZone(Constant.Zone.Play, c.getController()).add(c);
    	  }
    	}//resolve()

    	public boolean canPlayAI()
    	{
    	  //try to target human creature
    	  CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
    	  Card target = CardFactoryUtil.AI_getBestCreature(human);//returns null if list is empty

    	  if(target == null)
    		return false;
    	  else
    	  {
    		setTargetCard(target);
    		return true;
    	  }
    	}//canPlayAI()
      };//SpellAbility enchantment


      @SuppressWarnings("unused") // target
	final Input target = new Input()
      {
		private static final long serialVersionUID = -251660220889858176L;

		//showMessage() is always the first method called
    	public void showMessage()
    	{
    	  AllZone.Display.showMessage("Select creature to remove from the game (sorry no phasing yet).");
    	  ButtonUtil.enableOnlyCancel();
    	}
    	public void selectButtonCancel() {stop();}

    	public void selectCard(Card c, PlayerZone zone)
    	{
    	  if(!CardFactoryUtil.canTarget(enchantment, c)){
          	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }	
    	  else if(zone.is(Constant.Zone.Play) && c.isCreature())
    	  {
    		enchantment.setTargetCard(c);

    		stopSetNext(new Input_PayManaCost(enchantment));
    	  }
    	}
      };//Input target

      Command commandLeavesPlay = new Command()
      {
		private static final long serialVersionUID = -2535098005246027777L;

		public void execute()
    	{
    	  Object o = enchantment.getTargetCard();
    	  if(o == null || ((Card)o).isToken() || !AllZone.GameAction.isCardRemovedFromGame((Card)o) )
    		return;

    	  SpellAbility ability = new Ability(card, "0")
    	  {
    		public void resolve()
    		{
    		  //copy card to reset card attributes like attack and defense
    		  Card c = enchantment.getTargetCard();
    		  if(! c.isToken())
    		  {
    			c = AllZone.CardFactory.copyCard(c);
    			c.setController(c.getOwner());

    			PlayerZone play = AllZone.getZone(Constant.Zone.Play, c.getOwner());
    			play.add(c);
    		  }
    		}//resolve()
    	  };//SpellAbility
    	  ability.setStackDescription(card.getName() +" - returning creature to play");
    	  AllZone.Stack.add(ability);
    	}//execute()
      };//Command
      card.addLeavesPlayCommand(commandLeavesPlay);

      card.clearSpellAbility();
      card.addSpellAbility(enchantment);

      enchantment.setBeforePayMana(CardFactoryUtil.input_targetCreature(enchantment));
    }//*************** END ************ END **************************






    //*************** START *********** START **************************
    if(cardName.equals("Test Destroy"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 6637283804612570910L;
		
		public boolean canPlayAI() {return false;}
		
        public void resolve()
        {
          AllZone.GameAction.destroy(getTargetCard());
        }//resolve()
      };

      card.clearSpellAbility();
      spell.setBeforePayMana(CardFactoryUtil.input_targetType(spell, "All"));
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Take Possession"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -7359291736123492910L;

		public boolean canPlayAI() {return 0 < CardFactoryUtil.AI_getHumanCreature(card, true).size();}

        public void chooseTargetAI()
        {
          Card best = CardFactoryUtil.AI_getBestCreature(CardFactoryUtil.AI_getHumanCreature(card, true));
          setTargetCard(best);
        }

        public void resolve()
        {
          Card c = getTargetCard();
          c.setController(card.getController());

          ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
          ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);

          PlayerZone from = AllZone.getZone(c);
          PlayerZone to = AllZone.getZone(Constant.Zone.Play, card.getController());

          from.remove(c);
          to.add(c);

          ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
          ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);

        }//resolve()
      };

      card.clearSpellAbility();
      spell.setBeforePayMana(CardFactoryUtil.input_targetType(spell, "All"));
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Night's Whisper"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -8594340516961923197L;
		
		public boolean canPlayAI()
        {
          return AllZone.Computer_Life.getLife()>2;
        }
        public void resolve()
        {
          //draw 2 cards, subtract 2 life
          String player = card.getController();
          AllZone.GameAction.drawCard(player);
          AllZone.GameAction.drawCard(player);

          AllZone.GameAction.getPlayerLife(player).subtractLife(2);
        }//resolve()
      };

      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Infest"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -4970294125917784048L;

		public boolean canPlayAI()
        {
          CardList human    = new CardList(AllZone.Human_Play.getCards());
          CardList computer = new CardList(AllZone.Computer_Play.getCards());

          human    = human.getType("Creature");
          computer = computer.getType("Creature");

          human = CardListUtil.filterToughness(human, 2);
          computer = CardListUtil.filterToughness(computer, 2);

          //the computer will at least destroy 2 more human creatures
          return computer.size() < human.size()-1;
        }//canPlayAI()

        public void resolve()
        {
          //get all creatures
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.getType("Creature");

          for(int i = 0; i < list.size(); i++)
            list.get(i).addDamage(2);
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Ember-Fist Zubera"))
    {
      //counts Zubera in all graveyards for this turn
      final CommandReturn countZubera = new CommandReturn()
      {
        public Object execute()
        {
          CardList list = new CardList();
          list.addAll(AllZone.Human_Graveyard.getCards());
          list.addAll(AllZone.Computer_Graveyard.getCards());

          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (c.getTurnInZone() == AllZone.Phase.getTurn()) &&
                      (c.getType().contains("Zubera") || c.getKeyword().contains("Changeling") );
            }
          });//CardListFilter()

          return new Integer(list.size());
        }
      };

      final Input[] input = new Input[1];

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          //human chooses target on resolve,
          //computer chooses target in Command destroy
          if(Constant.Player.Human.equals(card.getController()))
             AllZone.InputControl.setInput(input[0]);
          else
          {
            int damage = ((Integer)countZubera.execute()).intValue();

            if(getTargetCard() != null)
            {
              if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canDamage(card, getTargetCard()) 
                 && CardFactoryUtil.canTarget(card,getTargetCard()) )
              {
                Card c = getTargetCard();
                c.addDamage(damage);
              }
            }
            else
              AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(damage);
          }
        }//resolve()
      };//SpellAbility

      input[0] = new Input()
      {
		private static final long serialVersionUID = 1899925898843297992L;
		
		public void showMessage()
        {
          int damage = ((Integer)countZubera.execute()).intValue();
          AllZone.Display.showMessage("Select target Creature, Planeswalker or Player - " + damage +" damage ");
          ButtonUtil.disableAll();
        }
        public void selectCard(Card card, PlayerZone zone)
        {
          if((card.isCreature() || card.isPlaneswalker()) && zone.is(Constant.Zone.Play))
          {
            int damage = ((Integer)countZubera.execute()).intValue();
            card.addDamage(damage);

            //have to do this since state effects aren't checked
            //after this "Input" class is done
            //basically this makes everything work right
            //Ember-Fist Zubera can destroy a 2/2 creature
            AllZone.GameAction.checkStateEffects();
            stop();
          }
        }//selectCard()
        public void selectPlayer(String player)
        {
          int damage = ((Integer)countZubera.execute()).intValue();
          AllZone.GameAction.getPlayerLife(player).subtractLife(damage);
          stop();
        }//selectPlayer()
      };//Input

      Command destroy = new Command()
      {
 		private static final long serialVersionUID = -1889425992069348304L;

		public void execute()
        {
          ability.setStackDescription(card +" causes damage to creature or player");

          @SuppressWarnings("unused") // damage
		  int damage = ((Integer)countZubera.execute()).intValue();

          String con = card.getController();

          //human chooses target on resolve,
          //computer chooses target in Command destroy
          if(con.equals(Constant.Player.Computer))
            ability.setTargetPlayer(Constant.Player.Human);

          AllZone.Stack.add(ability);
        }//execute()
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Ashen-Skin Zubera"))
    {
      //counts Zubera in all graveyards for this turn
      final CommandReturn countZubera = new CommandReturn()
      {
        public Object execute()
        {
          CardList list = new CardList();
          list.addAll(AllZone.Human_Graveyard.getCards());
          list.addAll(AllZone.Computer_Graveyard.getCards());

          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (c.getTurnInZone() == AllZone.Phase.getTurn()) &&
                      (c.getType().contains("Zubera") || c.getKeyword().contains("Changeling") );
            }
          });//CardListFilter()
          return new Integer(list.size());
        }
      };//CommandReturn

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          int discard = ((Integer)countZubera.execute()).intValue();

          if(Constant.Player.Human.equals(getTargetPlayer()))
            AllZone.InputControl.setInput(CardFactoryUtil.input_discard(discard));
          else
          {
            for(int i = 0; i < discard; i++)
              AllZone.GameAction.discardRandom(Constant.Player.Computer);
          }
        }//resolve()
      };//SpellAbility

      Command destroy = new Command()
      {
		private static final long serialVersionUID = -7494691537986218546L;

		public void execute()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          ability.setTargetPlayer(opponent);
          ability.setStackDescription(card +" - " + opponent +" discards cards");

          AllZone.Stack.add(ability);
        }//execute()
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Floating-Dream Zubera"))
    {
      //counts Zubera in all graveyards for this turn
      final CommandReturn countZubera = new CommandReturn()
      {
        public Object execute()
        {
          CardList list = new CardList();
          list.addAll(AllZone.Human_Graveyard.getCards());
          list.addAll(AllZone.Computer_Graveyard.getCards());

          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (c.getTurnInZone() == AllZone.Phase.getTurn()) &&
                      (c.getType().contains("Zubera") || c.getKeyword().contains("Changeling") );
            }
          });//CardListFilter()
          return new Integer(list.size());
        }
      };//CommandReturn

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          int number = ((Integer)countZubera.execute()).intValue();

          for(int i = 0; i < number; i++)
            AllZone.GameAction.drawCard(getTargetPlayer());
        }//resolve()
      };//SpellAbility

      Command destroy = new Command()
      {
		private static final long serialVersionUID = -5814070329854975419L;

		public void execute()
        {
          ability.setTargetPlayer(card.getController());
          ability.setStackDescription(card +" - " +card.getController() +" draws cards");
          AllZone.Stack.add(ability);

        }//execute()
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Silent-Chant Zubera"))
    {
      //counts Zubera in all graveyards for this turn
      final CommandReturn countZubera = new CommandReturn()
      {
        public Object execute()
        {
          CardList list = new CardList();
          list.addAll(AllZone.Human_Graveyard.getCards());
          list.addAll(AllZone.Computer_Graveyard.getCards());

          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (c.getTurnInZone() == AllZone.Phase.getTurn()) &&
                      (c.getType().contains("Zubera") || c.getKeyword().contains("Changeling") );
            }
          });//CardListFilter()
          return new Integer(list.size());
        }
      };//CommandReturn

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          int number = ((Integer)countZubera.execute()).intValue();

          PlayerLife life = AllZone.GameAction.getPlayerLife(getTargetPlayer());
          life.addLife(number * 2);
        }//resolve()
      };//SpellAbility

      Command destroy = new Command()
      {
		private static final long serialVersionUID = -2327085948421343657L;

		public void execute()
        {
          ability.setTargetPlayer(card.getController());
          ability.setStackDescription(card +" - " +card.getController() +" gains life");
          AllZone.Stack.add(ability);

        }//execute()
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Dripping-Tongue Zubera"))
    {
      //counts Zubera in all graveyards for this turn
      final CommandReturn countZubera = new CommandReturn()
      {
        public Object execute()
        {
          CardList list = new CardList();
          list.addAll(AllZone.Human_Graveyard.getCards());
          list.addAll(AllZone.Computer_Graveyard.getCards());

          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (c.getTurnInZone() == AllZone.Phase.getTurn()) &&
                      (c.getType().contains("Zubera") || c.getKeyword().contains("Changeling") );
            }
          });//CardListFilter()
          return new Integer(list.size());
        }
      };//CommandReturn

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          int count = ((Integer)countZubera.execute()).intValue();
          for(int i = 0; i < count; i++)
            makeToken();
        }//resolve()
        void makeToken()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Spirit");
          c.setImageName("C 1 1 Spirit");
          c.setManaCost("");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Spirit");
          c.setBaseAttack(1);
          c.setBaseDefense(1);

          play.add(c);
        }//makeToken()

      };//SpellAbility

      Command destroy = new Command()
      {
		private static final long serialVersionUID = 8362692868619919330L;
        public void execute()
        {
          ability.setTargetPlayer(card.getController());
          ability.setStackDescription(card +" - " +card.getController() +" puts tokens into play");
          AllZone.Stack.add(ability);
        }//execute()
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Keiga, the Tide Star"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
            PlayerZone oldPlay = AllZone.getZone(getTargetCard());

            //so "comes into play" abilities don't trigger
            //getTargetCard().addComesIntoPlayCommand(Command.Blank);

            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
	        ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);
            
            play.add(getTargetCard());
            oldPlay.remove(getTargetCard());

            getTargetCard().setController(card.getController());
            
            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
	        ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
          }
        }//resolve()
      };

      final Input targetInput = new Input()
      {
		private static final long serialVersionUID = -8727869672234802473L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target creature");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          if(!CardFactoryUtil.canTarget(card, c)){
          	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }
          else if(c.isCreature() && zone.is(Constant.Zone.Play))
          {
            ability.setTargetCard(c);
            ability.setStackDescription("Gain control of " +ability.getTargetCard());
            AllZone.Stack.add(ability);
            stop();
          }
        }
      };//Input
      Command destroy = new Command()
      {
		private static final long serialVersionUID = -3868616119471172026L;

		public void execute()
        {
          String con = card.getController();
          CardList list = CardFactoryUtil.AI_getHumanCreature(card, true);

          if(con.equals(Constant.Player.Human))
            AllZone.InputControl.setInput(targetInput);
          else if(list.size() != 0)
          {
            Card target = CardFactoryUtil.AI_getBestCreature(list);
            ability.setTargetCard(target);
            AllZone.Stack.add(ability);
          }
        }//execute()
      };
      card.addDestroyCommand(destroy);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Angelic Blessing"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 6906094867912276636L;
		
		public void resolve()
        {
          final Command eot = new Command()
          {
			private static final long serialVersionUID = 4672991308703961180L;

			public void execute()
            {
              Card c = getTargetCard();
              if(AllZone.GameAction.isCardInPlay(c) )
              {
                c.addTempAttackBoost(-3);
                c.addTempDefenseBoost(-3);
                c.removeExtrinsicKeyword("Flying");
              }
            }//execute()
          };//Command

          Card c = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
          {
            c.addTempAttackBoost(3);
            c.addTempDefenseBoost(3);
            c.addExtrinsicKeyword("Flying");

            AllZone.EndOfTurn.addUntil(eot);
          }
        }//resolve()
        public boolean canPlayAI()
        {
          Combat combat = ComputerUtil.getAttackers();
          return (0 != combat.getAttackers().length);
        }
        public void chooseTargetAI()
        {
          Combat combat = ComputerUtil.getAttackers();
          Card[] attacker = combat.getAttackers();
          if(attacker.length != 0)
            setTargetCard(attacker[0]);
          else
          {
            CardList list = new CardList(AllZone.Computer_Play.getCards());
            list = list.getType("Creature");
            Card best = CardFactoryUtil.AI_getBestCreature(list);
            setTargetCard(best);
          }
        }//chooseTargetAI()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
    }//*************** END ************ END **************************


/*

    //*************** START *********** START **************************
    if(cardName.equals("Molten Rain"))
    {
      final SpellAbility spell = new Spell(card)
      {
        public boolean canPlayAI()
        {
          CardList land = new CardList(AllZone.Human_Play.getCards());
          land = land.getType("Basic");
          return land.size() != 0;
        }

        public void chooseTargetAI()
        {
          //target basic land that Human only has 1 or 2 in play
          CardList land = new CardList(AllZone.Human_Play.getCards());
          land = land.getType("Basic");

          Card target = null;

          String[] name = {"Forest", "Swamp", "Plains", "Mountain", "Island"};
          for(int i = 0; i < name.length; i++)
            if(land.getName(name[i]).size() == 1)
            {
              target = land.getName(name[i]).get(0);
              break;
            }

          //see if there are only 2 lands of the same type
          if(target == null)
          {
            for(int i = 0; i < name.length; i++)
              if(land.getName(name[i]).size() == 2)
              {
              target = land.getName(name[i]).get(0);
              break;
            }
          }//if
          if(target == null)
          {
            land.shuffle();
            target = land.get(0);
          }
          setTargetCard(target);
        }//chooseTargetAI()

        public void resolve()
        {
          Card c = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(c))
          {
            AllZone.GameAction.destroy(c);

            if(! c.getType().contains("Basic"))
              AllZone.GameAction.getPlayerLife(c.getController()).subtractLife(2);
          }
        }//resolve()

      };//Spell
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      Input target = new Input()
      {
        public void showMessage()
        {
          AllZone.Display.showMessage("Select target Land");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if(card.isLand() && zone.is(Constant.Zone.Play))
          {
            spell.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }//selectCard()
      };
      spell.setBeforePayMana(target);
    }//*************** END ************ END **************************

*/


//*************** START *********** START **************************
	if (cardName.equals("Molten Rain"))
	{
		final SpellAbility spell = new Spell(card)
		{
			private static final long serialVersionUID = 8855786097956610090L;

			public void resolve()
			{
				Card c = getTargetCard();
				if (AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, c)) {
					if(! c.getType().contains("Basic"))
			              AllZone.GameAction.getPlayerLife(c.getController()).subtractLife(2);
					AllZone.GameAction.destroy(c);
				}
				
			}// resolve()
	
		};// Spell
		card.clearSpellAbility();
		card.addSpellAbility(spell);
	
		spell.setChooseTargetAI(CardFactoryUtil.AI_targetType("Land", AllZone.Human_Play));
		spell.setBeforePayMana(CardFactoryUtil.input_targetType(spell,"Land"));
	}// *************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Elvish Piper"))
    {
      final SpellAbility ability = new Ability_Tap(card, "G")
      {
        private static final long serialVersionUID = 8788555124182810249L;

		public boolean canPlayAI() {return getCreature().size() != 0;}
        public void chooseTargetAI()
        {
          card.tap();
          Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
          setTargetCard(target);
        }
        CardList getCreature()
        {
          CardList list = new CardList(AllZone.Computer_Hand.getCards());
          list = list.getType("Creature");
          return list;
        }

        public void resolve()
        {
          Card c = getTargetCard();
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());

          if(AllZone.GameAction.isCardInZone(c, hand))
          {
            hand.remove(c);
            play.add(c);
          }
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("G, tap: Put a creature card from your hand into play.");

      final Command paid  = new Command()
      {
		private static final long serialVersionUID = 6859737530872573139L;
        public void execute()
        {
          AllZone.InputControl.resetInput();
          AllZone.Stack.add(ability);
        }
      };
      final Command unpaid = new Command()
      {
		private static final long serialVersionUID = -257927480355704167L;

		public void execute()
        {
            card.untap();
        }
      };
      final Input target = new Input()
      {
		private static final long serialVersionUID = -1041198540673942649L;
		
		public void showMessage()
        {
          ButtonUtil.enableOnlyCancel();
          AllZone.Display.showMessage("Select creature from your hand to put into play");
        }
        public void selectCard(Card c, PlayerZone zone)
        {
          if(c.isCreature() && zone.is(Constant.Zone.Hand, Constant.Player.Human))
          {
            card.tap();

            ability.setTargetCard(c);//since setTargetCard() changes stack description
            ability.setStackDescription("Put into play " +c);

            AllZone.InputControl.setInput(new Input_PayManaCost_Ability(ability.getManaCost(), paid, unpaid));
          }
        }
        public void selectButtonCancel()
        {
          card.untap();
          stop();
        }
      };//Input target
      ability.setBeforePayMana(target);
    }//*************** END ************ END **************************
    

    //*************** START *********** START **************************
    if(cardName.equals("Belbe's Portal"))
    {
      final SpellAbility ability = new Ability_Tap(card, "3")
      {
        private static final long serialVersionUID = 3790805878629855813L;

		public boolean canPlayAI() {return getCreature().size() != 0;}
        public void chooseTargetAI()
        {
          card.tap();
          Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
          setTargetCard(target);
        }
        CardList getCreature()
        {
          CardList list = new CardList(AllZone.Computer_Hand.getCards());
          list = list.getType(card.getChosenType());
          return list;
        }

        public void resolve()
        {
          Card c = getTargetCard();
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());

          if(AllZone.GameAction.isCardInZone(c, hand))
          {
            hand.remove(c);
            play.add(c);
          }
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("3, tap: Put a creature card of the chosen type from your hand into play.");

      final Command paid  = new Command()
      {
		private static final long serialVersionUID = 4258139342966165260L;

		public void execute()
        {
          AllZone.InputControl.resetInput();
          AllZone.Stack.add(ability);
        }
      };
      final Command unpaid = new Command()
      {
		private static final long serialVersionUID = 5792270994683837097L;

		public void execute()
        {
            card.untap();
        }
      };
      final Input target = new Input()
      {
		private static final long serialVersionUID = -3180364352114242238L;
		
		public void showMessage()
        {
          ButtonUtil.enableOnlyCancel();
          AllZone.Display.showMessage("Select creature from your hand to put into play");
        }
        public void selectCard(Card c, PlayerZone zone)
        {
          if(c.isCreature() && zone.is(Constant.Zone.Hand, Constant.Player.Human) && c.getType().contains(card.getChosenType()))
          {
            card.tap();

            ability.setTargetCard(c);//since setTargetCard() changes stack description
            ability.setStackDescription("Put into play " +c);

            AllZone.InputControl.setInput(new Input_PayManaCost_Ability(ability.getManaCost(), paid, unpaid));
          }
        }
        public void selectButtonCancel()
        {
          card.untap();
          stop();
        }
      };//Input target
      ability.setBeforePayMana(target);
    }//*************** END ************ END **************************
    
    
  

    //*************** START *********** START **************************
    if(cardName.equals("Weathered Wayfarer"))
    {
      final SpellAbility ability = new Ability_Tap(card, "W")
      {
		private static final long serialVersionUID = 2902408879239353813L;
		
		public void resolve()
        {
          //getTargetCard() will NEVER be null

          //checks to see if card is still in the library
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          if(AllZone.GameAction.isCardInZone(getTargetCard(), library))
          {
            PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
            AllZone.GameAction.moveTo(hand, getTargetCard());
          }
        }//resolve()
        public boolean canPlay()
        {
          String oppPlayer = AllZone.GameAction.getOpponent(card.getController());

          PlayerZone selfZone = AllZone.getZone(Constant.Zone.Play, card.getController());
          PlayerZone oppZone = AllZone.getZone(Constant.Zone.Play, oppPlayer);

          CardList self = new CardList(selfZone.getCards());
          CardList opp = new CardList(oppZone.getCards());

          self = self.getType("Land");
          opp = opp.getType("Land");

          //checks to see if any land in library
          PlayerZone selfLibrary = AllZone.getZone(Constant.Zone.Library, card.getController());
          CardList library = new CardList(selfLibrary.getCards());
          library = library.getType("Land");

          return (self.size() < opp.size()) && (library.size() != 0) && super.canPlay();
        }
       public void chooseTargetAI()
       {
         PlayerZone selfLibrary = AllZone.getZone(Constant.Zone.Library, card.getController());
         CardList library = new CardList(selfLibrary.getCards());
         library = library.getType("Land");

         setTargetCard(library.get(0));
       }
      };//SpellAbility

      Input target = new Input()
      {
        private static final long serialVersionUID = 3492362297282622857L;

		public void showMessage()
        {
          CardList land = new CardList(AllZone.Human_Library.getCards());
          land = land.getType("Land");
          Object o = AllZone.Display.getChoiceOptional("Select a Land", land.toArray());

          //techincally not correct, but correct enough
          //this allows players to look at their decks without paying anything
          if(o == null)
            stop();
          else
          {
            AllZone.GameAction.shuffle("Human");
            ability.setTargetCard((Card)o);
            stopSetNext(new Input_PayManaCost(ability));
          }
        }//showMessage()
      };//Input - target

      card.addSpellAbility(ability);
      ability.setDescription("W, tap: Search your library for a land card, reveal it, and put it into your hand. Then shuffle your library. Play this ability only if an opponent controls more lands than you.");
      ability.setBeforePayMana(target);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Disciple of Kangee"))
    {
      final SpellAbility ability = new Ability_Tap(card, "U")
      {
        private static final long serialVersionUID = -5169389637917649036L;
		public boolean canPlayAI()
        {
          if(CardFactoryUtil.AI_doesCreatureAttack(card))
            return false;

          return CardFactoryUtil.AI_getHumanCreature("Flying", card, false).isEmpty() &&
                 (getCreature().size() != 0);
        }
        public void chooseTargetAI()
        {
          card.tap();
          Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
          setTargetCard(target);
        }
        CardList getCreature()
        {
          CardList list = new CardList(AllZone.Computer_Play.getCards());
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isCreature() && (!CardFactoryUtil.AI_doesCreatureAttack(c)) &&
                     (! c.getKeyword().contains("Flying")) && CardFactoryUtil.canTarget(card, c);
            }
          });
          list.remove(card);
          return list;
        }//getCreature()
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            final Card[] creature = new Card[1];
            final Command EOT = new Command()
            {
				private static final long serialVersionUID = -1899153704584793548L;

			public void execute()
              {
                if(AllZone.GameAction.isCardInPlay(creature[0]))
                  creature[0].removeExtrinsicKeyword("Flying");
              }
            };
            creature[0] = getTargetCard();
            creature[0].addExtrinsicKeyword("Flying");
            AllZone.EndOfTurn.addUntil(EOT);
          }//if (card is in play)
        }//resolve()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("U, tap: Target creature gains flying.");

      ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Puppeteer"))
    {
      //tap - target creature
      final SpellAbility ability = new Ability_Tap(card, "U")
      {
        private static final long serialVersionUID = 7698358771800336470L;
		public boolean canPlayAI() {return getTapped().size() != 0;}
        public void chooseTargetAI()
        {
          card.tap();
          Card target = CardFactoryUtil.AI_getBestCreature(getTapped());
          setTargetCard(target);
        }
        CardList getTapped()
        {
          CardList list = new CardList(AllZone.Computer_Play.getCards());
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isCreature() && c.isTapped();
            }
          });
          return list;
        }//getTapped()
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            Card c = getTargetCard();
            if(c.isTapped())
              c.untap();
            else
              c.tap();
          }
        }//resolve()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("U, tap: Tap or untap target creature.");

      ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
    }//*************** END ************ END **************************



  //*************** START *********** START **************************
    if(cardName.equals("Sorceress Queen"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = -6853184726011448677L;
		public boolean canPlayAI()
        {
          Card c = getCreature();
          if(c == null)
            return false;
          else
          {
            setTargetCard(c);
            return true;
          }
        }//canPlayAI()
        //may return null
        public Card getCreature()
        {
          CardList untapped = CardFactoryUtil.AI_getHumanCreature(card, true);
          untapped = untapped.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isUntapped() && 2 < c.getNetDefense() && c != card;
            }
          });
          if(untapped.isEmpty())
            return null;

          Card big = CardFactoryUtil.AI_getBestCreature(untapped);
          return big;
        }
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            final Card[] creature = new Card[1];

            creature[0] = getTargetCard();
            final int[] originalAttack  = {creature[0].getBaseAttack()};
            final int[] originalDefense = {creature[0].getBaseDefense()};

            creature[0].setBaseAttack(0);
            creature[0].setBaseDefense(2);

            final Command EOT = new Command()
            {
				private static final long serialVersionUID = 6437463765161964445L;

			public void execute()
              {
                if(AllZone.GameAction.isCardInPlay(creature[0]))
                {
                  creature[0].setBaseAttack(originalAttack[0]);
                  creature[0].setBaseDefense(originalDefense[0]);
                }
              }
            };
            AllZone.EndOfTurn.addUntil(EOT);
          }//is card in play?
        }//resolve()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Target creature other than Sorceress Queen becomes 0/2 until end of turn.");
      //this ability can target "this card" when it shouldn't be able to
      ability.setBeforePayMana(CardFactoryUtil.input_targetCreature_NoCost_TapAbility_NoTargetSelf(ability));
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Immaculate Magistrate"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = 8976980151320100343L;
		public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            PlayerZone zone = AllZone.getZone(Constant.Zone.Play, card.getController());
            CardList list = new CardList(zone.getCards());
            int nElf = list.getType("Elf").size();

            Card c = getTargetCard();
            c.addCounter(Counters.P1P1, nElf);
            
          }//is card in play?
        }//resolve()
        public boolean canPlayAI()
        {
          CardList list = new CardList(AllZone.Computer_Play.getCards());
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isUntapped() && !c.equals(card) && c.isCreature();
            }
          });

          if(list.isEmpty())
            return false;

          list.shuffle();

          setTargetCard(list.get(0));
          return true;
        }//canPlayAI()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Put a +1/+1 counter on target creature for each Elf you control.");

      ability.setBeforePayMana(CardFactoryUtil.input_targetCreature_NoCost_TapAbility(ability));
    }//*************** END ************ END **************************

    /*
    //*************** START *********** START **************************
    if(cardName.equals("Prodigal Sorcerer") || cardName.equals("Prodigal Pyromancer") 
    	|| cardName.equals("Razorfin Hunter") || cardName.equals("Vulshok Sorcerer") 
    	|| cardName.equals("Viashino Fangtail") || cardName.equals("Jeska, Warrior Adept")) 
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = -7560349014757367722L;
		public void chooseTargetAI()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(1, card, true);
          list.shuffle();

          if(list.isEmpty() || AllZone.Human_Life.getLife() < 5)
            setTargetPlayer(Constant.Player.Human);
          else
            setTargetCard(list.get(0));
        }
        public void resolve()
        {
          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
              getTargetCard().addDamage(1);
          }
          else
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(1);
        }//resolve()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: " +card.getName() +" deals 1 damage to target creature or player.");

      ability.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(ability, true));

    }//*************** END ************ END **************************
    

    
    //*************** START *********** START **************************
    if (cardName.equals("Anaba Shaman"))
    {
    	final Ability_Tap ability = new Ability_Tap(card, "R")
        {
          private static final long serialVersionUID = -3954988810589187088L;
		public void chooseTargetAI()
          {
            CardList list = CardFactoryUtil.AI_getHumanCreature(1, card, true);
            list.shuffle();

            if(list.isEmpty() || AllZone.Human_Life.getLife() < 5)
              setTargetPlayer(Constant.Player.Human);
            else
              setTargetCard(list.get(0));
          }
          public void resolve()
          {
            if(getTargetCard() != null)
            {
              if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
                getTargetCard().addDamage(1);
            }
            else
              AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(1);
          }//resolve()
        };//SpellAbility
        card.addSpellAbility(ability);
        ability.setDescription("R, tap: " +card.getName() +" deals 1 damage to target creature or player.");

        ability.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(ability, true));
    	
    	
    }//*************** END ************ END **************************
    
       

    //*************** START *********** START **************************
    if(cardName.equals("Kamahl, Pit Fighter"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = 6922727343642792543L;
		public boolean canPlayAI()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(card, true);

          boolean b = true;

          //use ability only if no human creatures can block
          for(int i = 0; i < list.size(); i++)
            if(list.get(i).isUntapped())
              b = false;

          return b || AllZone.Phase.getPhase().equals(Constant.Phase.Main2);
        }

        public void chooseTargetAI()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(3, card, true);
          list.shuffle();

          if(list.isEmpty() || AllZone.Human_Life.getLife() < 17)
            setTargetPlayer(Constant.Player.Human);
          else
            setTargetCard(list.get(0));
        }
        public void resolve()
        {
          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
              getTargetCard().addDamage(3);
          }
          else
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(3);
        }//resolve()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: " +card.getName() +" deals 3 damage to target creature or player.");

      ability.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(ability, true));
    }//*************** END ************ END **************************

	*/

    //*************** START *********** START **************************
    if(cardName.equals("Mawcor"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = 6238678956434079L;
		public boolean canPlayAI()
        {
          return AllZone.Phase.getPhase().equals(Constant.Phase.Main2);
        }

        public void chooseTargetAI()
        {
          setTargetPlayer(Constant.Player.Human);
        }
        public void resolve()
        {
          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
              getTargetCard().addDamage(1);
          }
          else
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(1);
        }//resolve()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Mawcor deals 1 damage to target creature or player.");

      ability.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(ability, true));
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Orcish Artillery") || cardName.equals("Goblin Artillery") 
    || cardName.equals("Orcish Cannoneers"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = -305363091630642003L;
		public boolean canPlayAI()
        {
          return AllZone.Computer_Life.getLife() > 6;
        }

        public void chooseTargetAI()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(2, card, true);
          list.shuffle();

          if(list.isEmpty() || AllZone.Human_Life.getLife() < 5)
            setTargetPlayer(Constant.Player.Human);
          else
            setTargetCard(list.get(0));
        }
        public void resolve()
        {
          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
            {
              getTargetCard().addDamage(2);
              //3 damage to self
              AllZone.GameAction.getPlayerLife(card.getController()).subtractLife(3);
              
              if (card.getKeyword().contains("Lifelink"))
              	GameActionUtil.executeLifeLinkEffects(card, 5);
              for(int i=0; i < CardFactoryUtil.hasNumberEnchantments(card, "Guilty Conscience"); i++)
            	   GameActionUtil.executeGuiltyConscienceEffects(card, 5);
              
            }
          }
          else
          {
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(2);
            //3 damage to self
            AllZone.GameAction.getPlayerLife(card.getController()).subtractLife(3);
            
            if (card.getKeyword().contains("Lifelink"))
            	GameActionUtil.executeLifeLinkEffects(card, 5);
            for(int i=0; i < CardFactoryUtil.hasNumberEnchantments(card, "Guilty Conscience"); i++)
          	   GameActionUtil.executeGuiltyConscienceEffects(card, 5);
          }
          
        }//resolve()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: " +cardName + " deals 2 damage to target creature or player and 3 damage to you.");

      ability.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(ability,true));
    }//*************** END ************ END **************************






    //*************** START *********** START **************************
    if(cardName.equals("Sparksmith"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = 681102636956052363L;
		public boolean canPlayAI()
        {
          int n = countGoblins();
          return (AllZone.Computer_Life.getLife() > n) &&
                 (CardFactoryUtil.AI_getHumanCreature(n, card, true).size() != 0);
        }
        public void chooseTargetAI()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(countGoblins(), card, true);
          list.shuffle();
          setTargetCard(list.get(0));
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
            life.subtractLife(countGoblins());

            getTargetCard().addDamage(countGoblins());
            
            if (card.getKeyword().contains("Lifelink"))
            	GameActionUtil.executeLifeLinkEffects(card, 2*countGoblins());
            for(int i=0; i < CardFactoryUtil.hasNumberEnchantments(card, "Guilty Conscience"); i++)
         	   GameActionUtil.executeGuiltyConscienceEffects(card, 2*countGoblins());
          }
        }//resolve()
        int countGoblins()
        {
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.getType("Goblin");
          return list.size();
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Sparksmith deals X damage to target creature and X damage to you, where X is the number of Goblins in play.");

      ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
    }//*************** END ************ END **************************

  //*************** START *********** START **************************
    if(cardName.equals("Rathi Assassin"))
    {
      final Ability_Tap ability = new Ability_Tap(card, "1 B B")
      {
    	private static final long serialVersionUID = 1117792059002738977L;
		public boolean canPlay()
    	{
    		return AllZone.GameAction.isCardInPlay(card) && !card.isTapped() && !card.hasSickness();
    	}
        public boolean canPlayAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          human = human.filter(new CardListFilter()
          {
            public boolean addCard(Card c) {return c.isTapped() && !CardUtil.getColor(c).equals(Constant.Color.Black);}
          });

          CardListUtil.sortAttack(human);
          CardListUtil.sortFlying(human);

          if(0 < human.size())
            setTargetCard(human.get(0));

          return 0 < human.size();
        }
        public void resolve()
        {
          Card c = getTargetCard();

          if(AllZone.GameAction.isCardInPlay(c) && c.isTapped()  && CardFactoryUtil.canTarget(card, c) && !CardUtil.getColor(c).equals(Constant.Color.Black) )
          {
            AllZone.GameAction.destroy(c);
          }
        }//resolve()
      };//SpellAbility
      
      /*
      Input target = new Input()
      {
        public void showMessage()
        {
          AllZone.Display.showMessage("Select target tapped nonblack creature to destroy");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          if(c.isCreature() && zone.is(Constant.Zone.Play) && c.isTapped() && ! CardUtil.getColor(c).equals(Constant.Color.Black) )
          {
            //tap ability
            card.tap();

            ability.setTargetCard(c);
            AllZone.Stack.add(ability);
            stop();
          }
        }//selectCard()
      };//Input
      */
      
      ability.setBeforePayMana(new Input()
      {
   	   private static final long serialVersionUID = -7903295056497483023L;

	public void showMessage()
          {
   		   	String opponent = AllZone.GameAction.getOpponent(card.getController());
            CardList slivers = new CardList(AllZone.getZone(Constant.Zone.Play, opponent).getCards());
            slivers = slivers.filter(new CardListFilter()
            {

				public boolean addCard(Card c)
				{
					PlayerZone zone = AllZone.getZone(c);
					return c.isCreature() && zone.is(Constant.Zone.Play) && c.isTapped() && ! CardUtil.getColor(c).equals(Constant.Color.Black);
				}
            	
            });
            
            stopSetNext(CardFactoryUtil.input_targetSpecific(ability, slivers, "Select a tapped non-black creature", true));
          }
      });

      card.addSpellAbility(ability);
      ability.setDescription("1 B B, tap: Destroy target tapped nonblack creature.");
      //ability.setBeforePayMana(target);
      //ability.setAfterPayMana(target);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Royal Assassin"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = 1974437552336643722L;
		public boolean canPlayAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          human = human.filter(new CardListFilter()
          {
            public boolean addCard(Card c) {return c.isTapped();}
          });

          CardListUtil.sortAttack(human);
          CardListUtil.sortFlying(human);

          if(0 < human.size())
            setTargetCard(human.get(0));

          return 0 < human.size();
        }
        public void resolve()
        {
          Card c = getTargetCard();

          if(AllZone.GameAction.isCardInPlay(c) && c.isTapped()  && CardFactoryUtil.canTarget(card, c) )
          {
            AllZone.GameAction.destroy(c);
          }
        }//resolve()
      };//SpellAbility

      Input target = new Input()
      {
        private static final long serialVersionUID = -5894703805950364923L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target tapped creature to destroy");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          if(!CardFactoryUtil.canTarget(card, c)){
          	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }
          else if(c.isCreature() && zone.is(Constant.Zone.Play) && c.isTapped())
          {
            //tap ability
            card.tap();

            ability.setTargetCard(c);
            AllZone.Stack.add(ability);
            stop();
          }
        }//selectCard()
      };//Input

      card.addSpellAbility(ability);
      ability.setDescription("tap: Destroy target tapped creature.");
      ability.setBeforePayMana(target);
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    if(cardName.equals("Giltspire Avenger"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = -1117719063688165635L;

		public boolean canPlayAI()
        {
          return false;
        }
        
        public boolean canPlay()
        {
        	System.out.println("phase =" + AllZone.Phase.getPhase());
        	if ((AllZone.Phase.getPhase().equals(Constant.Phase.Main2) || 
        		AllZone.Phase.getPhase().equals(Constant.Phase.End_Of_Turn)) &&
        		!card.hasSickness() && card.isUntapped())
        		return true;
        	else
        		return false;
        	
        }
        
        public void resolve()
        {
          Card c = getTargetCard();

          if(AllZone.GameAction.isCardInPlay(c) && (c.getDealtCombatDmgToOppThisTurn() || c.getDealtDmgToOppThisTurn())
             && CardFactoryUtil.canTarget(card, c) )
          {
            AllZone.GameAction.destroy(c);
          }
        }//resolve()
      };//SpellAbility

      Input target = new Input()
      {
        private static final long serialVersionUID = -4946540988877576202L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target creature to destroy");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          if(!CardFactoryUtil.canTarget(card, c)){
          	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }
          else if(c.isCreature() && zone.is(Constant.Zone.Play) && (c.getDealtCombatDmgToOppThisTurn() || 
        		  c.getDealtDmgToOppThisTurn()) )
          {
            //tap ability
            card.tap();

            ability.setTargetCard(c);
            AllZone.Stack.add(ability);
            stop();
          }
        }//selectCard()
      };//Input

      card.addSpellAbility(ability);
      ability.setDescription("tap: Destroy target creature that dealt damage to you this turn.");
      ability.setBeforePayMana(target);
    }//*************** END ************ END **************************





  //*************** START *********** START **************************
    if(cardName.equals("Hex"))
    {
      final Card[] target = new Card[6];
      final int[] index = new int[1];

      final SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -1880229743741157304L;
		public boolean canPlayAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);

          CardListUtil.sortAttack(human);
          CardListUtil.sortFlying(human);

          if(6 <= human.size())
          {
            for(int i = 0; i < 6; i++) //should check to make sure none of these creatures have protection or cannot be the target of spells.
              target[i] = human.get(i);
          }

          return 6 <= human.size();
        }
        public void resolve()
        {
          for(int i = 0; i < target.length; i++)
            if(AllZone.GameAction.isCardInPlay(target[i]) && CardFactoryUtil.canTarget(card, target[i]) )
              AllZone.GameAction.destroy(target[i]);
        }//resolve()
      };//SpellAbility


      final Input input = new Input()
      {
        private static final long serialVersionUID = 5792813689927185739L;
		public void showMessage()
        {
          int count = 6 - index[0];
          AllZone.Display.showMessage("Select target " + count +" creatures to destroy");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          for(int i=0;i<index[0];i++){
             if(c.equals(target[i])){
                AllZone.Display.showMessage("You have already selected this target. You must select unique targets for each of the 6 creatures to destroy.");
                return; //cannot target the same creature twice.
             }
          }
         
          if(c.isCreature() && zone.is(Constant.Zone.Play))
          {
            target[index[0]] = c;
            index[0]++;
            showMessage();

            if(index[0] == target.length)
              stopSetNext(new Input_PayManaCost(spell));
          }
        }//selectCard()
      };//Input

      Input runtime = new Input()
      {
        private static final long serialVersionUID = 3522833806455511494L;

		public void showMessage()
        {
          index[0] = 0;
          stopSetNext(input);
        }
      };//Input

      card.clearSpellAbility();
      card.addSpellAbility(spell);
      spell.setBeforePayMana(runtime);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Vedalken Plotter"))
    {
      final Card[] target = new Card[2];
      final int[] index = new int[1];

      final Ability ability = new Ability(card, "")
      {

		private static final long serialVersionUID = -3075569295823682336L;
		public boolean canPlayAI()
        {
          return false;
        }
        public void resolve()
        {
            
            Card crd0 = target[0];
            Card crd1 = target[1];
            
            if (crd0 != null && crd1 != null)
            {
            
	            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
	            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);
	
	            PlayerZone from0 = AllZone.getZone(crd0);
	            from0.remove(crd0);
	            PlayerZone from1 = AllZone.getZone(crd1);
	            from1.remove(crd1);
	           
	            crd0.setController(AllZone.GameAction.getOpponent(card.getController()));
	            crd1.setController(card.getController());
	            
	            PlayerZone to0 = AllZone.getZone(Constant.Zone.Play, AllZone.GameAction.getOpponent(card.getController()));
	            to0.add(crd0);
	            PlayerZone to1 = AllZone.getZone(Constant.Zone.Play, card.getController());
	            to1.add(crd1);
	
	            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
	            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
            }
            
        }//resolve()
      };//SpellAbility


      final Input input = new Input()
      {
		
		private static final long serialVersionUID = -7143706716256752987L;
		public void showMessage()
        {
          if(index[0] == 0)
            AllZone.Display.showMessage("Select target land you control.");
          else
            AllZone.Display.showMessage("Select target land opponent controls.");

          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          //must target creature you control
          if(index[0] == 0 && !c.getController().equals(card.getController()))
             return;

          //must target creature you don't control
          if(index[0] == 1 && c.getController().equals(card.getController()))
             return;


          if(c.isLand() && zone.is(Constant.Zone.Play) && CardFactoryUtil.canTarget(card, c))
          {
        	  //System.out.println("c is: " +c);
            target[index[0]] = c;
            index[0]++;
            showMessage();

            if(index[0] == target.length) {
                AllZone.Stack.add(ability);
                stop();
            }
          }
        }//selectCard()
      };//Input

      Command comesIntoPlay = new Command()
      {
			private static final long serialVersionUID = 6513203926272187582L;
	
			public void execute() {
				index[0] = 0;
				if(card.getController().equals(Constant.Player.Human))
		            AllZone.InputControl.setInput(input);
			}  
      };

      //card.clearSpellAbility();
      ability.setStackDescription(cardName + " - Exchange control of target land you control and target land an opponent controls.");
      card.addComesIntoPlayCommand(comesIntoPlay);
    }//*************** END ************ END **************************
    

    //*************** START *********** START **************************
    if(cardName.equals("Political Trickery"))
    {
      final Card[] target = new Card[2];
      final int[] index = new int[1];

      final SpellAbility spell = new Spell(card)
      {

		private static final long serialVersionUID = -3075569295823682336L;
		public boolean canPlayAI()
        {
          return false;
        }
        public void resolve()
        {
            
            Card crd0 = target[0];
            Card crd1 = target[1];
            
            if (crd0 != null && crd1 != null)
            {
	            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
	            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);
	
	            PlayerZone from0 = AllZone.getZone(crd0);
	            from0.remove(crd0);
	            PlayerZone from1 = AllZone.getZone(crd1);
	            from1.remove(crd1);
	           
	            crd0.setController(AllZone.GameAction.getOpponent(card.getController()));
	            crd1.setController(card.getController());
	            
	            PlayerZone to0 = AllZone.getZone(Constant.Zone.Play, AllZone.GameAction.getOpponent(card.getController()));
	            to0.add(crd0);
	            PlayerZone to1 = AllZone.getZone(Constant.Zone.Play, card.getController());
	            to1.add(crd1);
	
	            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
	            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
            }
            
        }//resolve()
      };//SpellAbility


      final Input input = new Input()
      {
		
		private static final long serialVersionUID = -1017253686774265770L;
		public void showMessage()
        {
          if(index[0] == 0)
            AllZone.Display.showMessage("Select target land you control.");
          else
            AllZone.Display.showMessage("Select target land opponent controls.");

          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          //must target creature you control
          if(index[0] == 0 && !c.getController().equals(card.getController()))
             return;

          //must target creature you don't control
          if(index[0] == 1 && c.getController().equals(card.getController()))
             return;


          if(c.isLand() && zone.is(Constant.Zone.Play) && CardFactoryUtil.canTarget(card, c))
          {
            target[index[0]] = c;
            index[0]++;
            showMessage();

            if(index[0] == target.length)
              stopSetNext(new Input_PayManaCost(spell));
          }
        }//selectCard()
      };//Input

      Input runtime = new Input()
      {

		private static final long serialVersionUID = 4003351872990899418L;

		public void showMessage()
        {
          index[0] = 0;
          stopSetNext(input);
        }
      };//Input

      card.clearSpellAbility();
      card.addSpellAbility(spell);
      spell.setBeforePayMana(runtime);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Peel from Reality"))
    {
      final Card[] target = new Card[2];
      final int[] index = new int[1];

      final SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -5781099237509350795L;
		public boolean canPlayAI()
        {
          return false;
        }
        public void resolve()
        {
          //bounce two creatures in target[]
          for(int i = 0; i < target.length; i++)
          {
            Card c = target[i];
            PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, c.getOwner());

            if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, c) )
              AllZone.GameAction.moveTo(hand, c);
          }
        }//resolve()
      };//SpellAbility


      final Input input = new Input()
      {
		private static final long serialVersionUID = -5897481915350104062L;
		public void showMessage()
        {
          if(index[0] == 0)
            AllZone.Display.showMessage("Select target creature you control to bounce return to their owners' hand");
          else
            AllZone.Display.showMessage("Select target creature you don't control to return to their owners' hand");

          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          //must target creature you control
          if(index[0] == 0 && !c.getController().equals(card.getController()))
             return;

          //must target creature you don't control
          if(index[0] == 1 && c.getController().equals(card.getController()))
             return;


          if(c.isCreature() && zone.is(Constant.Zone.Play) && CardFactoryUtil.canTarget(card, c))
          {
            target[index[0]] = c;
            index[0]++;
            showMessage();

            if(index[0] == target.length)
              stopSetNext(new Input_PayManaCost(spell));
          }
        }//selectCard()
      };//Input

      Input runtime = new Input()
      {
		private static final long serialVersionUID = 1194864613104644447L;

		public void showMessage()
        {
          index[0] = 0;
          stopSetNext(input);
        }
      };//Input

      card.clearSpellAbility();
      card.addSpellAbility(spell);
      spell.setBeforePayMana(runtime);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Ashes to Ashes"))
    {
      final Card[] target = new Card[2];
      final int[] index = new int[1];

      final SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -6509598408022853029L;

		public boolean canPlayAI()
        {
          return 2 <= getNonArtifact().size() &&
                 5 < AllZone.Computer_Life.getLife() ;
        }
        public void chooseTargetAI()
        {
          CardList human = getNonArtifact();
          CardListUtil.sortAttack(human);

          target[0] = human.get(0);
          target[1] = human.get(1);
        }
        CardList getNonArtifact()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(card, true);
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return !c.isArtifact();
            }
          });
          return list;
        }//getNonArtifact()

        public void resolve()
        {
          for(int i = 0; i < target.length; i++)
          {
            Card c = target[i];
            PlayerZone remove = AllZone.getZone(Constant.Zone.Removed_From_Play, c.getOwner());

            AllZone.GameAction.moveTo(remove, c);
          }

          PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
          life.subtractLife(5);
        }//resolve()
      };//SpellAbility


      final Input input = new Input()
      {
		private static final long serialVersionUID = -4114782677700487264L;
		public void showMessage()
        {
          if(index[0] == 0)
            AllZone.Display.showMessage("Select 1st target non-artifact creature to remove from the game");
          else
            AllZone.Display.showMessage("Select 2nd target non-artifact creature to remove from the game");

          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          if(! CardUtil.getColor(c).equals(Constant.Color.Colorless) &&
             c.isCreature()              &&
             zone.is(Constant.Zone.Play))
          {
            target[index[0]] = c;
            index[0]++;
            showMessage();

            if(index[0] == target.length)
              stopSetNext(new Input_PayManaCost(spell));
          }
        }//selectCard()
      };//Input

      Input runtime = new Input()
      {
		private static final long serialVersionUID = -3162536306318797516L;

		public void showMessage()
        {
          index[0] = 0;
          stopSetNext(input);
        }
      };//Input

      card.clearSpellAbility();
      card.addSpellAbility(spell);
      spell.setBeforePayMana(runtime);
    }//*************** END ************ END **************************

  //*************** START *********** START **************************
    if(cardName.equals("Ramses Overdark"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {

		private static final long serialVersionUID = 3560953910041049722L;

		public boolean canPlayAI()
        {
          if(CardFactoryUtil.AI_doesCreatureAttack(card))
            return false;

          return CardFactoryUtil.AI_getHumanCreature(card, true).size() != 0;
        }
        public void chooseTargetAI()
        {
          CardList creature = CardFactoryUtil.AI_getHumanCreature(card, true);
          Card target = CardFactoryUtil.AI_getBestCreature(creature);
          setTargetCard(target);
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) && getTargetCard().isEnchanted() )
          {
            AllZone.GameAction.destroy(getTargetCard());
          }
        }//resolve()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Destroy target enchanted creature.");

      Input runtime = new Input()
      {

		private static final long serialVersionUID = 7538894357147291895L;

		public void showMessage()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());
          all = all.filter(new CardListFilter()
          {
			public boolean addCard(Card c) {
				return AllZone.GameAction.isCardInPlay(c) && c.isCreature() && CardFactoryUtil.canTarget(card, c) && c.isEnchanted();
			}
          });
          
          stopSetNext(CardFactoryUtil.input_targetSpecific(ability, all, "Destroy target enchanted creature.", true));
        }
      };
      ability.setBeforePayMana(runtime);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Visara the Dreadful"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = 6371765024236754171L;

		public boolean canPlayAI()
        {
          if(CardFactoryUtil.AI_doesCreatureAttack(card))
            return false;

          return CardFactoryUtil.AI_getHumanCreature(card, true).size() != 0;
        }
        public void chooseTargetAI()
        {
          CardList creature = CardFactoryUtil.AI_getHumanCreature(card, true);
          Card target = CardFactoryUtil.AI_getBestCreature(creature);
          setTargetCard(target);
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            AllZone.GameAction.destroyNoRegeneration(getTargetCard());
          }
        }//resolve()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Destroy target creature. It can't be regenerated");

      ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Ethersworn Adjudicator"))
    {
      final Ability_Tap ability = new Ability_Tap(card, "1 W B")
      {
		private static final long serialVersionUID = 4160943954590944389L;

		public boolean canPlay()
    	{
    		SpellAbility sa;
	    	  for (int i=0; i<AllZone.Stack.size(); i++)
	    	  {
	    	       sa = AllZone.Stack.peek(i);
	    	       if (sa.getSourceCard().equals(card))
	    	             return false;
	    	  }
	    	  
	    	  if (AllZone.GameAction.isCardInPlay(card) && !card.hasSickness() && !card.isTapped())
	    		  return true;
	    	  else
	    		  return false;
    		
    	}
        public boolean canPlayAI()
        {
          if(CardFactoryUtil.AI_doesCreatureAttack(card))
            return false;

          return CardFactoryUtil.AI_getHumanCreature(card, true).size() != 0 && CardFactoryUtil.AI_getHumanEnchantment(card, true).size() != 0;
        }
        public void chooseTargetAI()
        {
          CardList creature = CardFactoryUtil.AI_getHumanCreature(card, true);
          if (creature.size() > 0){
        	  Card target = CardFactoryUtil.AI_getBestCreature(creature);
        	  setTargetCard(target);
          }
          else
          {
        	  CardList enchantment = CardFactoryUtil.AI_getHumanEnchantment(card, true);
        	  if (enchantment.size() > 0)
        	  {
        		  Card target = CardFactoryUtil.AI_getBestEnchantment(enchantment, card, true);
        		  setTargetCard(target);
        	  }
          }
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            AllZone.GameAction.destroy(getTargetCard());
          }
        }//resolve()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap, 1 W B: Destroy target creature or enchantment.");

      //ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
      
      Input runtime = new Input()
      {
		private static final long serialVersionUID = -8099713981623158814L;

		public void showMessage()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());
          all = all.filter(new CardListFilter()
          {
			public boolean addCard(Card c) {
				return (c.isEnchantment() || c.isCreature() ) && CardFactoryUtil.canTarget(card, c);
			}
          });
          
          stopSetNext(CardFactoryUtil.input_targetSpecific(ability, all, "Destroy target creature or enchantment.", true));
        }
      };
      ability.setBeforePayMana(runtime);
    }//*************** END ************ END **************************






    //*************** START *********** START **************************
    if(cardName.equals("Wojek Embermage"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = -1208482961653326721L;
		public boolean canPlayAI()
        {
          return (CardFactoryUtil.AI_getHumanCreature(1, card, true).size() != 0) &&
                  (AllZone.Phase.getPhase().equals(Constant.Phase.Main2));
        }

        public void chooseTargetAI()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(1, card, true);
          list.shuffle();
          setTargetCard(list.get(0));
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            CardList list = getRadiance(getTargetCard());
            for(int i = 0; i < list.size(); i++)
              list.get(i).addDamage(1);
          }
        }//resolve()
        //parameter Card c, is included in CardList
        //no multi-colored cards
        CardList getRadiance(Card c)
        {
          String color = CardUtil.getColor(c);
          if(color.equals(Constant.Color.Colorless))
          {
            CardList list = new CardList();
            list.add(c);
            return list;
          }

          CardList sameColor = new CardList();

          //get all creatures
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.getType("Creature");

          for(int i = 0; i < list.size(); i++)
            if(CardUtil.getColor(list.get(i)).equals(color))
              sameColor.add(list.get(i));

          return sameColor;
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("Radiance - tap: Wojek Embermage deals 1 damage to target creature and each other creature that shares a color with it.");

      ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Timberwatch Elf"))
    {
      final Card[] creature = new Card[1];
      final int[] pump = new int[1];
      final Command EOT = new Command()
      {
		private static final long serialVersionUID = -2764970883655205904L;

		public void execute()
        {
          if(AllZone.GameAction.isCardInPlay(creature[0]))
          {
            creature[0].addTempAttackBoost(-pump[0]);
            creature[0].addTempDefenseBoost(-pump[0]);
          }
        }
      };

      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = -7536296719726210357L;
		public boolean canPlayAI()
        {
          CardList c = getAttackers();
          if(c.isEmpty())
            return false;
          else
          {
            setTargetCard(c.get(0));
            return true;
          }
        }//canPlayAI()
        CardList getAttackers()
        {
          Card[] c = ComputerUtil.getAttackers().getAttackers();
          CardList list = new CardList(c);
          list = list.filter(new CardListFilter(){

			public boolean addCard(Card c) {
				return CardFactoryUtil.canTarget(card, c);
			}
        	  
          });
          
          //remove "this card" from attackers, if it is there
          list.remove(card);
          list.shuffle();
          return list;
        }//getAttackers()

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            creature[0] = getTargetCard();
            pump[0]     = countElves();

            creature[0].addTempAttackBoost(pump[0]);
            creature[0].addTempDefenseBoost(pump[0]);

            AllZone.EndOfTurn.addUntil(EOT);
          }
        }//resolve()
        int countElves()
        {
          CardList elf = new CardList();
          elf.addAll(AllZone.Human_Play.getCards());
          elf.addAll(AllZone.Computer_Play.getCards());

          elf = elf.getType("Elf");
          return elf.size();
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Target creature gets +X/+X until end of turn, where X is the number of Elves in play.");

      ability.setBeforePayMana(CardFactoryUtil.input_targetCreature_NoCost_TapAbility(ability));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Mad Auntie"))
    {
      final Card[] creature = new Card[1];
      final Command EOT = new Command()
      {
        private static final long serialVersionUID = -5143708900761432510L;

		public void execute()
        {
          if(AllZone.GameAction.isCardInPlay(creature[0]))
          {
            creature[0].setShield(0);
          }
        }
      };

      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = -1280855188535819509L;
		public boolean canPlayAI()
        {
            return false;
        }//canPlayAI()
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            getTargetCard().addShield();
            AllZone.EndOfTurn.addUntil(EOT);
          }
        }//resolve()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Regenerate another target Goblin.");

      ability.setBeforePayMana(CardFactoryUtil.input_targetCreature_NoCost_TapAbility(ability));
    }//*************** END ************ END **************************






    //*************** START *********** START **************************
    if(cardName.equals("Intrepid Hero"))
    {
      //tap ability - no cost - target creature

      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = -7825416464364928117L;
		public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) &&
        	 getTargetCard().getNetAttack() >= 4)
          {
            AllZone.GameAction.destroy(getTargetCard());
          }
        }//resolve()
        public boolean canPlayAI()
        {
          return getHumanCreatures().size() != 0;
        }
        public void chooseTargetAI()
        {
          CardList human = getHumanCreatures();
          human.shuffle();
          setTargetCard(human.get(0));
        }
        CardList getHumanCreatures()
        {
          CardList list = new CardList(AllZone.Human_Play.getCards());
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isCreature() && 3 < c.getNetAttack();
            }
          });
          return list;
        }
      };//SpellAbility

      Input target = new Input()
      {
        private static final long serialVersionUID = -7024383930124942288L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target creature with power 4 or greater");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if(card.isCreature() && zone.is(Constant.Zone.Play) && 3 < card.getNetAttack())
          {
            ability.setTargetCard(card);
            stopSetNext(new Input_NoCost_TapAbility(ability));
          }
        }
      };

      card.addSpellAbility(ability);
      ability.setDescription("tap: Destroy target creature with power 4 or greater.");

      ability.setBeforePayMana(target);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Tetsuo Umezawa"))
    {
      //tap ability - no cost - target creature

      final Ability_Tap ability = new Ability_Tap(card)
      {

		private static final long serialVersionUID = -8034678094689484203L;
		public void resolve()
        {
		  CardList blockers = AllZone.Combat.getAllBlockers();
			
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) &&
        	(blockers.contains(getTargetCard()) || getTargetCard().isTapped()) )  
          {
        	  AllZone.GameAction.destroy(getTargetCard());
          }
        }//resolve()
        public boolean canPlayAI()
        {
          return false;
        }
      };//SpellAbility

      Input target = new Input()
      {

		private static final long serialVersionUID = -1939019440028116051L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target tapped or blocking creature.");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          CardList blockers = AllZone.Combat.getAllBlockers();
          if(card.isCreature() && zone.is(Constant.Zone.Play) &&
        	  (blockers.contains(card) || card.isTapped()) )
          {
            ability.setTargetCard(card);
            stopSetNext(new Input_NoCost_TapAbility(ability));
          }
        }
      };

      card.addSpellAbility(ability);
      ability.setDescription("U B B R, Tap: Destroy target tapped or blocking creature.");

      ability.setBeforePayMana(target);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Tor Wauki"))
    {
      //tap ability - no cost - target creature

      final Ability_Tap ability = new Ability_Tap(card)
      {

		private static final long serialVersionUID = -8034678094689484203L;
		public void resolve()
        {
		  CardList attackers = new CardList(AllZone.Combat.getAttackers());
		  CardList blockers = AllZone.Combat.getAllBlockers();
			
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) &&
        	(attackers.contains(getTargetCard()) || blockers.contains(getTargetCard()) )  )
          {
        	  getTargetCard().addDamage(2);
          }
        }//resolve()
        public boolean canPlayAI()
        {
          return false;
        }
      };//SpellAbility

      Input target = new Input()
      {

		private static final long serialVersionUID = -1939019440028116051L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target attacking or blocking creature.");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          CardList attackers = new CardList(AllZone.Combat.getAttackers());
          CardList blockers = AllZone.Combat.getAllBlockers();
          if(card.isCreature() && zone.is(Constant.Zone.Play) &&
        	 (attackers.contains(card) || blockers.contains(card) ) )
          {
            ability.setTargetCard(card);
            stopSetNext(new Input_NoCost_TapAbility(ability));
          }
        }
      };

      card.addSpellAbility(ability);
      ability.setDescription("tap: Tor Wauki deals 2 damage to target attacking or blocking creature.");

      ability.setBeforePayMana(target);
    }//*************** END ************ END **************************
    
    

    //*************** START *********** START **************************
    if(cardName.equals("Lady Caleria"))
    {
      //tap ability - no cost - target creature

      final Ability_Tap ability = new Ability_Tap(card)
      {

		private static final long serialVersionUID = -8034678094689484203L;
		public void resolve()
        {
		  CardList attackers = new CardList(AllZone.Combat.getAttackers());
		  CardList blockers = AllZone.Combat.getAllBlockers();
			
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) &&
        	(attackers.contains(getTargetCard()) || blockers.contains(getTargetCard()) )  )
          {
        	  getTargetCard().addDamage(3);
          }
        }//resolve()
        public boolean canPlayAI()
        {
          return false;
        }
      };//SpellAbility

      Input target = new Input()
      {

		private static final long serialVersionUID = -1939019440028116051L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target attacking or blocking creature.");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          CardList attackers = new CardList(AllZone.Combat.getAttackers());
          CardList blockers = AllZone.Combat.getAllBlockers();
          if(card.isCreature() && zone.is(Constant.Zone.Play) &&
        	 (attackers.contains(card) || blockers.contains(card) ) )
          {
            ability.setTargetCard(card);
            stopSetNext(new Input_NoCost_TapAbility(ability));
          }
        }
      };

      card.addSpellAbility(ability);
      ability.setDescription("tap: Lady Caleria deals 3 damage to target attacking or blocking creature.");

      ability.setBeforePayMana(target);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Femeref Archers"))
    {
      //tap ability - no cost - target creature

      final Ability_Tap ability = new Ability_Tap(card)
      {
        
		private static final long serialVersionUID = -4369831076920644547L;
		public void resolve()
        {
		  CardList attackers = new CardList(AllZone.Combat.getAttackers());
			
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) &&
        	attackers.contains(getTargetCard()) && getTargetCard().getKeyword().contains("Flying"))
          {
        	  getTargetCard().addDamage(4);
          }
        }//resolve()
        public boolean canPlayAI()
        {
          return false;
        }
      };//SpellAbility

      Input target = new Input()
      {
        
		private static final long serialVersionUID = 3455890565752527632L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target attacking creature with flying.");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          CardList attackers = new CardList(AllZone.Combat.getAttackers());
          if(card.isCreature() && zone.is(Constant.Zone.Play) && card.getKeyword().contains("Flying") &&
        	 attackers.contains(card))
          {
            ability.setTargetCard(card);
            stopSetNext(new Input_NoCost_TapAbility(ability));
          }
        }
      };

      card.addSpellAbility(ability);
      ability.setDescription("tap: Femeref Archers deals 4 damage to target attacking creature with flying.");

      ability.setBeforePayMana(target);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Adarkar Valkyrie"))
    {
      //tap ability - no cost - target creature - EOT

      final Card[] target = new Card[1];
      
      final Command destroy = new Command()
      {
		private static final long serialVersionUID = -2433442359225521472L;

		public void execute()
        {
          AllZone.Stack.add(new Ability(card, "0", "Return " +target[0] +" from graveyard to play")
          {
            public void resolve()
            {
              PlayerZone grave = AllZone.getZone(target[0]);
              //checks to see if card is still in the graveyard
              if(AllZone.GameAction.isCardInZone(target[0], grave))
              {
                PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
                AllZone.GameAction.moveTo(play, target[0]);
                target[0].setController(card.getController());
              }
            }
          });
        }//execute()
      };
      
      final Command untilEOT = new Command()
      {
        private static final long serialVersionUID = 2777978927867867610L;

		public void execute()
        {
          //resets the Card destroy Command
          //target[0].addDestroy(Command.Blank);
		  target[0].removeDestroyCommand(destroy);	
		
        }
      };

      final Ability_Tap ability = new Ability_Tap(card)
      {
		private static final long serialVersionUID = -8454685126878522607L;
		public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()))
          {
            target[0] = getTargetCard();
            AllZone.EndOfTurn.addUntil(untilEOT);

            //when destroyed, return to play
            //add triggered ability to target card
            target[0].addDestroyCommand(destroy);
          }//if
        }//resolve()
        public boolean canPlayAI()
        {
          return false;
        }
      };//SpellAbility

      Input targetInput = new Input()
      {
        private static final long serialVersionUID = 913860087744941946L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target non-token creature other than this card");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          //must target non-token creature, and cannot target itself
          if(c.isCreature() && (!c.isToken()) && (!c.equals(card)))
          {
            ability.setTargetCard(c);
            stopSetNext(new Input_NoCost_TapAbility(ability));
          }
        }
      };

      card.addSpellAbility(ability);
      ability.setDescription("tap: When target creature other than Adarkar Valkyrie is put into a graveyard this turn, return that card to play under your control.");

      ability.setBeforePayMana(targetInput);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Imperious Perfect"))
    {
      //mana tap ability
      final Ability_Tap ability = new Ability_Tap(card, "G")
      {
        private static final long serialVersionUID = -3266607637871879336L;

		public boolean canPlayAI()
        {
          String phase = AllZone.Phase.getPhase();
          return phase.equals(Constant.Phase.Main2);
        }
        public void chooseTargetAI() {card.tap();}

        public void resolve()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Elf Warrior");
          c.setImageName("G 1 1 Elf Warrior");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Elf");
          c.addType("Warrior");

          c.setBaseAttack(1);
          c.setBaseDefense(1);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//resolve()
      };//SpellAbility

      card.addSpellAbility(ability);

      ability.setDescription("G, tap: Put a 1/1 green Elf Warrior creature token into play.");
      ability.setStackDescription("Imperious Perfect - Put a 1/1 green Elf Warrior creature token into play.");
      ability.setBeforePayMana(new Input_PayManaCost(ability));
    }//*************** END ************ END **************************






    //*************** START *********** START **************************
    if(cardName.equals("Wall of Kelp"))
    {
      //mana tap ability
      final Ability_Tap ability = new Ability_Tap(card, "U U")
      {
        private static final long serialVersionUID = 2893813929304858905L;

		public boolean canPlayAI()
        {
          String phase = AllZone.Phase.getPhase();
          return phase.equals(Constant.Phase.Main2);
        }
        public void chooseTargetAI() {card.tap();}

        public void resolve()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Kelp");
          c.setManaCost("U");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Plant");
          c.addType("Wall");
          c.addIntrinsicKeyword("Defender");

          c.setBaseAttack(0);
          c.setBaseDefense(1);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//resolve()
      };//SpellAbility

      card.addSpellAbility(ability);

      ability.setDescription("UU, tap: Put a 0/1 blue Kelp Wall creature token with defender into play.");
      ability.setStackDescription("Wall of Kelp - Put a 0/1 blue Kelp Wall creature token with defender into play");
      ability.setBeforePayMana(new Input_PayManaCost(ability));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Vedalken Mastermind"))
    {
      //mana tap ability
      final Ability_Tap ability = new Ability_Tap(card, "U")
      {
        private static final long serialVersionUID = -6131368241135911606L;

		public boolean canPlayAI() {return false;}

        public void resolve()
        {
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, getTargetCard().getOwner());
          AllZone.GameAction.moveTo(hand, getTargetCard());
          
          if (getTargetCard().isToken())
        	  hand.remove(getTargetCard());
        }//resolve()
      };//SpellAbility


      Input runtime = new Input()
      {
        private static final long serialVersionUID = -5218098811060156481L;

		public void showMessage()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList choice = new CardList(play.getCards());
          stopSetNext(CardFactoryUtil.input_targetSpecific(ability, choice, "Select a permanent you control.", true));
        }
      };
      card.addSpellAbility(ability);
      ability.setDescription("U, tap: Return target permanent you control to its owner's hand.");
      ability.setBeforePayMana(runtime);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Helldozer"))
    {
      //mana tap ability
      final Ability_Tap ability = new Ability_Tap(card, "B B B")
      {
        private static final long serialVersionUID = 6426884086364885861L;

		public boolean canPlayAI()
        {
          if(CardFactoryUtil.AI_doesCreatureAttack(card))
            return false;

          CardList land = new CardList(AllZone.Human_Play.getCards());
          land = land.getType("Land");
          return land.size() != 0;
        }

        public void chooseTargetAI()
        {
          card.tap();

          //target basic land that Human only has 1 or 2 in play
          CardList land = new CardList(AllZone.Human_Play.getCards());
          land = land.getType("Land");

          Card target = null;

          String[] name = {"Forest", "Swamp", "Plains", "Mountain", "Island"};
          for(int i = 0; i < name.length; i++)
            if(land.getName(name[i]).size() == 1)
            {
              target = land.getName(name[i]).get(0);
              break;
            }

          //see if there are only 2 lands of the same type
          if(target == null)
          {
            for(int i = 0; i < name.length; i++)
              if(land.getName(name[i]).size() == 2)
              {
              target = land.getName(name[i]).get(0);
              break;
            }
          }//if
          if(target == null)
          {
            land.shuffle();
            target = land.get(0);
          }
          setTargetCard(target);
        }//chooseTargetAI()

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            AllZone.GameAction.destroy(getTargetCard());

            //if non-basic, untap Helldozer
            if(! getTargetCard().getType().contains("Basic"))
              card.untap();
          }
        }//resolve()
      };//SpellAbility

      card.addSpellAbility(ability);
      ability.setDescription("BBB, tap: Destroy target land. If that land is nonbasic, untap Helldozer.");
      ability.setBeforePayMana(CardFactoryUtil.input_targetType(ability, "Land"));
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Cao Cao, Lord of Wei"))
    {
      //mana tap ability
      final Ability_Tap ability = new Ability_Tap(card, "0")
      {
        private static final long serialVersionUID = 6760838700101179614L;
		public void chooseTargetAI() {card.tap();}
        public boolean canPlayAI()
        {
          int hand = AllZone.Human_Hand.getCards().length;
          if((! CardFactoryUtil.AI_doesCreatureAttack(card)) && hand != 0)
            return true;

          return 2 <= hand;
        }

        public void resolve()
        {
          String player = AllZone.GameAction.getOpponent(card.getController());

          if(player.equals(Constant.Player.Human))
             AllZone.InputControl.setInput(CardFactoryUtil.input_discard(2));
          else
          {
            AllZone.GameAction.discardRandom(player);
            AllZone.GameAction.discardRandom(player);
          }
        }//resolve()
        public boolean canPlay()
        {
          String opp = AllZone.GameAction.getOpponent(card.getController());
          setStackDescription(card.getName() +" - " +opp +" discards 2 cards");

          String phase         = AllZone.Phase.getPhase();
          String activePlayer = AllZone.Phase.getActivePlayer();

          return super.canPlay() &&
                 phase.equals(Constant.Phase.Main1) &&
                 card.getController().equals(activePlayer);
        }
      };//SpellAbility

      ability.setChooseTargetAI(CardFactoryUtil.AI_targetHuman());
      ability.setDescription("tap: Target opponent discards two cards. Play this ability only during your turn, before the combat phase.");
      ability.setBeforePayMana(new Input_NoCost_TapAbility(ability));

      card.addSpellAbility(ability);
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    if(cardName.equals("Gwendlyn Di Corci"))
    {
      //mana tap ability
      final Ability_Tap ability = new Ability_Tap(card, "0")
      {

		private static final long serialVersionUID = -4211234606012596777L;
		public void chooseTargetAI() {setTargetPlayer(Constant.Player.Human); }
        public boolean canPlayAI()
        {
          int hand = AllZone.Human_Hand.getCards().length;
          return hand > 0;
        }

        public void resolve()
        {
          String player = getTargetPlayer();

          AllZone.GameAction.discardRandom(player);
          
        }//resolve()
        public boolean canPlay()
        {
          setStackDescription(card.getName() +" - " +getTargetPlayer() +" discards a card at random.");

          String activePlayer = AllZone.Phase.getActivePlayer();

          return super.canPlay() &&
                 card.getController().equals(activePlayer);
        }
      };//SpellAbility
      
      Input input = new Input()
      {
		private static final long serialVersionUID = 3312693459353844120L;

		public void showMessage()
    	  {
    	    //prevents this from running multiple times, which it is for some reason
    	    if(ability.getSourceCard().isUntapped())
    	    {
    	      ability.getSourceCard().tap();
    	      stopSetNext(CardFactoryUtil.input_targetPlayer(ability));
    	    }
    	  }
      };

      ability.setDescription("Tap: Target player discards a card at random. Activate this ability only during your turn.");
      ability.setBeforePayMana(input);
      //ability.setBeforePayMana(CardFactoryUtil.input_targetPlayer(ability));

      card.addSpellAbility(ability);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Xira Arien"))
    {
      //mana tap ability
      final Ability_Tap ability = new Ability_Tap(card, "G R B")
      {

		private static final long serialVersionUID = 5373361883064666451L;
		public void chooseTargetAI() {setTargetPlayer(Constant.Player.Computer);}
        public boolean canPlayAI()
        {
          int hand = AllZone.Computer_Hand.getCards().length;
          int lib = AllZone.Computer_Library.getCards().length;
          return hand < 6 && lib > 0;
        }

        public void resolve()
        {
          String player = getTargetPlayer();

          AllZone.GameAction.drawCard(player);
          
        }//resolve()
        public boolean canPlay()
        {
          
          setStackDescription(card.getName() +" - " +getTargetPlayer() +" discards a card at random.");

          return super.canPlay();
        }
      };//SpellAbility

      ability.setDescription("Tap: Target player draws a card.");
      //ability.setBeforePayMana(new Input_NoCost_TapAbility(ability));
      ability.setBeforePayMana(CardFactoryUtil.input_targetPlayer(ability));

      card.addSpellAbility(ability);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Wayward Soul"))
    {
      //mana ability
      final Ability ability = new Ability(card, "U")
      {
        public boolean canPlayAI() {return false;}

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(card) )
          {
            card.setBaseAttack(3);
            card.setBaseDefense(2);
            card.setIntrinsicKeyword(new ArrayList<String>());
            card.addIntrinsicKeyword("Flying");

            card.setAssignedDamage(0);
            card.setDamage(0);
            card.untap();
            AllZone.getZone(card).remove(card);

            //put card on top of library
            PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getOwner());
            library.add(card, 0);
          }
        }//resolve()
      };//SpellAbility

      Input runtime = new Input()
      {
        private static final long serialVersionUID = 1469011418219527227L;

		public void showMessage()
        {
          ability.setStackDescription("Put " +card +" on top of its owner's library");

          stopSetNext(new Input_PayManaCost(ability));
        }
      };
      ability.setDescription("U: Put Wayward Soul on top of its owner's library.");
      ability.setStackDescription("Put Wayward Soul on top of its owner's library.");
      card.addSpellAbility(ability);
      ability.setBeforePayMana(runtime);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Coastal Hornclaw"))
    {
      //sacrifice ability - targets itself - until EOT
      final Command untilEOT = new Command()
      {
        private static final long serialVersionUID = 7538741250040204529L;

		public void execute()
        {
          card.removeIntrinsicKeyword("Flying");
        }
      };

      //mana tap ability
      final Ability ability = new Ability(card, "0")
      {
        public boolean canPlayAI()
        {
          CardList land = new CardList(AllZone.Computer_Play.getCards());
          land = land.getType("Land");

          CardList canBlock = CardFactoryUtil.AI_getHumanCreature(card, true);
          canBlock = canBlock.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isUntapped();
            }
          });

          return (land.size() != 0)                       &&
                 (! card.getKeyword().contains("Flying")) &&
                 CardFactoryUtil.AI_getHumanCreature("Flying", card, false).isEmpty() &&
                 (! card.hasSickness()) &&
                 (AllZone.Phase.getPhase().equals(Constant.Phase.Main1));
        }

        public void chooseTargetAI()
        {
          CardList land = new CardList(AllZone.Computer_Play.getCards());
          land = land.getType("Land");
          land.shuffle();
          AllZone.GameAction.sacrifice(land.get(0));
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(card))
          {
            card.addIntrinsicKeyword("Flying");
            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };//SpellAbility


      Input runtime = new Input()
      {
        private static final long serialVersionUID = 4874019210748846864L;

		public void showMessage()
        {
          ability.setStackDescription(card +" gains flying until EOT.");

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList choice = new CardList(play.getCards());
          choice = choice.getType("Land");
          stopSetNext(CardFactoryUtil.input_sacrifice(ability, choice, "Select a land to sacrifice."));
        }
      };
      ability.setStackDescription(card +" gains flying until end of turn.");
      ability.setDescription("Sacrifice a land: Coastal Hornclaw gains flying until end of turn.");
      card.addSpellAbility(ability);
      ability.setBeforePayMana(runtime);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Spitting Spider"))
    {
      final Ability ability = new Ability(card, "0")
      {
        public boolean canPlayAI()
        {
          return false;
        }
        public void resolve()
        {
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isCreature() && c.getKeyword().contains("Flying");
            }
          });

          for(int i = 0; i < list.size(); i++)
            list.get(i).addDamage(1);
        }//resolve()
      };//SpellAbility

      Input runtime = new Input()
      {
        private static final long serialVersionUID = 2004031367305867525L;

		public void showMessage()
        {

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList choice = new CardList(play.getCards());
          choice = choice.getType("Land");
          stopSetNext(CardFactoryUtil.input_sacrifice(ability, choice, "Select a land to sacrifice."));
        }
      };
      ability.setStackDescription(card +" deals 1 damage to each creature with flying.");
      ability.setDescription("Sacrifice a land: Spitting Spider deals 1 damage to each creature with flying.");
      card.addSpellAbility(ability);
      ability.setBeforePayMana(runtime);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Killer Whale"))
    {
      final Ability ability = new Ability(card, "U")
      {
        public boolean canPlayAI()
        {
          return false;
        }
        public void resolve()
        {
          final Command untilEOT = new Command()
          {
            private static final long serialVersionUID = -8494294720368074013L;

			public void execute()
            {
              card.removeIntrinsicKeyword("Flying");
            }
          };

          if(AllZone.GameAction.isCardInPlay(card))
          {
            card.addIntrinsicKeyword("Flying");
            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };//SpellAbility

      ability.setStackDescription(card +" gains flying until end of turn.");
      ability.setDescription("U: Killer Whale gains flying until end of turn.");
      card.addSpellAbility(ability);
    }//*************** END ************ END **************************

	// *************** START *********** START **************************
	if (cardName.equals("Lay Waste") || cardName.equals("Stone Rain")
			|| cardName.equals("Ice Storm") || cardName.equals("Sinkhole"))
	{
		final SpellAbility spell = new Spell(card)
		{
			private static final long serialVersionUID = -4973311759179228894L;
			public boolean canPlayAI()
			{
				CardList land = new CardList(AllZone.Human_Play.getCards());
				land = land.getType("Basic");
				return land.size() != 0;
			}
				public void chooseTargetAI()
			{
				// target basic land that Human only has 1 or 2 in play
				CardList land = new CardList(AllZone.Human_Play.getCards());
				land = land.getType("Basic");
					Card target = null;
					String[] name =
				{ "Forest", "Swamp", "Plains", "Mountain", "Island" };
				for (int i = 0; i < name.length; i++)
					if (land.getName(name[i]).size() == 1)
					{
						target = land.getName(name[i]).get(0);
						break;
					}
					// see if there are only 2 lands of the same type
				if (target == null)
				{
					for (int i = 0; i < name.length; i++)
						if (land.getName(name[i]).size() == 2)
						{
							target = land.getName(name[i]).get(0);
							break;
						}
				}// if
				if (target == null)
				{
					land.shuffle();
					target = land.get(0);
				}
				setTargetCard(target);
			}// chooseTargetAI()
				public void resolve()
				{
				if (AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
					AllZone.GameAction.destroy(getTargetCard());
			}// resolve()
		};// SpellAbility
		card.clearSpellAbility();
		spell.setBeforePayMana(CardFactoryUtil.input_targetType(spell,
			"Land"));
			card.addSpellAbility(spell);
			if (cardName.equals("Lay Waste"))
		{
			card.addSpellAbility(CardFactoryUtil.ability_cycle(card, "2"));
			spell.setDescription("Destroy target land");
		}
			return card;
	}// *************** END ************ END **************************
	
	//*************** START *********** START **************************
    if(cardName.equals("Obsidian Fireheart"))
    {
    	final Ability ability = new Ability(card, "1 R R")
    	{
			public void resolve() {
				Card c = getTargetCard();
				
				if (AllZone.GameAction.isCardInPlay(c) && c.isLand() && (c.getCounters(Counters.BLAZE)==0) )
					c.addCounter(Counters.BLAZE, 1);
				
			}
			public boolean canPlayAI()
			{
				PlayerZone play = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
				CardList land = new CardList(play.getCards());
				land = land.filter(new CardListFilter()
				{
					public boolean addCard(Card c) {
						return c.isLand() && c.getCounters(Counters.BLAZE) < 1;
					}
				});
				
				if (land.size() > 0)
					setTargetCard(land.get(0));
				
				return land.size() > 0;
			}
    		
    	};
    	
    	ability.setDescription("1 R R: Put a blaze counter on target land without a blaze counter on it. For as long as that land has a blaze counter on it, it has \"At the beginning of your upkeep, this land deals 1 damage to you.\" (The land continues to burn after Obsidian Fireheart has left the battlefield.)");
    	ability.setBeforePayMana(CardFactoryUtil.input_targetType(ability, "Land"));
		card.addSpellAbility(ability);
    	
    }// *************** END ************ END **************************

	//*************** START *********** START **************************
    if(cardName.equals("Glint-Eye Nephilim"))
    {
      final Command untilEOT = new Command()
      {
        private static final long serialVersionUID = 5790680475821014099L;

		public void execute()
        {
          card.addTempAttackBoost(-1);
          card.addTempDefenseBoost(-1);
        }
      };

      final Ability ability = new Ability(card, "1")
      {
        public boolean canPlayAI()
        {
          Card[] hand = AllZone.Computer_Hand.getCards();
          return CardFactoryUtil.AI_doesCreatureAttack(card) && (hand.length != 0);
        }
        public void  chooseTargetAI() {AllZone.GameAction.discardRandom(Constant.Player.Computer);}

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(card) )
          {
            card.addTempAttackBoost(1);
            card.addTempDefenseBoost(1);

            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };//SpellAbility


      Input runtime = new Input()
      {
        private static final long serialVersionUID = -4302110760957471033L;

		public void showMessage()
        {
          ability.setStackDescription(card +" gets +1/+1 until EOT.");
          //stopSetNext(CardFactoryUtil.input_sacrifice(ability, choice, "Select a card to discard."));
          stopSetNext(CardFactoryUtil.input_discard(ability, 1));
          
        }
      };
      ability.setStackDescription(card +" gets +1/+1 until end of turn.");
      ability.setDescription("1, Discard a card: Glint-Eye Nephilim gets +1/+1 until end of turn.");
      card.addSpellAbility(ability);
      ability.setBeforePayMana(runtime);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Wild Mongrel"))
    {
      //sacrifice ability - targets itself - until EOT
      final Command untilEOT = new Command()
      {
        private static final long serialVersionUID = -5563743272875711445L;

		public void execute()
        {
          card.addTempAttackBoost(-1);
          card.addTempDefenseBoost(-1);
        }
      };

      //mana tap ability
      final Ability ability = new Ability(card, "0")
      {
        public boolean canPlayAI()
        {
          Card[] hand = AllZone.Computer_Hand.getCards();
          return CardFactoryUtil.AI_doesCreatureAttack(card) && (hand.length > 3);
        }
        public void  chooseTargetAI() {AllZone.GameAction.discardRandom(Constant.Player.Computer);}

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(card))
          {
            card.addTempAttackBoost(1);
            card.addTempDefenseBoost(1);

            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };//SpellAbility


      Input runtime = new Input()
      {
        private static final long serialVersionUID = -4209163355325441624L;

		public void showMessage()
        {
          ability.setStackDescription(card +" gets +1/+1 until EOT.");
          //stopSetNext(CardFactoryUtil.input_sacrifice(ability, choice, "Select a card to discard."));
          stopSetNext(CardFactoryUtil.input_discard(ability, 1));
          //AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
        }
      };
      ability.setStackDescription(card +" gets +1/+1 until end of turn.");
      ability.setDescription("Discard a card: Wild Mongrel gets +1/+1 until end of turn.");
      card.addSpellAbility(ability);
      ability.setBeforePayMana(runtime);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Hell-Bent Raider"))
    {
      final Command untilEOT = new Command()
      {

		private static final long serialVersionUID = -2693050198371979012L;

		public void execute()
        {
          card.removeIntrinsicKeyword("Protection from white");
        }
      };

      //mana tap ability
      final Ability ability = new Ability(card, "0")
      {
        public boolean canPlayAI()
        {
          return false;
        }

        public void resolve()
        {
          AllZone.GameAction.discardRandom(card.getController());
          if(AllZone.GameAction.isCardInPlay(card))
          { 
        	card.addIntrinsicKeyword("Protection from white");
            
            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };//SpellAbility


      ability.setStackDescription(card +" gets Protection from white until end of turn.");
      ability.setDescription("Discard a card at random: Hell-Bent Raider gets protection from white until end of turn.");
      card.addSpellAbility(ability);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Whiptongue Frog"))
    {
      //mana ability - targets itself - until EOT
      final Command untilEOT = new Command()
      {
        private static final long serialVersionUID = -2693050198371979012L;

		public void execute()
        {
          card.removeIntrinsicKeyword("Flying");
        }
      };

      //mana tap ability
      final Ability ability = new Ability(card, "U")
      {
        public boolean canPlayAI()
        {       
          return (! card.hasSickness()) &&
                 (! card.getKeyword().contains("Flying")) &&
                 (AllZone.Phase.getPhase().equals(Constant.Phase.Main1));
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(card))
          {
            card.addIntrinsicKeyword("Flying");
            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };//SpellAbility


      Input runtime = new Input()
      {
        private static final long serialVersionUID = 1268037036474796569L;

		public void showMessage()
        {
          ability.setStackDescription(card +" gains flying until EOT.");
          stopSetNext(new Input_PayManaCost(ability));
        }
      };
      ability.setStackDescription("Whiptongue Frog gains flying until EOT.");
      ability.setDescription("U: Whiptongue Frog gains flying until end of turn.");
      card.addSpellAbility(ability);
      ability.setBeforePayMana(runtime);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Sarcomite Myr"))
    {
      //mana ability - targets itself - until EOT
      final Command untilEOT = new Command()
      {
        private static final long serialVersionUID = -1726670429352834671L;

		public void execute()
        {
          card.removeIntrinsicKeyword("Flying");
        }
      };

      //mana tap ability
      final Ability ability = new Ability(card, "2")
      {
        public boolean canPlayAI()
        {
          return (! card.hasSickness()) &&
                 (! card.getKeyword().contains("Flying")) &&
                 (AllZone.Phase.getPhase().equals(Constant.Phase.Main1));
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(card))
          {
            card.addIntrinsicKeyword("Flying");
            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };//SpellAbility


      Input runtime = new Input()
      {
        private static final long serialVersionUID = -685958984421033465L;

		public void showMessage()
        {
          ability.setStackDescription(card +" gains flying until EOT.");
          stopSetNext(new Input_PayManaCost(ability));
        }
      };
      ability.setStackDescription(card +" - gains flying until EOT.");
      ability.setDescription("2: Sarcomite Myr gains flying until end of turn.");
      card.addSpellAbility(ability);
      ability.setBeforePayMana(runtime);

      //ability 2
      final Ability ability2 = new Ability(card, "2")
      {
        public boolean canPlayAI()
        {
          return false;
        }

        public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());
        }//resolve()
      };//SpellAbility

      card.addSpellAbility(ability2);
      ability2.setDescription("2, Sacrifice Sarcomite Myr: Draw a card.");
      ability2.setStackDescription("Sarcomite Myr - draw a card");
      ability2.setBeforePayMana(new Input_PayManaCost_Ability(ability2.getManaCost(), new Command()
      {
        private static final long serialVersionUID = -4357239016463815380L;

		public void execute()
        {
          AllZone.GameAction.sacrifice(card);
          AllZone.Stack.add(ability2);
        }
      }));

    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Goblin Balloon Brigade"))
    {
      //mana ability - targets itself - until EOT
      final Command untilEOT = new Command()
      {
        private static final long serialVersionUID = 3574792977266468264L;

		public void execute()
        {
          if(AllZone.GameAction.isCardInPlay(card))
            card.removeIntrinsicKeyword("Flying");
        }
      };

      //mana tap ability
      final Ability ability = new Ability(card, "R")
      {
        public boolean canPlayAI()
        {
          CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, false);
          return flying.isEmpty()    &&
              (! card.hasSickness()) &&
              (! card.getKeyword().contains("Flying")) &&
              (! CardFactoryUtil.AI_getHumanCreature(card, true).isEmpty());
        }
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(card))
          {
            card.addIntrinsicKeyword("Flying");
            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };//SpellAbility


      Input runtime = new Input()
      {
        private static final long serialVersionUID = 7757347395564372034L;

		public void showMessage()
        {
          ability.setStackDescription(card +" gains flying until EOT.");
          stopSetNext(new Input_PayManaCost(ability));
        }
      };
      ability.setStackDescription("Goblin Balloon Brigade gains flying until EOT.");
      ability.setDescription("R: Goblin Balloon Brigade gains flying until end of turn.");
      card.addSpellAbility(ability);
      ability.setBeforePayMana(runtime);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Manta Riders"))
    {
      //mana ability - targets itself - until EOT
      final Command untilEOT = new Command()
      {
        private static final long serialVersionUID = -8732007889935536106L;

		public void execute()
        {
          if(AllZone.GameAction.isCardInPlay(card))
            card.removeIntrinsicKeyword("Flying");
        }
      };

      //mana tap ability
      final Ability ability = new Ability(card, "U")
      {
        public boolean canPlayAI()
        {
          CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, false);
          return flying.isEmpty()    &&
              (! card.hasSickness()) &&
              (! card.getKeyword().contains("Flying")) &&
              (! CardFactoryUtil.AI_getHumanCreature(card, true).isEmpty());
        }
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(card))
          {
            card.addIntrinsicKeyword("Flying");
            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };//SpellAbility


      Input runtime = new Input()
      {
        private static final long serialVersionUID = -3889041123558196949L;

		public void showMessage()
        {
          ability.setStackDescription(card +" gains flying until EOT.");
          stopSetNext(new Input_PayManaCost(ability));
        }
      };
      ability.setStackDescription(card.getName() +" gains flying until EOT.");
      ability.setDescription("U: Manta Riders gains flying until end of turn.");
      card.addSpellAbility(ability);
      ability.setBeforePayMana(runtime);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Turtleshell Changeling"))
    {
      //mana ability - targets itself - until EOT
      //mana ability
      final Ability ability = new Ability(card, "1 U")
      {
        public boolean canPlayAI()
        {
          return CardFactoryUtil.AI_doesCreatureAttack(card) && card.getNetAttack() == 1;
        }
        public void resolve()
        {
          //in case ability is played twice
          final int[] oldAttack = new int[1];
          final int[] oldDefense = new int[1];

          oldAttack[0]  = card.getBaseAttack();
          oldDefense[0] = card.getBaseDefense();

          card.setBaseAttack(oldDefense[0]);
          card.setBaseDefense(oldAttack[0]);

          //EOT
          final Command untilEOT = new Command()
          {
            private static final long serialVersionUID = -5494886974452901728L;

			public void execute()
            {
              card.setBaseAttack(oldAttack[0]);
              card.setBaseDefense(oldDefense[0]);
            }
          };

          AllZone.EndOfTurn.addUntil(untilEOT);
        }//resolve()
      };//SpellAbility


      ability.setStackDescription(card +" - switch power and toughness until EOT.");
      ability.setDescription("1 U: Switch Turtleshell Changeling's power and toughness until end of turn.");
      card.addSpellAbility(ability);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Wings of Velis Vel"))
    {
      final SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -5744842090293912606L;
		public boolean canPlayAI()
        {
          Combat combat = ComputerUtil.getAttackers();
          @SuppressWarnings("unused") // attack
		  Card[] attack = combat.getAttackers();

          CardList small = new CardList(AllZone.Computer_Play.getCards());
          small = small.getType("Creature");

          //try to make a good attacker
          if(0 < small.size())
          {
            CardListUtil.sortAttackLowFirst(small);
            setTargetCard(small.get(0));

            return true && AllZone.Phase.getPhase().equals(Constant.Phase.Main1);
          }

          return false;
        }//canPlayAI()
        public void resolve()
        {
          //in case ability is played twice
          final int[] oldAttack = new int[1];
          final int[] oldDefense = new int[1];

          final Card card[] = new Card[1];
          card[0] = getTargetCard();

          oldAttack[0]  = card[0].getBaseAttack();
          oldDefense[0] = card[0].getBaseDefense();

          card[0].setBaseAttack(4);
          card[0].setBaseDefense(4);
          card[0].addExtrinsicKeyword("Flying");

          //EOT
          final Command untilEOT = new Command()
          {
            private static final long serialVersionUID = 7236360479349324099L;

			public void execute()
            {
              card[0].setBaseAttack(oldAttack[0]);
              card[0].setBaseDefense(oldDefense[0]);

              card[0].removeExtrinsicKeyword("Flying");
            }
          };

          AllZone.EndOfTurn.addUntil(untilEOT);
        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
    }//*************** END ************ END **************************



/*
    //*************** START *********** START **************************
if(cardName.equals("Epic Proportions"))
{
  final SpellAbility spell = new Spell(card)
  {
	private static final long serialVersionUID = 358340213887424783L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      setTargetCard(list.get(0));
      return true;
    }//canPlayAI()
    public void resolve()
    {
      Card c = getTargetCard();
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, getTargetCard()) )
      {
        c.addSemiPermanentAttackBoost(5);
        c.addSemiPermanentDefenseBoost(5);
        c.addExtrinsicKeyword("Trample");
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);

  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

*/

    
    
    
//*************** START *********** START **************************
if(cardName.equals("Epic Proportions"))
{
  final SpellAbility spell = new Spell(card)
  {
	private static final long serialVersionUID = 358340213887424783L;
	
	public boolean canPlay()
	{
		return true; // for flash, which is not working through the keyword for some reason
	}
	
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      setTargetCard(list.get(0));
      return true;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
      
      Card c = getTargetCard();
      
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
    	  card.enchantCard(c);
    	  System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
  
  Command onEnchant = new Command()
  {    
	private static final long serialVersionUID = 5133552158526053493L;

	public void execute()
      {
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addExtrinsicKeyword("Trample");
				crd.addSemiPermanentAttackBoost(5);
				crd.addSemiPermanentDefenseBoost(5);
			}  
      }//execute()
  };//Command
  

  Command onUnEnchant = new Command()
  {    
	    private static final long serialVersionUID = -2404250578944336031L;
	
		public void execute()
		{
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.removeExtrinsicKeyword("Trample");
				crd.addSemiPermanentAttackBoost(-5);					
				crd.addSemiPermanentDefenseBoost(-5);
			}
	    
		}//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {
	private static final long serialVersionUID = -6076263565995301138L;

	public void execute()
	   {
		   if (card.isEnchanting())
		   {
			   Card crd = card.getEnchanting().get(0);
			   card.unEnchantCard(crd);
		   }
	   }
   };
  
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
  
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Mythic Proportions"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 4227124619270545652L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      setTargetCard(list.get(0));
      return true;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
      
      Card c = getTargetCard();
      
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
    	  card.enchantCard(c);
    	  System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
  
  Command onEnchant = new Command()
  {    
	private static final long serialVersionUID = -6642467768059387172L;

	public void execute()
      {
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addExtrinsicKeyword("Trample");
				crd.addSemiPermanentAttackBoost(8);
				crd.addSemiPermanentDefenseBoost(8);
			}  
      }//execute()
  };//Command
  

  Command onUnEnchant = new Command()
  {    
	
	  	private static final long serialVersionUID = 3550678810412528973L;

		public void execute()
		{
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.removeExtrinsicKeyword("Trample");
				crd.addSemiPermanentAttackBoost(-8);					
				crd.addSemiPermanentDefenseBoost(-8);
			}
	    
		}//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {
	private static final long serialVersionUID = -8590925715809196436L;

	public void execute()
	   {
		   if (card.isEnchanting())
		   {
			   Card crd = card.getEnchanting().get(0);
			   card.unEnchantCard(crd);
		   }
	   }
   };
  
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
  
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Nimbus Wings"))
{
  final SpellAbility spell = new Spell(card)
  {


	private static final long serialVersionUID = -4759884801420518565L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
         if (CardFactoryUtil.canTarget(card, list.get(i)))
         {
            setTargetCard(list.get(i));
            return true;
         }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);

  Command onEnchant = new Command()
  {   

   /**
	 * 
	 */
	private static final long serialVersionUID = 4941909585318384005L;

public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
      crd.addSemiPermanentAttackBoost(1);
            crd.addSemiPermanentDefenseBoost(2);
           
      crd.addExtrinsicKeyword("Flying");
         }
      }//execute()
  };//Command


  Command onUnEnchant = new Command()
  {   

	private static final long serialVersionUID = -728144711022713882L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
        crd.addSemiPermanentAttackBoost(-1);
            crd.addSemiPermanentDefenseBoost(-2);
           
       crd.removeExtrinsicKeyword("Flying");
         }
     
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {


	private static final long serialVersionUID = -8808281961367126149L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };

  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);

  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************


//*************** START *********** START **************************
if(cardName.equals("Hero's Resolve"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = -4759884801420518565L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
         if (CardFactoryUtil.canTarget(card, list.get(i)))
         {
            setTargetCard(list.get(i));
            return true;
         }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);

  Command onEnchant = new Command()
  {
	  
	private static final long serialVersionUID = 4941909585318384005L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addSemiPermanentAttackBoost(1);
            crd.addSemiPermanentDefenseBoost(5);
           
         }
      }//execute()
  };//Command


  Command onUnEnchant = new Command()
  {   


	private static final long serialVersionUID = -728144711022713882L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addSemiPermanentAttackBoost(-1);
            crd.addSemiPermanentDefenseBoost(-5);
           
         }
     
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -8808281961367126149L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };

  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);

  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************


//*************** START *********** START **************************
if(cardName.equals("Holy Strength"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 7142921886192227052L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
      
      Card c = getTargetCard();
      
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
    	  card.enchantCard(c);
    	  //System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
  
  Command onEnchant = new Command()
  {    

	private static final long serialVersionUID = 29524607366962807L;

	public void execute()
      {
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addSemiPermanentAttackBoost(1);
				crd.addSemiPermanentDefenseBoost(2);
			}  
      }//execute()
  };//Command
  

  Command onUnEnchant = new Command()
  {    
	
	private static final long serialVersionUID = -3236907619285510709L;

	public void execute()
	{
		if (card.isEnchanting())
		{
			Card crd = card.getEnchanting().get(0);
			crd.addSemiPermanentAttackBoost(-1);					
			crd.addSemiPermanentDefenseBoost(-2);
		}
    
	}//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -4543302260602460839L;

	public void execute()
	   {
		   if (card.isEnchanting())
		   {
			   Card crd = card.getEnchanting().get(0);
			   card.unEnchantCard(crd);
		   }
	   }
   };
  
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
  
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Unholy Strength"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 249022827643646119L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
      
      Card c = getTargetCard();
      
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
    	  card.enchantCard(c);
    	  //System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
  
  Command onEnchant = new Command()
  {    

	private static final long serialVersionUID = 3550678810412528973L;

	public void execute()
      {
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addSemiPermanentAttackBoost(2);
				crd.addSemiPermanentDefenseBoost(1);
			}  
      }//execute()
  };//Command
  

  Command onUnEnchant = new Command()
  {    
	
	private static final long serialVersionUID = -8590925715809196436L;

		public void execute()
		{
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addSemiPermanentAttackBoost(-2);					
				crd.addSemiPermanentDefenseBoost(-1);
			}
	    
		}//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = 3368827667218463197L;

	public void execute()
	   {
		   if (card.isEnchanting())
		   {
			   Card crd = card.getEnchanting().get(0);
			   card.unEnchantCard(crd);
		   }
	   }
   };
  
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
  
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Weakness"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 3959966663907905001L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Human_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
      
      Card c = getTargetCard();
      
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
    	  card.enchantCard(c);
    	  //System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
  
  Command onEnchant = new Command()
  {    

	private static final long serialVersionUID = -2365466450520529652L;

	public void execute()
    {
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addSemiPermanentAttackBoost(-2);
				crd.addSemiPermanentDefenseBoost(-1);
			}  
    }//execute()
  };//Command
  

  Command onUnEnchant = new Command()
  {    

	  	private static final long serialVersionUID = 8144460293841806556L;

		public void execute()
		{
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addSemiPermanentAttackBoost(2);					
				crd.addSemiPermanentDefenseBoost(1);
			}
	    
		}//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	   private static final long serialVersionUID = -8235558710156197207L;

	   public void execute()
	   {
		   if (card.isEnchanting())
		   {
			   Card crd = card.getEnchanting().get(0);
			   card.unEnchantCard(crd);
		   }
	   }
   };
  
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
  
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Guilty Conscience"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 1169151960692309514L;
	public boolean canPlayAI()
    {
		
      CardList stuffy = new CardList(AllZone.Computer_Play.getCards());
      stuffy = stuffy.getName("Stuffy Doll");
      
      if (stuffy.size() > 0)
      {
    	  setTargetCard(stuffy.get(0));
    	  return true;
      }
      else 
      {
	      CardList list = new CardList(AllZone.Human_Play.getCards());
	      list = list.getType("Creature");
	
	      if(list.isEmpty())
	    	  return false;
	
	      //else
	      CardListUtil.sortAttack(list);
	      CardListUtil.sortFlying(list);
	
	      for (int i=0;i<list.size();i++) {
		      if (CardFactoryUtil.canTarget(card, list.get(i)) && (list.get(i).getNetAttack() >= list.get(i).getNetDefense()) && list.get(i).getNetAttack() >= 3)
		      {
			      setTargetCard(list.get(i));
			      return true;
		      }
	      }
      }
      return false;
      
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
      
      Card c = getTargetCard();
      
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
    	  card.enchantCard(c);
      
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
  
  
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Cessation"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 3681531440398159146L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Human_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)) && !list.get(i).getKeyword().contains("Defender"))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
      
      Card c = getTargetCard();
      
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
    	  card.enchantCard(c);
    	  //System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
  
  Command onEnchant = new Command()
  {    

	private static final long serialVersionUID = -5544484800605477434L;

	public void execute()
    {
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addExtrinsicKeyword("This creature can't attack");
			}  
    }//execute()
  };//Command
  

  Command onUnEnchant = new Command()
  {    
	  	private static final long serialVersionUID = 3621591534173743090L;

		public void execute()
		{
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.removeExtrinsicKeyword("This creature can't attack");
			}
	    
		}//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -6043933114268403555L;

	public void execute()
	   {
		   if (card.isEnchanting())
		   {
			   Card crd = card.getEnchanting().get(0);
			   card.unEnchantCard(crd);
		   }
	   }
   };
  
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
  
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Pacifism") || cardName.equals("Bound in Silence"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = -1357026258424339999L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Human_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)) && !list.get(i).getKeyword().contains("Defender"))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
      
      Card c = getTargetCard();
      
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
    	  card.enchantCard(c);
    	  //System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
  
  Command onEnchant = new Command()
  {    

	private static final long serialVersionUID = -897162953903978929L;

	public void execute()
    {
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addExtrinsicKeyword("This creature can't attack or block");
			}  
    }//execute()
  };//Command
  

  Command onUnEnchant = new Command()
  {    
	    private static final long serialVersionUID = 3461412526408858199L;

		public void execute()
		{
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.removeExtrinsicKeyword("This creature can't attack or block");
			}
	    
		}//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -4922257746317147308L;

	public void execute()
	   {
		   if (card.isEnchanting())
		   {
			   Card crd = card.getEnchanting().get(0);
			   card.unEnchantCard(crd);
		   }
	   }
   };
  
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
  
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Pillory of the Sleepless"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 4504925036782582195L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Human_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)) && !list.get(i).getKeyword().contains("Defender"))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
      
      Card c = getTargetCard();
      
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
    	  card.enchantCard(c);
    	  //System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
  
  Command onEnchant = new Command()
  {    

	private static final long serialVersionUID = -6104532173397759007L;

	public void execute()
    {
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addExtrinsicKeyword("This creature can't attack or block");
			}  
    }//execute()
  };//Command
  

  Command onUnEnchant = new Command()
  {    

	private static final long serialVersionUID = -2563098134722661731L;

		public void execute()
		{
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.removeExtrinsicKeyword("This creature can't attack or block");
			}
	    
		}//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -1621250313053538491L;

	public void execute()
	   {
		   if (card.isEnchanting())
		   {
			   Card crd = card.getEnchanting().get(0);
			   card.unEnchantCard(crd);
		   }
	   }
   };
  
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
  
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Brilliant Halo"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 3959966663907905001L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
      
      Card c = getTargetCard();
      
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
    	  card.enchantCard(c);

    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
  
  Command onEnchant = new Command()
  {    

	private static final long serialVersionUID = -2365466450520529652L;

	public void execute()
    {
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addSemiPermanentAttackBoost(1);
				crd.addSemiPermanentDefenseBoost(2);
			}  
      }//execute()
  };//Command
  

  Command onUnEnchant = new Command()
  {    
	

	  	private static final long serialVersionUID = 8144460293841806556L;

		public void execute()
		{
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addSemiPermanentAttackBoost(-1);					
				crd.addSemiPermanentDefenseBoost(-2);
			}
	    
		}//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -8235558710156197207L;

	public void execute()
	{
		   if (card.isEnchanting())
		   {
			   Card crd = card.getEnchanting().get(0);
			   card.unEnchantCard(crd);
		   }
	 }
   };
  
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
  
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Cloak of Mists"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 1349252919350703923L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);

  Command onEnchant = new Command()
  {   

   
	private static final long serialVersionUID = -5477386150275605685L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addExtrinsicKeyword("Unblockable");
         }
      }//execute()
  };//Command


  Command onUnEnchant = new Command()
  {   


	private static final long serialVersionUID = -1458403756319532488L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.removeExtrinsicKeyword("Unblockable");
         }
     
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = 2970703965180562317L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };

  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);

  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Indomitable Will"))
{
  final SpellAbility spell = new Spell(card)
  {
      
  
	private static final long serialVersionUID = -8730555134087764706L;
	public boolean canPlay()
    {
      return true; // for flash, which is not working through the keyword for some reason
    }
   
   public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
 
  Command onEnchant = new Command()
  {   
   	private static final long serialVersionUID = -9017595501743099736L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addSemiPermanentAttackBoost(1);
            crd.addSemiPermanentDefenseBoost(2);
         } 
      }//execute()
  };//Command
 

  Command onUnEnchant = new Command()
  {   

	private static final long serialVersionUID = -301746096442890239L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            
            crd.addSemiPermanentAttackBoost(-1);               
            crd.addSemiPermanentDefenseBoost(-2);
         }
      
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {
   
	private static final long serialVersionUID = 4866639414492912349L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };
 
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
 
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Uncontrollable Anger"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = -817670112637191266L;
	
	//for flash, keyword somehow doesn't work
	public boolean canPlay()
	{
		return true;
	}
	
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
         if (CardFactoryUtil.canTarget(card, list.get(i)))
         {
            setTargetCard(list.get(i));
            return true;
         }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);

  Command onEnchant = new Command()
  {   

	private static final long serialVersionUID = 3621591534173743090L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addSemiPermanentAttackBoost(2);
            crd.addSemiPermanentDefenseBoost(2);
       crd.addExtrinsicKeyword("This card attacks each turn if able.");
         }
      }//execute()
  };//Command


  Command onUnEnchant = new Command()
  {   

	private static final long serialVersionUID = -6043933114268403555L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addSemiPermanentAttackBoost(-2);               
            crd.addSemiPermanentDefenseBoost(-2);
      crd.removeExtrinsicKeyword("This card attacks each turn if able.");
         }
     
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -1854544543762078840L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };

  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);

  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Fear"))
{
  final SpellAbility spell = new Spell(card)
  {
	private static final long serialVersionUID = 1538560397393051959L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
         if (CardFactoryUtil.canTarget(card, list.get(i)))
         {
            setTargetCard(list.get(i));
            return true;
         }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);

  Command onEnchant = new Command()
  {   

	private static final long serialVersionUID = 3461412526408858199L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addExtrinsicKeyword("Fear");
         }
      }//execute()
  };//Command


  Command onUnEnchant = new Command()
  {   

	private static final long serialVersionUID = -4922257746317147308L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.removeExtrinsicKeyword("Fear");
         }
     
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {
	private static final long serialVersionUID = 8802824404322172485L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };

  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);

  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Battle Mastery"))
{
  final SpellAbility spell = new Spell(card)
  {


	private static final long serialVersionUID = 1538560397393051959L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
         if (CardFactoryUtil.canTarget(card, list.get(i)))
         {
            setTargetCard(list.get(i));
            return true;
         }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);

  Command onEnchant = new Command()
  {   

	private static final long serialVersionUID = 3461412526408858199L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addExtrinsicKeyword("Double Strike");
         }
      }//execute()
  };//Command


  Command onUnEnchant = new Command()
  {   

	private static final long serialVersionUID = -4922257746317147308L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.removeExtrinsicKeyword("Double Strike");
         }
     
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = 8802824404322172485L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };

  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);

  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Protective Bubble"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = -5744948616351896881L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
         if (CardFactoryUtil.canTarget(card, list.get(i)))
         {
            setTargetCard(list.get(i));
            return true;
         }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);

  Command onEnchant = new Command()
  {   

	private static final long serialVersionUID = -7504975809719164916L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addExtrinsicKeyword("Shroud");
            crd.addExtrinsicKeyword("Unblockable");
         }
      }//execute()
  };//Command


  Command onUnEnchant = new Command()
  {   

	private static final long serialVersionUID = -5732248224429180503L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.removeExtrinsicKeyword("Shroud");
            crd.removeExtrinsicKeyword("Unblockable");
         }
     
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -5677600048500997627L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };

  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);

  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Zephid's Embrace"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = -375053523089273410L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
         if (CardFactoryUtil.canTarget(card, list.get(i)))
         {
            setTargetCard(list.get(i));
            return true;
         }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);

  Command onEnchant = new Command()
  {   

	private static final long serialVersionUID = 7818182838059001941L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addSemiPermanentAttackBoost(2);
            crd.addSemiPermanentDefenseBoost(2);
            crd.addExtrinsicKeyword("Shroud");
            crd.addExtrinsicKeyword("Flying");
         }
      }//execute()
  };//Command


  Command onUnEnchant = new Command()
  {   


	private static final long serialVersionUID = 8038970743056290484L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addSemiPermanentAttackBoost(-2);
            crd.addSemiPermanentDefenseBoost(-2);
            crd.removeExtrinsicKeyword("Shroud");
            crd.removeExtrinsicKeyword("Flying");
         }
     
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {
	private static final long serialVersionUID = 104098395022764345L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };

  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);

  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Goblin War Paint"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = -959968424187950430L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
         if (CardFactoryUtil.canTarget(card, list.get(i)))
         {
            setTargetCard(list.get(i));
            return true;
         }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);

  Command onEnchant = new Command()
  {   

	private static final long serialVersionUID = 9074991509563203771L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addSemiPermanentAttackBoost(2);
            crd.addSemiPermanentDefenseBoost(2);
           
            crd.addExtrinsicKeyword("Haste");
         }
      }//execute()
  };//Command


  Command onUnEnchant = new Command()
  {   

	private static final long serialVersionUID = 720578490253659248L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
        crd.addSemiPermanentAttackBoost(-2);
            crd.addSemiPermanentDefenseBoost(-2);
           
       crd.removeExtrinsicKeyword("Haste");
         }
     
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -8089111708519929350L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };

  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);

  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Paralyzing Grasp"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = -2685360795445503449L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Human_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
         if (CardFactoryUtil.canTarget(card, list.get(i)))
         {
            setTargetCard(list.get(i));
            return true;
         }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);

  Command onEnchant = new Command()
  {   

	private static final long serialVersionUID = -380913483412563006L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
         crd.addExtrinsicKeyword("This card does not untap during your untap phase");
         }
      }//execute()
  };//Command


  Command onUnEnchant = new Command()
  {   

	private static final long serialVersionUID = 4534224467226579803L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
                   
            crd.removeExtrinsicKeyword("This card does not untap during your untap phase");
         }
     
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -2513967225177113996L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };

  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);

  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************




//*************** START *********** START **************************
if(cardName.equals("Undying Rage"))
{
	final SpellAbility spell = new Spell(card)
	{
	
		private static final long serialVersionUID = 7688777028599839669L;
		public boolean canPlayAI()
		{
			CardList list = new CardList(AllZone.Computer_Play.getCards());
			list = list.getType("Creature");
			
			if(list.isEmpty())
			return false;
			
			//else
			CardListUtil.sortAttack(list);
			CardListUtil.sortFlying(list);
			
			for (int i=0;i<list.size();i++) {
			      if (CardFactoryUtil.canTarget(card, list.get(i)))
			      {
				      setTargetCard(list.get(i));
				      return true;
			      }
		      }
		      return false;		
		 }//canPlayAI()
		public void resolve()
		{
			PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
			play.add(card);
			
			Card c = getTargetCard();
			
			if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, c) )
			card.enchantCard(c);
			
		}//resolve()
	};//SpellAbility
	card.clearSpellAbility();
	card.addSpellAbility(spell);
	
	Command onEnchant = new Command()
	{

		private static final long serialVersionUID = 5090552789458764964L;

		public void execute()
		{
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addSemiPermanentAttackBoost(+2);
				crd.addSemiPermanentDefenseBoost(+2);
				crd.addExtrinsicKeyword("This creature cannot block");
			}
		}//execute()
	};//Command
	
	
	Command onUnEnchant = new Command()
	{

		private static final long serialVersionUID = -82584999448000826L;

		public void execute()
		{
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.removeExtrinsicKeyword("This creature cannot block");
				crd.addSemiPermanentAttackBoost(-2);
				crd.addSemiPermanentDefenseBoost(-2);
			}
			
		}//execute()
	};//Command
	
	Command onLeavesPlay = new Command()
	{
	
		private static final long serialVersionUID = -4577373116316893192L;

		public void execute()
		{
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				card.unEnchantCard(crd);
			}
		}
	};
	
	card.addEnchantCommand(onEnchant);
	card.addUnEnchantCommand(onUnEnchant);
	card.addLeavesPlayCommand(onLeavesPlay);
	
	spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************



//*************** START *********** START **************************
if(cardName.equals("Rancor"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 7142921886192227052L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
      
      Card c = getTargetCard();
      
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
    	  card.enchantCard(c);

    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
  
  Command onEnchant = new Command()
  {    

	private static final long serialVersionUID = 29524607366962807L;

	public void execute()
    {
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.addExtrinsicKeyword("Trample");
				crd.addSemiPermanentAttackBoost(2);
			}  
      }//execute()
  };//Command
  

  Command onUnEnchant = new Command()
  {    
	
	private static final long serialVersionUID = -3236907619285510709L;

		public void execute()
		{
			if (card.isEnchanting())
			{
				Card crd = card.getEnchanting().get(0);
				crd.removeExtrinsicKeyword("Trample");
				crd.addSemiPermanentAttackBoost(-2);					
			}
	    
		}//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -4543302260602460839L;

	public void execute()
	{
		   if (card.isEnchanting())
		   {
			   Card crd = card.getEnchanting().get(0);
			   card.unEnchantCard(crd);
		   }
	   }
   };
  
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
  
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Armadillo Cloak"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 7414947327367193959L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
 
  Command onEnchant = new Command()
  {   

	private static final long serialVersionUID = -8808281961367126149L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addExtrinsicKeyword("Trample");
            crd.addExtrinsicKeyword("Lifelink");
            crd.addSemiPermanentAttackBoost(2);
            crd.addSemiPermanentDefenseBoost(2);
         } 
      }//execute()
  };//Command
 

  Command onUnEnchant = new Command()
  {   
   
	private static final long serialVersionUID = -3634342116735279715L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.removeExtrinsicKeyword("Trample");

            crd.removeExtrinsicKeyword("Lifelink");
   
            crd.addSemiPermanentAttackBoost(-2);               
            crd.addSemiPermanentDefenseBoost(-2);
         }
      
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {
   

	private static final long serialVersionUID = 648546709124047998L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };
 
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
 
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Serra's Embrace"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 4710595790920367640L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
 
  Command onEnchant = new Command()
  {   

	private static final long serialVersionUID = 8209539652143050311L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addExtrinsicKeyword("Flying");
            crd.addExtrinsicKeyword("Vigilance");
            crd.addSemiPermanentAttackBoost(2);
            crd.addSemiPermanentDefenseBoost(2);
         } 
      }//execute()
  };//Command
 

  Command onUnEnchant = new Command()
  {   
	private static final long serialVersionUID = 8569667869488235349L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.removeExtrinsicKeyword("Flying");
            crd.removeExtrinsicKeyword("Vigilance");
            crd.addSemiPermanentAttackBoost(-2);               
            crd.addSemiPermanentDefenseBoost(-2);
         }
      
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -515072286191538396L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };
 
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
 
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Wings of Hope"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = -8219002552125665610L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
 
  Command onEnchant = new Command()
  {   

	private static final long serialVersionUID = 615799578787695739L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addExtrinsicKeyword("Flying");
            crd.addSemiPermanentAttackBoost(1);
            crd.addSemiPermanentDefenseBoost(3);
         } 
      }//execute()
  };//Command
 

  Command onUnEnchant = new Command()
  {   
   
	private static final long serialVersionUID = -3945180659632792182L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.removeExtrinsicKeyword("Flying");
            crd.addSemiPermanentAttackBoost(-1);               
            crd.addSemiPermanentDefenseBoost(-3);
         }
      
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {
   
	private static final long serialVersionUID = -5544484800605477434L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };
 
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
 
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("AEther Web"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = -5744948616351896881L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
 
  Command onEnchant = new Command()
  {   

	private static final long serialVersionUID = -7504975809719164916L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addExtrinsicKeyword("Reach");
            crd.addExtrinsicKeyword("This creature can block creatures with shadow as though they didn't have shadow.");
            crd.addSemiPermanentAttackBoost(1);
            crd.addSemiPermanentDefenseBoost(1);
         } 
      }//execute()
  };//Command
 

  Command onUnEnchant = new Command()
  {   

	private static final long serialVersionUID = -5732248224429180503L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.removeExtrinsicKeyword("Reach");
            crd.removeExtrinsicKeyword("This creature can block creatures with shadow as though they didn't have shadow.");
            crd.addSemiPermanentAttackBoost(-1);               
            crd.addSemiPermanentDefenseBoost(-1);
         }
      
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -5677600048500997627L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };
 
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
 
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************


//*************** START *********** START **************************
if(cardName.equals("Launch") || cardName.equals("Flight"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 4710595790920367640L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
 
  Command onEnchant = new Command()
  {   

	private static final long serialVersionUID = 8209539652143050311L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addExtrinsicKeyword("Flying");
                     } 
      }//execute()
  };//Command
 

  Command onUnEnchant = new Command()
  {   

	private static final long serialVersionUID = 8569667869488235349L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.removeExtrinsicKeyword("Flying");

         }
      
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {

	private static final long serialVersionUID = -515072286191538396L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };
 
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
 
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Aspect of Mongoose") || cardName.equals("Robe of Mirrors") || cardName.equals("Diplomatic Immunity"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = -8219002552125665610L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
 
  Command onEnchant = new Command()
  {   
	private static final long serialVersionUID = 615799578787695739L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addExtrinsicKeyword("Shroud");
                     } 
      }//execute()
  };//Command
 

  Command onUnEnchant = new Command()
  {   
   
	private static final long serialVersionUID = -3945180659632792182L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.removeExtrinsicKeyword("Shroud");

         }
      
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {
   
	private static final long serialVersionUID = -5544484800605477434L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };
 
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
 
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Sleeper's Guile"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = -8219002552125665610L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
 
  Command onEnchant = new Command()
  {   

	private static final long serialVersionUID = 615799578787695739L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addExtrinsicKeyword("Fear");
         } 
      }//execute()
  };//Command
 

  Command onUnEnchant = new Command()
  {   
   
	private static final long serialVersionUID = -3945180659632792182L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.removeExtrinsicKeyword("Fear");

         }
      
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {
   
	private static final long serialVersionUID = -5544484800605477434L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };
 
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
 
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************

//*************** START *********** START **************************
if(cardName.equals("Sluggishness"))
{
  final SpellAbility spell = new Spell(card)
  {

	private static final long serialVersionUID = 5184457180419402397L;
	public boolean canPlayAI()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      list = list.getType("Creature");

      if(list.isEmpty())
       return false;

      //else
      CardListUtil.sortAttack(list);
      CardListUtil.sortFlying(list);

      for (int i=0;i<list.size();i++) {
	      if (CardFactoryUtil.canTarget(card, list.get(i)))
	      {
		      setTargetCard(list.get(i));
		      return true;
	      }
      }
      return false;
    }//canPlayAI()
    public void resolve()
    {
      PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
      play.add(card);
     
      Card c = getTargetCard();
     
      if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
      {
         card.enchantCard(c);
         System.out.println("Enchanted: " +getTargetCard());
      }
    }//resolve()
  };//SpellAbility
  card.clearSpellAbility();
  card.addSpellAbility(spell);
 
  Command onEnchant = new Command()
  {   


	private static final long serialVersionUID = -6043933114268403555L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.addExtrinsicKeyword("This creature can't block");
         } 
      }//execute()
  };//Command
 

  Command onUnEnchant = new Command()
  {   
   
	private static final long serialVersionUID = -1854544543762078840L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            crd.removeExtrinsicKeyword("This creature can't block");

         }
      
      }//execute()
   };//Command
   
   Command onLeavesPlay = new Command()
   {
   
	private static final long serialVersionUID = -897162953903978929L;

	public void execute()
      {
         if (card.isEnchanting())
         {
            Card crd = card.getEnchanting().get(0);
            card.unEnchantCard(crd);
         }
      }
   };
 
  card.addEnchantCommand(onEnchant);
  card.addUnEnchantCommand(onUnEnchant);
  card.addLeavesPlayCommand(onLeavesPlay);
 
  spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
}//*************** END ************ END **************************


//*************** START *********** START **************************
if(cardName.equals("Jugan, the Rising Star"))
{
  final SpellAbility ability = new Ability(card, "0")
  {
    //should the computer play this card?
    public boolean canPlayAI()
    {
      return (getComputerCreatures().size() != 0);
    }
    //set the target for the computer AI
    public void chooseTargetAI()
    {
      CardList list = getComputerCreatures();

      if(0 < list.size())
        setTargetCard(list.get(0));
      else
        //the computer doesn't have any other creatures
        setTargetCard(null);
    }
    CardList getComputerCreatures()
    {
      CardList list = new CardList(AllZone.Computer_Play.getCards());
      CardList out = list.getType("Creature");
      return out;
    }//getCreatures
    public void resolve()
    {
      Card c = getTargetCard();
      if(c != null && AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, c) )
      {
        c.addCounter(Counters.P1P1, 5);
      }
    }//resolve()
  };
  ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));

  Command leavesPlay = new Command()
  {
	private static final long serialVersionUID = -2823505283781217181L;

	public void execute()
    {
      if(card.getController().equals(Constant.Player.Human))
        AllZone.InputControl.setInput(CardFactoryUtil.input_targetCreature(ability));
      else if(ability.canPlayAI())
      {
        ability.chooseTargetAI();
        //need to add this to the stack
        AllZone.Stack.push(ability);
      }


    }//execute()
  };//Command

  card.addDestroyCommand(leavesPlay);
}//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Lignify"))
    {
      final SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = 5323770119451400755L;
		public boolean canPlayAI()
        {
          CardList c = CardFactoryUtil.AI_getHumanCreature(card, true);
          CardListUtil.sortAttack(c);
          CardListUtil.sortFlying(c);

          if(c.isEmpty())
            return false;

          if(2 <= c.get(0).getNetAttack() && c.get(0).getKeyword().contains("Flying"))
          {
            setTargetCard(c.get(0));
            return true;
          }

          CardListUtil.sortAttack(c);
          if(4 <= c.get(0).getNetAttack())
          {
            setTargetCard(c.get(0));
            return true;
          }

          return false;
        }//canPlayAI()
        public void resolve()
        {
          Card c = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, c) )
          {
            c.setBaseAttack(0);
            c.setBaseDefense(4);

            c.setType(new ArrayList<String>());
            c.addType("Creature");
            c.addType("Treefolk");

            c.setIntrinsicKeyword(new ArrayList<String>());

            c.clearSpellAbility();
          }
        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
    }//*************** END ************ END **************************
   
    
  //*************** START *********** START **************************
    if(cardName.equals("Control Magic"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 7359753772138233155L;
		public boolean canPlayAI()
        {
          CardList c = CardFactoryUtil.AI_getHumanCreature(card, true);
          CardListUtil.sortAttack(c);
          CardListUtil.sortFlying(c);

          if(c.isEmpty())
            return false;

          if(2 <= c.get(0).getNetAttack() && c.get(0).getKeyword().contains("Flying"))
          {
            setTargetCard(c.get(0));
            return true;
          }

          CardListUtil.sortAttack(c);
          if(4 <= c.get(0).getNetAttack())
          {
            setTargetCard(c.get(0));
            return true;
          }

          return false;
        }//canPlayAI()
        public void resolve()
        {
        	
        	
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(card);
            
          Card c = getTargetCard();
            
          if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
        	  card.enchantCard(c);

        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      
      Command onEnchant = new Command()
      {    

		private static final long serialVersionUID = -3423649303706656587L;

		public void execute()
        {
    			if (card.isEnchanting())
    			{
    				Card crd = card.getEnchanting().get(0);
    				//set summoning sickness
    	            if(crd.getKeyword().contains("Haste")){
    	              crd.setSickness(false);
    	            }
    	            else{
    	              crd.setSickness(true);
    	            }
    	            
    	            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
    	            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);

    	            PlayerZone from = AllZone.getZone(crd);
    	            from.remove(crd);
    	           
    	            crd.setController(card.getController());

    	            PlayerZone to = AllZone.getZone(Constant.Zone.Play, card.getController());
    	            to.add(crd);

    	            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
    	            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
    			}  
          }//execute()
      };//Command
      
      Command onUnEnchant = new Command()
      {    

		private static final long serialVersionUID = -2365466450520529652L;

			public void execute()
    		{
    			if (card.isEnchanting())
    			{
    				Card crd = card.getEnchanting().get(0);
    				if (AllZone.GameAction.isCardInPlay(crd))
    				{
	    				if(crd.getKeyword().contains("Haste")){
	      	              crd.setSickness(false);
	      	            }
	      	            else{
	      	              crd.setSickness(true);
	      	            }
	      	            
	      	            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
	      	            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);
	
	      	            PlayerZone from = AllZone.getZone(crd);
	      	            from.remove(crd);
	      	           
	      	            String opp = AllZone.GameAction.getOpponent(crd.getController());
	      	            crd.setController(opp);
	
	      	            PlayerZone to = AllZone.getZone(Constant.Zone.Play, opp);
	      	            to.add(crd);
	
	      	            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
	      	            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
    				}
    			}
    	    
    		}//execute()
       };//Command
       
       Command onLeavesPlay = new Command()
       {


		private static final long serialVersionUID = 8144460293841806556L;

		public void execute()
    	{
    		   if (card.isEnchanting())
    		   {
    			   Card crd = card.getEnchanting().get(0);
    			   card.unEnchantCard(crd);
    		   }
    	   }
       };
      
      card.addEnchantCommand(onEnchant);
      card.addUnEnchantCommand(onUnEnchant);
      card.addLeavesPlayCommand(onLeavesPlay);
      

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    //destroy doesn't work
    if(cardName.equals("Sower of Temptation"))
    {
      final Card moveCreature[] = new Card[1];

      final SpellAbility spell = new Spell_Permanent(card)
      {
        private static final long serialVersionUID = -6432280175218503718L;
		public boolean canPlayAI()
        {
          CardList c = CardFactoryUtil.AI_getHumanCreature(card, true);
          CardListUtil.sortAttack(c);
          CardListUtil.sortFlying(c);

          if(c.isEmpty())
            return false;

          if(2 <= c.get(0).getNetAttack() && c.get(0).getKeyword().contains("Flying"))
          {
            setTargetCard(c.get(0));
            return true;
          }

          CardListUtil.sortAttack(c);
          if(4 <= c.get(0).getNetAttack())
          {
            setTargetCard(c.get(0));
            return true;
          }

          return false;
        }//canPlayAI()
        public void resolve()
        {
          super.resolve();

          Card c = getTargetCard();
          moveCreature[0] = c;

          if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
          {
        	  
        	//set summoning sickness
      		if(c.getKeyword().contains("Haste")){
      		  c.setSickness(false);
      		}
      		else{
      		  c.setSickness(true);
      		}
      		
            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);

            c.setSickness(true);
            c.setController(card.getController());

            PlayerZone from = AllZone.getZone(c);
            from.remove(c);

            PlayerZone to = AllZone.getZone(Constant.Zone.Play, card.getController());
            to.add(c);

            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
          }
        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));

      card.addLeavesPlayCommand(new Command()
      {
        private static final long serialVersionUID = -8961588142846220965L;

		public void execute()
        {
          Card c = moveCreature[0];

          if(AllZone.GameAction.isCardInPlay(c))
          {
            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);

            c.setSickness(true);
            c.setController(AllZone.GameAction.getOpponent(c.getController()));
            
            PlayerZone from = AllZone.getZone(c);
            from.remove(c);

            PlayerZone to = AllZone.getZone(Constant.Zone.Play, c.getOwner());
            to.add(c);

            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
          }//if
        }//execute()
      });//Command
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Terramorphic Expanse"))
    {
      //tap sacrifice
      final Ability_Tap ability = new Ability_Tap(card, "0")
      {
        private static final long serialVersionUID = 5441740362881917927L;

		public boolean canPlayAI()
        {
          return false;
          /*
          //sacrifice Sakura-Tribe Elder if Human has any creatures
          CardList list = new CardList(AllZone.Human_Play.getCards());
          list = list.getType("Creature");
          return list.size() != 0 && card.isUntapped();
          */
        }
        public void chooseTargetAI()
        {
          AllZone.GameAction.sacrifice(card);
        }
        public boolean canPlay()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          CardList list = new CardList(library.getCards());
          list = list.getType("Basic");
          if (list.size() > 0 && AllZone.GameAction.isCardInPlay(card))
        	  return true;
          else
        	 return false;
          		
        }//canPlay()
        public void resolve()
        {
          if(owner.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void computerResolve()
        {
          CardList play = new CardList(AllZone.Computer_Play.getCards());
          play = play.getType("Basic");

          CardList library = new CardList(AllZone.Computer_Library.getCards());
          library = library.getType("Basic");

          //this shouldn't happen, but it is defensive programming, haha
          if(library.isEmpty())
            return;

          Card land = null;

          //try to find a basic land that isn't in play
          for(int i = 0; i < library.size(); i++)
            if(! play.containsName(library.get(i)))
            {
              land = library.get(i);
              break;
            }

          //if not found
          //library will have at least 1 basic land because canPlay() checks that
          if(land == null)
            land = library.get(0);

          land.tap();
          AllZone.Computer_Library.remove(land);
          AllZone.Computer_Play.add(land);

          AllZone.GameAction.shuffle(Constant.Player.Computer);
        }//computerResolve()

        public void humanResolve()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          PlayerZone play    = AllZone.getZone(Constant.Zone.Play   , card.getController());

          CardList basicLand = new CardList(library.getCards());
          basicLand = basicLand.getType("Basic");

          Object o = AllZone.Display.getChoiceOptional("Choose a basic land", basicLand.toArray());
          if(o != null)
          {
            Card land = (Card)o;
            land.tap();

            library.remove(land);
            play.add(land);
          }
          AllZone.GameAction.shuffle(card.getController());
        }//resolve()
      };//SpellAbility

      Input runtime = new Input()
      {
        private static final long serialVersionUID = -4379321114820908030L;
		boolean once = true;
        public void showMessage()
        {
          //this is necessary in order not to have a StackOverflowException
          //because this updates a card, it creates a circular loop of observers
          if(once)
          {
            once = false;
            AllZone.GameAction.sacrifice(card);

            ability.setStackDescription(card.getController() +" - Search your library for a basic land card and put it into play tapped. Then shuffle your library.");
            AllZone.Stack.add(ability);

            stop();
          }
        }//showMessage()
      };
      card.addSpellAbility(ability);
      ability.setDescription("tap, Sacrifice Terramorphic Expanse: Search your library for a basic land card and put it into play tapped. Then shuffle your library.");
      ability.setBeforePayMana(runtime);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Frostling"))
    {
      final Ability ability = new Ability(card, "0")
      {
        public boolean canPlayAI() {return getCreature().size() != 0;}

        public void  chooseTargetAI()
        {
          CardList list = getCreature();
          list.shuffle();
          setTargetCard(list.get(0));

          AllZone.GameAction.sacrifice(card);
        }
        CardList getCreature()
        {
          //toughness of 1
          CardList list = CardFactoryUtil.AI_getHumanCreature(1, card, true);
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              //only get 1/1 flyers or 2/1 creatures
              return (2 <= c.getNetAttack()) || c.getKeyword().contains("Flying");
            }
          });
          return list;
        }//getCreature()

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
            getTargetCard().addDamage(1);
        }//resolve()
      };//SpellAbility

      card.addSpellAbility(ability);
      ability.setDescription("Sacrifice Frostling: Frostling deals 1 damage to target creature.");
      ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability, new Command()
      {
        private static final long serialVersionUID = 3482118508536148313L;

		public void execute()
        {
          AllZone.GameAction.sacrifice(card);
        }
      }));
    }//*************** END ************ END **************************
    
    
    //*************** START *********** START **************************
    if(cardName.equals("Bottle Gnomes"))
    {
      final Ability ability = new Ability(card, "0")
      {
        public boolean canPlayAI() 
        { 
        	return AllZone.Computer_Life.getLife() < 3;
        	
        }
        
        public boolean canPlay()
        {
        	  SpellAbility sa;
	    	  for (int i=0; i<AllZone.Stack.size(); i++)
	    	  {
	    	       sa = AllZone.Stack.peek(i);
	    	       if (sa.getSourceCard().equals(card))
	    	             return false;
	    	  }
	    	  if (AllZone.GameAction.isCardInPlay(card) && super.canPlay())
	    		  return true;
	    	  else
	    		  return false;
        }
		
        public void resolve()
        {
        	PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
            life.addLife(3);
            
            AllZone.GameAction.sacrifice(card);
        }//resolve()
      };//SpellAbility

      card.addSpellAbility(ability);
      ability.setDescription("Sacrifice Bottle Gnomes: Gain 3 life.");
      ability.setStackDescription(card.getName() + " - " +card.getController() + " gains 3 life.");

    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Mogg Fanatic"))
    {
      final Ability ability = new Ability(card, "0")
      {
        public boolean canPlayAI() {return getCreature().size() != 0;}

        public void chooseTargetAI()
        {
          if(AllZone.Human_Life.getLife() < 3)
            setTargetPlayer(Constant.Player.Human);
          else
          {
            CardList list = getCreature();
            list.shuffle();
            setTargetCard(list.get(0));
          }
          AllZone.GameAction.sacrifice(card);
        }//chooseTargetAI()
        CardList getCreature()
        {
          //toughness of 1
          CardList list = CardFactoryUtil.AI_getHumanCreature(1, card, true);
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              //only get 1/1 flyers or 2/1 creatures
              return (2 <= c.getNetAttack()) || c.getKeyword().contains("Flying");
            }
          });
          return list;
        }//getCreature()

        public void resolve()
        {
          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
              getTargetCard().addDamage(1);
          }
          else
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(1);
        }//resolve()
      };//SpellAbility

      card.addSpellAbility(ability);
      ability.setDescription("Sacrifice Mogg Fanatic: Mogg Fanatic deals 1 damage to target creature or player.");
      ability.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(ability, new Command()
      {
        private static final long serialVersionUID = 8283052965865884779L;

		public void execute()
        {
          AllZone.GameAction.sacrifice(card);
        }
      }, true));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Goblin Skycutter"))
    {
      final Ability ability = new Ability(card, "0")
      {
        public boolean canPlayAI() {return getFlying().size() != 0;}

        public void chooseTargetAI()
        {
          AllZone.GameAction.sacrifice(card);

          CardList flying = getFlying();
          flying.shuffle();
          setTargetCard(flying.get(0));
        }

        CardList getFlying()
        {
          CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          flying = flying.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.getNetDefense() == 2;
            }
          });
          return flying;
        }//getFlying()

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            getTargetCard().addDamage(2);
            getTargetCard().removeIntrinsicKeyword("Flying");
            getTargetCard().removeExtrinsicKeyword("Flying");
          }

          @SuppressWarnings("unused") // target
		  final Card[] target = {getTargetCard()};
          AllZone.EndOfTurn.addUntil(new Command()
          {
            private static final long serialVersionUID = -8889549737746466810L;

			public void execute()
            {
              if(AllZone.GameAction.isCardInPlay(getTargetCard()))
                getTargetCard().addIntrinsicKeyword("Flying");
            }
          });
        }//resolve()
      };//SpellAbility

      Input runtime = new Input()
      {
        private static final long serialVersionUID = 8609211991425118222L;

		public void showMessage()
        {
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isCreature() && c.getKeyword().contains("Flying") && CardFactoryUtil.canTarget(card, c);
            }
          });

          stopSetNext(CardFactoryUtil.input_targetSpecific(ability, list, "Select a creature with flying to deal 2 damage to", new Command()
          {
            private static final long serialVersionUID = -3287971244881855563L;

			public void execute()
            {
              AllZone.GameAction.sacrifice(card);
            }
          }, true));
        }//showMessage()
      };//Input

      card.addSpellAbility(ability);
      ability.setDescription("Sacrifice Goblin Skycutter: Goblin Skycutter deals 2 damage to target creature with flying. That creature loses flying until end of turn.");
      ability.setBeforePayMana(runtime);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Sakura-Tribe Elder"))
    {
      //tap sacrifice
      final SpellAbility ability = new Ability_Activated(card, "0")
      {
 		private static final long serialVersionUID = 1135117614484689768L;
		public boolean canPlayAI()
        {
          //sacrifice Sakura-Tribe Elder if Human has any creatures
          CardList list = new CardList(AllZone.Human_Play.getCards());
          list = list.getType("Creature");
          return list.size() != 0;
        }
        public void chooseTargetAI()
        {
          AllZone.GameAction.sacrifice(card);
        }
        public boolean canPlay()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          CardList list = new CardList(library.getCards());
          list = list.getType("Basic");
          return list.size() > 0 && super.canPlay();
        }//canPlay()
        public void resolve()
        {
          if(owner.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void computerResolve()
        {
          CardList play = new CardList(AllZone.Computer_Play.getCards());
          play = play.getType("Basic");

          CardList library = new CardList(AllZone.Computer_Library.getCards());
          library = library.getType("Basic");

          //this shouldn't happen, but it is defensive programming, haha
          if(library.isEmpty())
            return;

          Card land = null;

          //try to find a basic land that isn't in play
          for(int i = 0; i < library.size(); i++)
            if(! play.containsName(library.get(i)))
            {
              land = library.get(i);
              break;
            }

          //if not found
          //library will have at least 1 basic land because canPlay() checks that
          if(land == null)
            land = library.get(0);

          land.tap();
          AllZone.Computer_Library.remove(land);
          AllZone.Computer_Play.add(land);

          AllZone.GameAction.shuffle(Constant.Player.Computer);
        }//computerResolve()
        public void humanResolve()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          PlayerZone play    = AllZone.getZone(Constant.Zone.Play   , card.getController());

          CardList basicLand = new CardList(library.getCards());
          basicLand = basicLand.getType("Basic");
          if(basicLand.isEmpty())
            return;

          Object o = AllZone.Display.getChoiceOptional("Choose a basic land", basicLand.toArray());
          if(o != null)
          {
            Card land = (Card)o;
            land.tap();

            library.remove(land);
            play.add(land);
          }

          AllZone.GameAction.shuffle(card.getController());
        }//resolve()
      };//SpellAbility

      Input runtime = new Input()
      {
        private static final long serialVersionUID = 1959709104655340395L;
		boolean once = true;
        public void showMessage()
        {
          //this is necessary in order not to have a StackOverflowException
          //because this updates a card, it creates a circular loop of observers
          if(once)
          {
            once = false;
            AllZone.GameAction.sacrifice(card);
            AllZone.Stack.add(ability);

            stop();
          }
        }//showMessage()
      };
      card.addSpellAbility(ability);
      ability.setBeforePayMana(runtime);
      ability.setDescription("Sacrifice Sakura-Tribe Elder: Search your library for a basic land card, put that card into play tapped, then shuffle your library.");
      ability.setStackDescription("Search your library for a basic land card, put that card into play tapped, then shuffle your library.");
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Transluminant"))
    {
      final Command atEOT = new Command()
      {
        private static final long serialVersionUID = -5126793112740563180L;

		public void execute()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());
          
          c.setName("Spirit");
          c.setImageName("W 1 1 Spirit");
          c.setManaCost("W");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Spirit");
          c.setBaseAttack(1);
          c.setBaseDefense(1);
          c.addIntrinsicKeyword("Flying");

          PlayerZone play    = AllZone.getZone(Constant.Zone.Play   , card.getController());
          play.add(c);
        }//execute()
      };//Command

      final Ability ability = new Ability(card, "W")
      {
        public boolean canPlayAI()
        { /*
          CardList list = new CardList(AllZone.Human_Play.getCards());
          list = list.getType("Creature");

          String phase = AllZone.Phase.getPhase();
          return phase.equals(Constant.Phase.Main2) && list.size() != 0;
          */
          return false;
        }
        public void chooseTargetAI()
        {
          AllZone.GameAction.sacrifice(card);
        }

        public void resolve()
        {
          AllZone.EndOfTurn.addAt(atEOT);
        }//resolve()
      };//SpellAbility

      card.addSpellAbility(ability);
      ability.setDescription("W, Sacrifice Transluminant: Put a 1/1 white Spirit creature token with flying into play at end of turn.");
      ability.setStackDescription("Put a 1/1 white Spirit creature token with flying into play at end of turn.");
      ability.setBeforePayMana(new Input_PayManaCost_Ability(ability.getManaCost(), new Command()
      {
        private static final long serialVersionUID = -6553009833190713980L;

		public void execute()
        {
          AllZone.GameAction.sacrifice(card);
          AllZone.Stack.add(ability);
        }
      }));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Llanowar Behemoth"))
    {
      final Ability ability = new Ability(card, "0")
      {
        public boolean canPlayAI()
        {
          return (getUntapped().size() != 0) && CardFactoryUtil.AI_doesCreatureAttack(card);
        }
        public void chooseTargetAI()
        {
          Card c = getUntapped().get(0);
          c.tap();
          setTargetCard(c);
        }
        CardList getUntapped()
        {
          CardList list = new CardList(AllZone.Computer_Play.getCards());
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isCreature() && c.isUntapped() && (!CardFactoryUtil.AI_doesCreatureAttack(c));
            }
          });
          return list;
        }//getUntapped()

        public void resolve()
        {
          card.addTempAttackBoost(1);
          card.addTempDefenseBoost(1);

          Command untilEOT = new Command()
          {
            private static final long serialVersionUID = 6445782721494547172L;

			public void execute()
            {
              card.addTempAttackBoost(-1);
              card.addTempDefenseBoost(-1);
            }//execute()
          };//Command

          AllZone.EndOfTurn.addUntil(untilEOT);
        }//resolve()
      };//SpellAbility

      Input target = new Input()
      {
        private static final long serialVersionUID = 7721637420366357272L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select an untapped creature you control");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          if(c.isCreature() && zone.is(Constant.Zone.Play, card.getController()) && c.isUntapped())
          {
            ability.setStackDescription(card +" gets +1/+1 until end of turn.");
            c.tap();
            AllZone.Stack.add(ability);
            stop();
          }
        }
      };//Input
      ability.setBeforePayMana(target);
      ability.setDescription("Tap an untapped creature you control: Llanowar Behemoth gets +1/+1 until end of turn.");

      card.addSpellAbility(ability);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Memnarch"))
    {
      //has 2 non-tap abilities that effects itself
      final SpellAbility ability1 = new Ability(card, "1 U U")
      {
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            getTargetCard().addType("Artifact");
          }
        }//resolve()
        public boolean canPlayAI()
        {
          CardList list = getCreature();
          return list.size() != 0;
        }
        public void chooseTargetAI()
        {
          Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
          setTargetCard(target);
        }//chooseTargetAI()
        CardList getCreature()
        {
          CardList list = new CardList(AllZone.Human_Play.getCards());
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isCreature() && (!c.isArtifact());
            }
          });
          return list;
        }//getCreature()
      };//SpellAbility

      //**** start of ability2
      final SpellAbility ability2 = new Ability(card, "3 U")
      {
        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            //gain control of target artifact
            PlayerZone from = AllZone.getZone(Constant.Zone.Play, getTargetCard().getController());
            from.remove(getTargetCard());


            getTargetCard().setController(card.getController());

            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);

            PlayerZone to = AllZone.getZone(Constant.Zone.Play, card.getController());
            to.add(getTargetCard());
            to.setUpdate(true);

            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);


//            AllZone.GameAction.moveTo(play, getTargetCard());

            //TODO: controller probably is not set correctly
            //TODO: when you take control, the creature looses type "Artifact" since
            //      GameAction.moveTo() makes a new card object
          }
        }//resolve()
        public boolean canPlayAI()
        {
          CardList list = getArtifactCreatures();
          return list.size() != 0;
        }
        public void chooseTargetAI()
        {
          CardList list = getArtifactCreatures();
          Card target = CardFactoryUtil.AI_getBestCreature(list);
          if(target == null)
            target = AllZone.Human_Play.get(0);

          setTargetCard(target);
        }
        CardList getArtifactCreatures()
        {
          CardList list = new CardList(AllZone.Human_Play.getCards());
          list = list.getType("Artifact");
          list = list.getType("Creature");
          return list;
        }
      };//SpellAbility
      card.addSpellAbility(ability1);
      card.addSpellAbility(ability2);

      ability1.setDescription("1UU: Target permanent becomes an artifact in addition to its other types.(This effect doesn't end at end of turn.)");
      ability2.setDescription("3U: Gain control of target artifact.(This effect doesn't end at end of turn.)");

      ability1.setBeforePayMana(CardFactoryUtil.input_targetType(ability1, "All"));
      ability2.setBeforePayMana(CardFactoryUtil.input_targetType(ability2, "Artifact"));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Meloku the Clouded Mirror"))
    {
      final SpellAbility ability = new Ability(card, "1")
      {
        public void resolve()
        {
          Card c = new Card();
          c.setToken(true);
          c.setImageName("U 1 1 Illusion");
          c.setName("Illusion");

          c.setManaCost("U");
          c.setBaseAttack(1);
          c.setBaseDefense(1);
          c.addIntrinsicKeyword("Flying");
          c.addType("Creature");
          c.addType("Illusion");
          c.setOwner(card.getController());
          c.setController(card.getController());

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);

          //TODO: the "bounced" land should be chosen by the user
          //instead of "automatically" done for him
          CardList island = new CardList(play.getCards());
          island = island.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.getType().contains("Land") && c.isTapped();
            }
          });
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());

          if(! island.isEmpty())
            AllZone.GameAction.moveTo(hand, island.get(0));
        }//resolve()

      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("1, Return a land you control to its owner's hand: Put a 1/1 blue Illusion creature token with flying into play.");
      ability.setStackDescription("Put 1/1 token with flying into play");
      ability.setBeforePayMana(new Input_PayManaCost(ability));
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Squall Drifter"))
    {
      final SpellAbility ability = new Ability_Tap(card, "W")
      {
		private static final long serialVersionUID = 3862705592994953819L;
		public void resolve()
        {
          Card c = getTargetCard();
          c.tap();
        }
        public boolean canPlayAI() {return false;}
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("W, tap: Tap target creature.");

      ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("That Which Was Taken"))
    {
      final SpellAbility ability = new Ability_Tap(card, "4")
      {
		private static final long serialVersionUID = -8996435083734446340L;
		public void resolve()
        {
          Card c = getTargetCard();

          if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
            c.addExtrinsicKeyword("Indestructible");
        }
        public boolean canPlayAI()
        {
          CardList creatures = getCreatures();

          for (int i = 0; i < creatures.size(); i++)
          {
            if (!creatures.get(i).getKeyword().contains("Indestructible"))
            {
            return true;
          }
          }

          return false;
        }
        public void chooseTargetAI()
        {
          //Card c = CardFactoryUtil.AI_getBestCreature(getCreatures());
          CardList a = getCreatures();
          CardListUtil.sortAttack(a);
          CardListUtil.sortFlying(a);

          Card c = null;

          for (int i = 0; i < a.size(); i++)
          {
            if (!a.get(i).getKeyword().contains("Indestructible"))
            {
            c = a.get(i);
            break;
          }
          }

          setTargetCard(c);
        }
        CardList getCreatures()
        {
          CardList list = new CardList();
          list.addAll(AllZone.Computer_Play.getCards());
          return list.getType("Creature");
        }
      };//SpellAbility

      Input target = new Input()
      {
		private static final long serialVersionUID = 137806881250205274L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target permanent");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          if(zone.is(Constant.Zone.Play) && c != card)//cannot target self
          {
            ability.setTargetCard(c);
            stopSetNext(new Input_PayManaCost(ability));
          }
        }
      };//Input -- target

      ability.setBeforePayMana(target);
      ability.setDescription("4, tap: Tap a divinity counter on target permanent other than That Which Was Taken.");

      card.addSpellAbility(ability);
    }//*************** END ************ END **************************






    //*************** START *********** START **************************
    if(cardName.equals("Stern Judge"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
		private static final long serialVersionUID = 3059547795996737707L;
		public void resolve()
        {
          AllZone.Human_Life.subtractLife(countSwamps("Human"));
          AllZone.Computer_Life.subtractLife(countSwamps("Computer"));
        }
        int countSwamps(String player)
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
          CardList swamps = new CardList(play.getCards());
          swamps = swamps.getType("Swamp");
          return swamps.size();
        }
        public boolean canPlayAI()
        {
          int computer = countSwamps(Constant.Player.Computer);
          int human    = countSwamps(Constant.Player.Human);

          if((computer >= AllZone.Computer_Life.getLife()) || (human == 0))
            return false;

          return computer <= human;
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Each player loses 1 life for each Swamp he or she controls.");
      ability.setStackDescription("Stern Judge - Each player loses 1 life for each Swamp he or she controls");
      ability.setBeforePayMana(new Input_NoCost_TapAbility(ability));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Cackling Imp") || cardName.equals("Blightspeaker"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
		private static final long serialVersionUID = -8034678094689484203L;
		public void resolve()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          AllZone.GameAction.getPlayerLife(opponent).subtractLife(1);
        }
        public boolean canPlayAI()
        {
          //computer should play ability if this creature doesn't attack
          Combat c = ComputerUtil.getAttackers();
          CardList list = new CardList(c.getAttackers());

          //could this creature attack?, if attacks, do not use ability
          return (! list.contains(card));
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Target player loses 1 life.");
      ability.setStackDescription(card.getName() + " - Opponent loses 1 life.");
      ability.setBeforePayMana(new Input_NoCost_TapAbility(ability));
    }//*************** END ************ END **************************

    //*************** START *********** START **************************
    if(cardName.equals("Sea Gate Loremaster"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
		
		private static final long serialVersionUID = -1701216509507402535L;
		public boolean canPlayAI() {return false;}
        public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList list = new CardList(play.getCards());
          list = list.filter(new CardListFilter()
          {

			public boolean addCard(Card c) {
				return c.getType().contains("Ally") || c.getKeyword().contains("Changeling");
			}
        	  
          });
          
          for (int i=0;i<list.size();i++)
          {
              AllZone.GameAction.drawCard(card.getController());
          }
          
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Draw a card for each Ally you control.");
      ability.setStackDescription(cardName + " - draw a card for each Ally you control.");
      ability.setBeforePayMana(new Input_NoCost_TapAbility(ability));
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Thought Courier"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
		private static final long serialVersionUID = -7702857487992969125L;
		public boolean canPlayAI() {return false;}
        public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());
          AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Draw a card, then discard a card.");
      ability.setStackDescription("Thought Courier - draw a card, then discard a card.");
      ability.setBeforePayMana(new Input_NoCost_TapAbility(ability));
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Tortuga"))
    {
      final Input discardThenDraw = new Input()
      {
		private static final long serialVersionUID = -7119292573232058526L;
		int nCards = 1;
        int n = 0;

        public void showMessage()
        {
          AllZone.Display.showMessage("Select a card to discard");
          ButtonUtil.disableAll();

          //in case no more cards in hand
          if(n == nCards || AllZone.Human_Hand.getCards().length == 0)
          {
            stop();
            AllZone.GameAction.drawCard(card.getController());
            n = 0; //very important, otherwise the 2nd time you play this ability, you
                   //don't have to discard
          }
        }
        public void selectCard(Card card, PlayerZone zone)
        {
          if(zone.is(Constant.Zone.Hand))
          {
            AllZone.GameAction.discard(card);
            n++;
            showMessage();
          }
        }
      };//SpellAbility





      final Ability_Tap ability = new Ability_Tap(card)
      {

		private static final long serialVersionUID = -2946606436670861559L;
		public boolean canPlayAI() {return false;}
        public void resolve()
        {
          AllZone.InputControl.setInput(discardThenDraw);
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Discard a card, then draw a card.");
      ability.setStackDescription("Tortuga - Discard a card, then draw a card.");
      ability.setBeforePayMana(new Input_NoCost_TapAbility(ability));


      final Ability_Tap ability2 = new Ability_Tap(card)
      {
		private static final long serialVersionUID = 8961266883009597786L;
		public boolean canPlay()
        {
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          return hand.getCards().length == 7;
        }
        public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());
        }
      };//SpellAbility
      card.addSpellAbility(ability2);
      ability2.setDescription("tap: Draw a card. Play this ability only if you have exactly 7 cards in your hand.");
      ability2.setStackDescription("Tortuga - draw a card.");
      ability2.setBeforePayMana(new Input_NoCost_TapAbility(ability2));

    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Library of Alexandria"))
    {
      final Ability_Tap ability2 = new Ability_Tap(card)
      {
		private static final long serialVersionUID = -3405763871882165537L;
		public boolean canPlay()
        {
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          return hand.getCards().length == 7 && super.canPlay();
        }
        public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());
        }
      };//SpellAbility
      card.addSpellAbility(ability2);
      ability2.setDescription("tap: Draw a card. Play this ability only if you have exactly 7 cards in your hand.");
      ability2.setStackDescription("Library of Alexandria - draw a card.");
      ability2.setBeforePayMana(new Input_NoCost_TapAbility(ability2));

    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Magus of the Library"))
    {
      final Ability_Tap ability2 = new Ability_Tap(card)
      {
		private static final long serialVersionUID = 6567685794684744457L;
		public boolean canPlay()
        {
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          return hand.getCards().length == 7 && super.canPlay();
        }
        public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());
        }
      };//SpellAbility
      card.addSpellAbility(ability2);
      ability2.setDescription("tap: Draw a card. Play this ability only if you have exactly 7 cards in hand.");
      ability2.setStackDescription("Magus of the Library - draw a card.");
      ability2.setBeforePayMana(new Input_NoCost_TapAbility(ability2));

    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Bonded Fetch"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
		private static final long serialVersionUID = 3959966663907905001L;
		public boolean canPlayAI() {return false;}
        public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());
          AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Draw a card, then discard a card.");
      ability.setStackDescription("Bonded Fetch - draw a card, then discard a card.");
      ability.setBeforePayMana(new Input_NoCost_TapAbility(ability));
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Hammerfist Giant"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
		private static final long serialVersionUID = 1089840397064226840L;
		
		public boolean canPlayAI()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(4, card, true);
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c) {return ! c.getKeyword().contains("Flying");}
          });

          return list.size() > 3 && 6 < AllZone.Computer_Life.getLife();
        }//canPlayAI()
        public void resolve()
        {
          //get all creatures
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.getType("Creature");

          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return ! c.getKeyword().contains("Flying") && CardFactoryUtil.canDamage(card, c);
            }
          });
          for(int i = 0; i < list.size(); i++)
            list.get(i).addDamage(4);

          AllZone.Human_Life.subtractLife(4);
          AllZone.Computer_Life.subtractLife(4);
        }//resolve()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Hammerfist Giant deals 4 damage to each creature without flying and each player.");
      ability.setStackDescription("Hammerfist Giant - deals 4 damage to each creature without flying and each player.");
      ability.setBeforePayMana(new Input_NoCost_TapAbility(ability));
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Urborg Syphon-Mage"))
    {
      final Ability_Tap ability = new Ability_Tap(card, "2 B")
      {
		private static final long serialVersionUID = -1965170715774280112L;
		
		public void resolve()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          AllZone.GameAction.getPlayerLife(opponent).subtractLife(2);

          AllZone.GameAction.getPlayerLife(card.getController()).addLife(2);

          //computer discards here, todo: should discard when ability put on stack
          if(card.getController().equals(Constant.Player.Computer))
            AllZone.GameAction.discardRandom(Constant.Player.Computer);
        }
        public boolean canPlay()
        {
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          return super.canPlay() && hand.getCards().length != 0;
        }
        public boolean canPlayAI()
        {
          int life = AllZone.Human_Life.getLife();
          Card[] hand = AllZone.Computer_Hand.getCards();
          return ((life < 11) || (5 < AllZone.Phase.getTurn())) &&
                 hand.length > 0;
        }
      };//SpellAbility

      card.addSpellAbility(ability);
      ability.setDescription("2B, tap, Discard a card: Each other player loses 2 life. You gain life equal to the life lost this way.");
      ability.setStackDescription("Urborg Syphon-Mage - Opponent loses 2 life, and you gain 2 life");
      ability.setBeforePayMana(new Input_PayManaCost_Ability("2 B", new Command()
      {
		private static final long serialVersionUID = 1186455545951390853L;

		public void execute()
        {
          card.tap();
          AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
          AllZone.Stack.add(ability);
        }
      }));
    }//*************** END ************ END **************************

  //*************** START *********** START **************************
    if(cardName.equals("Spectral Procession"))
    {
    	final SpellAbility spell = new Spell(card)
    	{
			private static final long serialVersionUID = 6118842682065463016L;
			public void resolve()
	    	{
	    		makeToken();
	    		makeToken();
	    		makeToken();
	    	}
	    	void makeToken()
	    	{
	    		PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
	            Card c = new Card();

	            c.setOwner(card.getController());
	            c.setController(card.getController());

	            c.setManaCost("W");
	            c.setToken(true);

	            c.addType("Creature");
	            c.addType("Spirit");
	            c.setBaseAttack(1);
	            c.setBaseDefense(1);
	            c.addIntrinsicKeyword("Flying");

	            c.setName("Spirit");
	            c.setImageName("W 1 1 Spirit");
	            
	            play.add(c);
	    	}
	    };
	    
	    card.clearSpellAbility();
	    card.addSpellAbility(spell);
  	}//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if (cardName.equals("Stangg")){
    	
    	final Ability ability = new Ability(card, "0")
		{
			public void resolve()
			{
				Card c = new Card();

				c.setName("Stangg Twin");
				
				c.setOwner(card.getController());
				c.setController(card.getController());

				c.setManaCost("R G");
				c.setToken(true);

				c.addType("Legendary");
				c.addType("Creature");
				c.addType("Human");
				c.addType("Warrior");
				c.setBaseAttack(3);
				c.setBaseDefense(4);
				
				c.addLeavesPlayCommand(new Command()
				{
					private static final long serialVersionUID = 3367390368512271319L;

					public void execute() {
						if (AllZone.GameAction.isCardInPlay(card))
							AllZone.GameAction.sacrifice(card);
					}
					
				});

				PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
				play.add(c);
				
			}
		};
		ability.setStackDescription("When Stangg enters the battlefield, if Stangg is on the battlefield, put a legendary 3/4 red and green Human Warrior creature token named Stangg Twin onto the battlefield.");
		
		card.addComesIntoPlayCommand(new Command()
		{
			private static final long serialVersionUID = 6667896040611028600L;

			public void execute() {
				AllZone.Stack.add(ability);
			}			
		});
		
		card.addLeavesPlayCommand(new Command()
		{
			private static final long serialVersionUID = 1786900359843939456L;

			public void execute() {
				CardList list = new CardList();
				list.addAll(AllZone.Computer_Play.getCards());
				list.addAll(AllZone.Human_Play.getCards());
				list = list.getName("Stangg Twin");
				
				if (list.size() == 1)
					AllZone.GameAction.removeFromGame(list.get(0));
			}	
		});
    	
    }//*************** END ************ END **************************

    //*************** START *********** START **************************
    if(cardName.equals("Llanowar Mentor"))
    {
      final Ability_Tap ability = new Ability_Tap(card, "G")
      {
		private static final long serialVersionUID = 752280918226277729L;

		public void resolve()
        {
          makeToken();

          //computer discards here, todo: should discard when ability put on stack
          if(card.getController().equals(Constant.Player.Computer))
            AllZone.GameAction.discardRandom(Constant.Player.Computer);
        }
        void makeToken()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Elf");
          c.addType("Druid");
          c.setBaseAttack(1);
          c.setBaseDefense(1);


          //custom settings
          c.setName("Llanowar Elves");
          c.setImageName("G 1 1 Llanowar Elves");
          //c.addIntrinsicKeyword("tap: add G");
          c.addSpellAbility(new Ability_Mana(card, "tap: add G")
		  {
			private static final long serialVersionUID = 7871036527184588884L;  
		  });


          play.add(c);
        }//makeToken()

        public boolean canPlay()
        {
          Card c[] = AllZone.getZone(Constant.Zone.Hand, card.getController()).getCards();

          return super.canPlay() && (0 < c.length);
        }

        public boolean canPlayAI()
        {
          boolean canDiscard =  0 < AllZone.Computer_Hand.getCards().length;
          return canPlay() && canDiscard && AllZone.Phase.getPhase().equals(Constant.Phase.Main2);
        }
      };//SpellAbility

      card.addSpellAbility(ability);
      ability.setDescription("G, tap, Discard a card: Put a 1/1 green Elf Druid creature token named Llanowar Elves into play with \"tap: add G\" ");
      ability.setStackDescription("Llanowar Mentor - Put a 1/1 token into play");
      ability.setBeforePayMana(new Input_PayManaCost_Ability("G", new Command()
      {
		private static final long serialVersionUID = -8140640118045101485L;

		public void execute()
        {
          card.tap();
          AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
          AllZone.Stack.add(ability);
        }
      }));
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Sparkspitter"))
    {
      final Ability_Tap ability = new Ability_Tap(card, "R")
      {
		private static final long serialVersionUID = -6381252527344512333L;

		public void resolve()
        {
          makeToken();

          //computer discards here, todo: should discard when ability put on stack
          if(card.getController().equals(Constant.Player.Computer))
            AllZone.GameAction.discardRandom(Constant.Player.Computer);
        }
        void makeToken()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = CardFactory.this.getCard("Spark Elemental", card.getController());
          c.setToken(true);
          c.setImageName("R 3 1 Spark Elemental");
          play.add(c);
        }//makeToken()

        public boolean canPlay()
        {
          Card c[] = AllZone.getZone(Constant.Zone.Hand, card.getController()).getCards();

          return super.canPlay() && (0 < c.length);
        }

        public boolean canPlayAI()
        {
          boolean canDiscard =  0 < AllZone.Computer_Hand.getCards().length;
          return canPlay() && canDiscard;
        }
      };//SpellAbility

      card.addSpellAbility(ability);
      ability.setDescription("R, tap, Discard a card: Put a 3/1 red Elemental creature token named Spark Elemental into play with trample, haste, and \"At end of turn, sacrifice Spark Elemental.\" ");
      ability.setStackDescription("Sparkspitter - Put a 3/1 token into play");
      ability.setBeforePayMana(new Input_PayManaCost_Ability("R", new Command()
      {
		private static final long serialVersionUID = 4717424466422508064L;

		public void execute()
        {
          card.tap();
          AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
          AllZone.Stack.add(ability);
        }
      }));
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Sliversmith"))
    {
      final Ability_Tap ability = new Ability_Tap(card, "1")
      {
		private static final long serialVersionUID = -901356795848120643L;

		public void resolve()
        {
          makeToken();

          //computer discards here, todo: should discard when ability put on stack
          if(card.getController().equals(Constant.Player.Computer))
            AllZone.GameAction.discardRandom(Constant.Player.Computer);
        }
        void makeToken()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setManaCost("1");
          c.setToken(true);
          
          c.addType("Artifact");
          c.addType("Creature");
          c.addType("Sliver");
          c.setBaseAttack(1);
          c.setBaseDefense(1);


          //custom settings
          c.setName("Metallic Sliver");
          c.setImageName("C 1 1 Metallic Sliver");

          play.add(c);
        }//makeToken()

        public boolean canPlay()
        {
          Card c[] = AllZone.getZone(Constant.Zone.Hand, card.getController()).getCards();

          return super.canPlay() && (0 < c.length);
        }

        public boolean canPlayAI()
        {
          boolean canDiscard =  0 < AllZone.Computer_Hand.getCards().length;
          return canPlay() && canDiscard && AllZone.Phase.getPhase().equals(Constant.Phase.Main2);
        }
      };//SpellAbility

      card.addSpellAbility(ability);
      ability.setDescription("1, tap, Discard a card: Put a 1/1 Sliver artifact creature token named Metallic Sliver into play.");
      ability.setStackDescription(card +" - Put a 1/1 token into play");
      ability.setBeforePayMana(new Input_PayManaCost_Ability("1", new Command()
      {
		private static final long serialVersionUID = 7980998398222481323L;

		public void execute()
        {
          card.tap();
          AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
          AllZone.Stack.add(ability);
        }
      }));
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Cloudseeder"))
    {
      final Ability_Tap ability = new Ability_Tap(card, "U")
      {
		private static final long serialVersionUID = -4685908556244137496L;

		public void resolve()
        {
          makeToken();

          //computer discards here, todo: should discard when ability put on stack
          if(card.getController().equals(Constant.Player.Computer))
            AllZone.GameAction.discardRandom(Constant.Player.Computer);
        }
        void makeToken()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setManaCost("U");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Faerie");
          c.setBaseAttack(1);
          c.setBaseDefense(1);


          //custom settings
          c.setName("Cloud Sprite");
          c.setImageName("U 1 1 Cloud Sprite");
          c.addIntrinsicKeyword("Flying");
          c.addIntrinsicKeyword("This creature can block only creatures with flying");

          play.add(c);
        }//makeToken()

        public boolean canPlay()
        {
          Card c[] = AllZone.getZone(Constant.Zone.Hand, card.getController()).getCards();

          return super.canPlay() && (0 < c.length);
        }

        public boolean canPlayAI()
        {
          boolean canDiscard =  0 < AllZone.Computer_Hand.getCards().length;
          return canPlay() && canDiscard && AllZone.Phase.getPhase().equals(Constant.Phase.Main2);
        }
      };//SpellAbility

      card.addSpellAbility(ability);
      ability.setDescription("U, tap, Discard a card: Put a 1/1 blue Sprite creature token named Cloud Sprite into play with flying and \"this creature can block only creatures with flying\".");
      ability.setStackDescription("Cloudseeker - Put a 1/1 token into play");
      ability.setBeforePayMana(new Input_PayManaCost_Ability("U", new Command()
      {
		private static final long serialVersionUID = 7707504858274558816L;

		public void execute()
        {
          card.tap();
          AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
          AllZone.Stack.add(ability);
        }
      }));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Goldmeadow Lookout"))
    {
      final Ability_Tap ability = new Ability_Tap(card, "G")
      {
		private static final long serialVersionUID = -8413409735529340094L;

		public void resolve()
        {
          makeToken();

          //computer discards here, todo: should discard when ability put on stack
          if(card.getController().equals(Constant.Player.Computer))
            AllZone.GameAction.discardRandom(Constant.Player.Computer);
        }
        void makeToken()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setManaCost("W");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Kithkin");
          c.addType("Soldier");
          c.setBaseAttack(1);
          c.setBaseDefense(1);


          //custom settings
          c.setName("Goldmeadow Harrier");
          c.setImageName("W 1 1 Goldmeadow Harrier");
          final SpellAbility ability = new Ability_Tap(c, "W")
          {
			private static final long serialVersionUID = -7327585136675896817L;
			
			public void resolve()
            {
              Card c = getTargetCard();
              c.tap();
            }
            public boolean canPlayAI() {return false;}
          };//SpellAbility
          c.addSpellAbility(new Spell_Permanent(c));
          c.addSpellAbility(ability);
          ability.setDescription("W, tap: Tap target creature.");
          ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));


          play.add(c);
        }//makeToken()

        public boolean canPlay()
        {
          Card c[] = AllZone.getZone(Constant.Zone.Hand, card.getController()).getCards();

          return super.canPlay() && (0 < c.length);
        }

        public boolean canPlayAI()
        {
          boolean canDiscard =  0 < AllZone.Computer_Hand.getCards().length;
          return canPlay() && canDiscard && AllZone.Phase.getPhase().equals(Constant.Phase.Main2);
        }
      };//SpellAbility

      card.addSpellAbility(ability);
      ability.setDescription("W, tap, Discard a card: Put a 1/1 white Kithkin Soldier creature token named Goldmeadow Harrier into play with \"W, tap target creature.\"");
      ability.setStackDescription("Goldmeadow Lookout - Put a 1/1 token into play");
      ability.setBeforePayMana(new Input_PayManaCost_Ability("W", new Command()
      {
		private static final long serialVersionUID = 8621733943286161557L;

		public void execute()
        {
          card.tap();
          AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
          AllZone.Stack.add(ability);
        }
      }));
    }//*************** END ************ END **************************
   
    //*************** START *********** START **************************
    if (cardName.equals("Goldmeadow Harrier") || cardName.equals("Loxodon Mystic") 
    	|| cardName.equals("Master Decoy"))
    {
    	final SpellAbility ability = new Ability_Tap(card, "W")
        {

		   private static final long serialVersionUID = 4424848120984319655L;
		   public void resolve()
           {
             Card c = getTargetCard();
             c.tap();
           }
           public boolean canPlayAI() {return false;}
        };//SpellAbility
        card.addSpellAbility(ability);
        ability.setDescription("W, tap: Tap target creature.");
        ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));

  	}//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Silent Attendant"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
      /**
		 * 
		 */
		private static final long serialVersionUID = -2602340080268657851L;
	public void resolve()
        {
         
          AllZone.GameAction.getPlayerLife(card.getController()).addLife(1);
        }
        public boolean canPlayAI()
        {
          //computer should play ability if this creature doesn't attack
          Combat c = ComputerUtil.getAttackers();
          CardList list = new CardList(c.getAttackers());

          //could this creature attack?, if attacks, do not use ability
          return (! list.contains(card));
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: You gain 1 life.");
      ability.setStackDescription(card.getName() + " -  you gain 1 life.");
      ability.setBeforePayMana(new Input_NoCost_TapAbility(ability));
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Ghost-Lit Redeemer"))
    {
      final SpellAbility ability = new Ability_Tap(card, "W")
      {
		private static final long serialVersionUID = -7119153679100849498L;

		public boolean canPlayAI() {return AllZone.Phase.getPhase().equals(Constant.Phase.Main2);}

        public void resolve()
        {
          Card c = card;
          PlayerLife life = AllZone.GameAction.getPlayerLife(c.getController());
          life.addLife(2);
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("W, tap: You gain 2 life");
      ability.setStackDescription("Computer gains 2 life");

      final Command paid  = new Command()
      {
		private static final long serialVersionUID = 3649597692883194760L;

		public void execute()
        {
          Card c = card;
          c.tap();
          AllZone.Human_Play.updateObservers();//so the card will tap at the correct time

          ability.setStackDescription(c.getController()+" gains 2 life");
          AllZone.Stack.add(ability);
          AllZone.InputControl.resetInput();
        }
      };
      ability.setBeforePayMana(new Input_PayManaCost_Ability(ability.getManaCost(), paid, Command.Blank));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Tremor"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 3451888160398198322L;

		public boolean canPlayAI()
		{
			CardList human = new CardList(AllZone.Human_Play.getCards());
			CardList computer = new CardList(AllZone.Computer_Play.getCards());

			human = human.filter(new CardListFilter()
			{

				public boolean addCard(Card c) {
					return !c.getKeyword().contains("Flying") && CardFactoryUtil.canDamage(card, c) && 
						    c.getNetDefense() == 1;
				}
			});
			computer = computer.filter(new CardListFilter()
			{
				public boolean addCard(Card c) {
					return !c.getKeyword().contains("Flying") && CardFactoryUtil.canDamage(card, c) &&
							c.getNetDefense() == 1;
				}
			});

			// the computer will at least destroy 2 more human creatures
			return computer.size() < human.size() - 1;
		}
		public void resolve()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());
          all = all.getType("Creature");

          for(int i = 0; i < all.size(); i++)
            if(! all.get(i).getKeyword().contains("Flying") && CardFactoryUtil.canDamage(card,all.get(i)))
              all.get(i).addDamage(1);
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Reviving Dose"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -3239301336328919121L;

		public void resolve()
        {
          PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
          life.addLife(3);

          AllZone.GameAction.drawCard(card.getController());
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Swords to Plowshares"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 4752934806606319269L;
		
		public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            //add life
            String player = getTargetCard().getController();
            PlayerLife life = AllZone.GameAction.getPlayerLife(player);
            life.addLife(getTargetCard().getNetAttack());

            //remove card from play
            AllZone.GameAction.removeFromGame(getTargetCard());
          }
        }//resolve()
        public boolean canPlayAI()
        {
          CardList creature = new CardList(AllZone.Human_Play.getCards());
          creature = creature.getType("Creature");
          creature = creature.filter(new CardListFilter()
          {
			public boolean addCard(Card c) {
				return CardFactoryUtil.canTarget(card,c);
			}   
          });
          return creature.size() != 0 && (AllZone.Phase.getTurn() > 4);
        }
        public void chooseTargetAI()
        {
          CardList play = new CardList(AllZone.Human_Play.getCards());
          Card target = CardFactoryUtil.AI_getBestCreature(play, card);
          setTargetCard(target);
        }
      };
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));

      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Unmake"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -9194035528349589512L;
		public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
        	//remove card from play
            AllZone.GameAction.removeFromGame(getTargetCard());
          }
        }//resolve()
        public boolean canPlayAI()
        {
          CardList creature = new CardList(AllZone.Human_Play.getCards());
          creature = creature.getType("Creature");
          creature = creature.filter(new CardListFilter()
          {
			public boolean addCard(Card c) {
				return CardFactoryUtil.canTarget(card,c);
			}   
          });
          return creature.size() != 0 && (AllZone.Phase.getTurn() > 4);
        }
        public void chooseTargetAI()
        {
          CardList play = new CardList(AllZone.Human_Play.getCards());
          Card target = CardFactoryUtil.AI_getBestCreature(play);
          setTargetCard(target);
        }
      };
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));

      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



  //*************** START *********** START **************************
    if(cardName.equals("Crib Swap"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -4567382566960071562L;
		
		public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            String player = getTargetCard().getController();
            makeToken(player);

            //remove card from play
            AllZone.GameAction.removeFromGame(getTargetCard());
          }
        }//resolve()
        public boolean canPlayAI()
        {
          CardList creature = new CardList(AllZone.Human_Play.getCards());
          creature = creature.getType("Creature");
          return creature.size() != 0 && (AllZone.Phase.getTurn() > 4);
        }
        public void chooseTargetAI()
        {
          CardList play = new CardList(AllZone.Human_Play.getCards());
          Card target = CardFactoryUtil.AI_getBestCreature(play);
          setTargetCard(target);
        }
        void makeToken(String player)
        {
          Card c = new Card();

          c.setName("Shapeshifter");
          c.setName("C 1 1 Shapeshifter");

          c.setOwner(player);
          c.setController(player);

          c.setManaCost("");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Shapeshifter");
          c.addIntrinsicKeyword("Changeling");
          c.setBaseAttack(1);
          c.setBaseDefense(1);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
          play.add(c);
        }//makeToken()

      };
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));

      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




  //*************** START *********** START **************************
    if(cardName.equals("Demonic Tutor") || cardName.equals("Diabolic Tutor") || cardName.equals("Grim Tutor"))
    {
      final SpellAbility spell = new Spell(card)
      {
      private static final long serialVersionUID = 1481169060428051519L;
      
      public void resolve()
        {
          String player = card.getController();
          if(player.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void humanResolve()
        {
          Object check = AllZone.Display.getChoiceOptional("Select card", AllZone.Human_Library.getCards());
          if(check != null)
          {
            PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
            AllZone.GameAction.moveTo(hand, (Card)check);
          }
          AllZone.GameAction.shuffle(Constant.Player.Human);
         
          //lose 3 life
          if(cardName.equals("Grim Tutor"))
          {    
           String player = Constant.Player.Human;
           PlayerLife life = AllZone.GameAction.getPlayerLife(player);
           life.subtractLife(3);
          }
        }
        public void computerResolve()
        {
          Card[] library = AllZone.Computer_Library.getCards();
          CardList list = new CardList(library);

          //pick best creature
          Card c = CardFactoryUtil.AI_getBestCreature(list);
          if(c == null)
            c = library[0];
          //System.out.println("comptuer picked - " +c);
          AllZone.Computer_Library.remove(c);
          AllZone.Computer_Hand.add(c);
         
          //lose 3 life
          if(cardName.equals("Grim Tutor"))
          {   
           String player = Constant.Player.Computer;
           PlayerLife life = AllZone.GameAction.getPlayerLife(player);
           life.subtractLife(3);
          }
        }
        public boolean canPlay()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
         
          return library.getCards().length != 0 && AllZone.Phase.getActivePlayer().equals(card.getController())
          && !AllZone.Phase.getPhase().equals("End of Turn");
        }
        public boolean canPlayAI()
        {
          CardList creature = new CardList();
          creature.addAll(AllZone.Computer_Library.getCards());
          creature = creature.getType("Creature");
          return creature.size() != 0;
        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    if(cardName.equals("Entomb"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 4724906962713222211L;
		public void resolve()
        {
          String player = card.getController();
          if(player.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void humanResolve()
        {
          Object check = AllZone.Display.getChoiceOptional("Select card", AllZone.Human_Library.getCards());
          if(check != null)
          {
            PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
            AllZone.GameAction.moveTo(grave, (Card)check);
          }
          AllZone.GameAction.shuffle(Constant.Player.Human);
        }
        public void computerResolve()
        {
          Card[] library = AllZone.Computer_Library.getCards();
          CardList list = new CardList(library);


          //pick best creature
          Card c = CardFactoryUtil.AI_getBestCreature(list);
          if(c == null)
            c = library[0];
          //System.out.println("comptuer picked - " +c);
          AllZone.Computer_Library.remove(c);
          AllZone.Computer_Graveyard.add(c);
        }
        public boolean canPlay()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          
          return library.getCards().length != 0;
        }
        public boolean canPlayAI()
        {
          CardList creature = new CardList();
          creature.addAll(AllZone.Computer_Library.getCards());
          creature = creature.getType("Creature");
          return creature.size() != 0;
        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Do or Die"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 8241241003478388362L;

		public boolean canPlayAI()
        {
          return 4 <= CardFactoryUtil.AI_getHumanCreature(card, true).size() && 4 < AllZone.Phase.getTurn();
        }

        public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, getTargetPlayer());
          CardList list = new CardList(play.getCards());
          list = list.getType("Creature");

          list.shuffle();

          for(int i = 0; i < list.size() / 2; i++)
            AllZone.GameAction.destroyNoRegeneration(list.get(i));
        }
      };//SpellAbility
      spell.setChooseTargetAI(CardFactoryUtil.AI_targetHuman());
      spell.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell));

      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if (cardName.equals("Hymn to Tourach"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 42470566751344693L;

        public boolean canPlayAI()
        {
          return AllZone.Human_Hand.size() > 0;
        }

        public void resolve()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          AllZone.GameAction.discardRandom(opponent);
          AllZone.GameAction.discardRandom(opponent);
        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Beacon of Destruction"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 6653675303299939465L;
		
		public void resolve()
        {
          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
            {
              getTargetCard().addDamage(5);
              done();
            }
            else
              AllZone.GameAction.moveToGraveyard(card);
          }
          else
          {
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(5);
            done();
          }
        }//resolve()
        void done()
        {
          //shuffle card back into the library
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          library.add(card);
          AllZone.GameAction.shuffle(card.getController());
        }
      };
      spell.setChooseTargetAI(CardFactoryUtil.AI_targetHumanCreatureOrPlayer());

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(spell, true));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Capsize"))
    {
      final SpellAbility spell_one = new Spell(card)
      {
		private static final long serialVersionUID = 7688777028599839669L;

		public boolean canPlayAI() {return false;}

        public void resolve()
        {
          final Card[] target = new Card[1];
          target[0] = getTargetCard();
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, target[0].getController());
          
          if(AllZone.GameAction.isCardInPlay(target[0])  && CardFactoryUtil.canTarget(card, target[0]) )
          {
        	  if (!target[0].isToken())
        		  AllZone.GameAction.moveTo(hand ,target[0]);
        	  else
        		  AllZone.GameAction.removeFromGame(target[0]);
        	  
          }
        }//resolve()
      };//SpellAbility

      final SpellAbility spell_two = new Spell(card)
      {

		private static final long serialVersionUID = -2399079881132655853L;
		public boolean canPlayAI()
        {
			CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
	        return 3 < AllZone.Phase.getTurn() && 0 < human.size();
          
        }
        public void chooseTargetAI()
        {
        	CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
            setTargetCard(CardFactoryUtil.AI_getBestCreature(human));
        }
        

        public void resolve()
        {
          
        	final Card[] target = new Card[1];
            target[0] = getTargetCard();
            PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, target[0].getOwner());
            
            if(AllZone.GameAction.isCardInPlay(target[0]) && CardFactoryUtil.canTarget(card, target[0]) )
            {
              if (!target[0].isToken())
           		  AllZone.GameAction.moveTo(hand ,target[0]);
           	  else
           		  AllZone.GameAction.removeFromGame(target[0]);
            }
            done();
        }//resolve()
        void done()
        {
          //return card to the hand
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          AllZone.GameAction.moveTo(hand, card);
        }
      };//SpellAbility
      spell_two.setManaCost("4 U U");

      spell_one.setDescription("Return target permanent to its owner's hand.");
      spell_two.setDescription("Buyback 3 - Pay 4 U U, put this card into your hand as it resolves.");
      spell_two.setIsBuyBackAbility(true);

      Input runtime1 = new Input()
	  {
	
    	    private static final long serialVersionUID = 6884105724632382299L;

			public void showMessage()
	        {
			  PlayerZone human = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
		      PlayerZone comp = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
		      CardList perms = new CardList();
			  perms.addAll(human.getCards());
			  perms.addAll(comp.getCards());
			  
	          stopSetNext(CardFactoryUtil.input_targetSpecific(spell_one, perms, "Select target permanent.", true));
	        }
	  };  
	  
	  Input runtime2 = new Input()
	  {
		  	private static final long serialVersionUID = 8564956495965504679L;

			public void showMessage()
	        {
			  PlayerZone human = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
	          PlayerZone comp = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
			  CardList perms = new CardList();
			  perms.addAll(human.getCards());
			  perms.addAll(comp.getCards());
	          
	          
	          stopSetNext(CardFactoryUtil.input_targetSpecific(spell_two, perms, "Select target permanent.", true));
	        }
	  };  
      
      spell_one.setBeforePayMana(runtime1);
      spell_two.setBeforePayMana(runtime2);

      card.clearSpellAbility();
      card.addSpellAbility(spell_one);
      card.addSpellAbility(spell_two);
      
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Whispers of the Muse"))
    {
      final SpellAbility spell_one = new Spell(card)
      {

		private static final long serialVersionUID = 8341386638247535343L;

		public boolean canPlayAI() {return false;}

        public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());
        }//resolve()
      };//SpellAbility

      final SpellAbility spell_two = new Spell(card)
      {

 		private static final long serialVersionUID = -131686114078716307L;
		public void resolve()
        {            
        	AllZone.GameAction.drawCard(card.getController());
            done();
        }//resolve()
        void done()
        {
          //return card to the hand
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          AllZone.GameAction.moveTo(hand, card);
        }
      };//SpellAbility
      spell_two.setManaCost("5 U");

      spell_one.setDescription("Draw a card.");
      spell_one.setStackDescription(cardName + " - " +card.getController() + " draws a card.");
      spell_two.setDescription("Buyback 5 - Pay 5 U , put this card into your hand as it resolves.");
      spell_two.setStackDescription(cardName + " - (Buyback) " +card.getController() + " draws a card.");
      spell_two.setIsBuyBackAbility(true);

      card.clearSpellAbility();
      card.addSpellAbility(spell_one);
      card.addSpellAbility(spell_two);
      
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Elvish Fury"))
    {
      final SpellAbility spell_one = new Spell(card)
      {
		private static final long serialVersionUID = 3356401944678089378L;

		public boolean canPlayAI() {return false;}

        public void resolve()
        {
          final Card[] target = new Card[1];
          final Command untilEOT = new Command()
          {
			private static final long serialVersionUID = 7120352016188545025L;

			public void execute()
            {
              if(AllZone.GameAction.isCardInPlay(target[0]))
              {
                target[0].addTempAttackBoost(-2);
                target[0].addTempDefenseBoost(-2);
              }
            }
          };

          target[0] = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(target[0])  && CardFactoryUtil.canTarget(card, target[0]) )
          {
            target[0].addTempAttackBoost(2);
            target[0].addTempDefenseBoost(2);

            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };//SpellAbility

      final SpellAbility spell_two = new Spell(card)
      {
		private static final long serialVersionUID = 3898017438147188882L;
		
		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public void chooseTargetAI()
        {
          setTargetCard(getAttacker());
        }
        public Card getAttacker()
        {
          //target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();

          CardList list = new CardList(c.getAttackers());
          CardListUtil.sortFlying(list);

          Card[] att = list.toArray();
          if(att.length != 0)
            return att[0];
          else
            return null;
        }//getAttacker()


        public void resolve()
        {
          final Card[] target = new Card[1];
          final Command untilEOT = new Command()
          {
			private static final long serialVersionUID = 280295105716586978L;

			public void execute()
            {
              if(AllZone.GameAction.isCardInPlay(target[0]))
              {
                target[0].addTempAttackBoost(-2);
                target[0].addTempDefenseBoost(-2);
              }
            }
          };

          target[0] = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(target[0]) && CardFactoryUtil.canTarget(card, target[0]) )
          {
            target[0].addTempAttackBoost(2);
            target[0].addTempDefenseBoost(2);

            AllZone.EndOfTurn.addUntil(untilEOT);
            done();
          }
        }//resolve()
        void done()
        {
          //return card to the hand
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          AllZone.GameAction.moveTo(hand, card);
        }
      };//SpellAbility
      spell_two.setManaCost("4 G");

      spell_one.setDescription("Target creature gets +2/+2 until end of turn.");
      spell_two.setDescription("Buyback 4 - Pay 4G, put this card into your hand as it resolves.");

      spell_one.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell_one));
      spell_two.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell_two));
      
      spell_two.setIsBuyBackAbility(true);

      card.clearSpellAbility();
      card.addSpellAbility(spell_one);
      card.addSpellAbility(spell_two);
      
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Ramosian Revivalist"))
    {
    	@SuppressWarnings("unused") // costMinusOne
		String costMinusOne = "";
	    int a = Integer.parseInt("6");
	    a--;
	    costMinusOne = Integer.toString(a);
	    final int converted = a;
	    final String player = card.getController();
	    
	    final SpellAbility ability = new Ability_Tap(card, "6")
		  {
			private static final long serialVersionUID = 2675327938055139432L;

			public boolean canPlay()
		      {
		    	  SpellAbility sa;
		    	  for (int i=0; i<AllZone.Stack.size(); i++)
		    	  {
		    	       sa = AllZone.Stack.peek(i);
		    	       if (sa.getSourceCard().equals(card))
		    	             return false;
		    	  }
		    	  
		    	  if (AllZone.GameAction.isCardInPlay(card) && !card.hasSickness() && !card.isTapped())
		    		  return true;
		    	  else
		    		  return false;
		      }
		      public boolean canPlayAI() 
		      {
		    	  PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, player);

		    	  CardList list = new CardList(grave.getCards());
		    	  list = list.getType("Rebel");
		    	  
		    	  if (AllZone.Phase.getPhase().equals(Constant.Phase.Main2) && list.size() >0)
		    		  return true;
		    	  else
		    		  return false;
		    	  
		      }
		      
		      public void resolve()
		      {
		    	  PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, player);
		    	  PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
		    	  
		    	  CardList rebels = new CardList();
		    	  CardList list = new CardList(grave.getCards());
		    	  list = list.getType("Rebel");
		    	  
		    	  if (list.size()>0)
		    	  {
			    	  for (int i=0;i < list.size(); i++)
			    	  {
			    		  if (CardUtil.getConvertedManaCost(list.get(i).getManaCost()) <= converted)
			    		  {
			    			  rebels.add(list.get(i));
			    		  }
			    			  
			    	  }
			    	  
			    	  if (rebels.size() > 0)
			    	  {
				    	  if (player.equals(Constant.Player.Computer))
				    	  {
				    		  Card rebel = CardFactoryUtil.AI_getBestCreature(rebels);
				    		  grave.remove(rebel);
				    		  play.add(rebel);
				    	  }
				    	  else //human
				    	  {
				    		  Object o = AllZone.Display.getChoiceOptional("Select target Rebel", rebels.toArray());
				    		  Card rebel = (Card)o;
				    		  grave.remove(rebel);
				    		  play.add(rebel);
				    	  }
			    	  }//rebels.size() >0
		    	  }//list.size() > 0
		      }//resolve
		  };
		  ability.setDescription("6: Return target Rebel permanent card with converted mana cost 5 or less from your graveyard to play.");
		  ability.setStackDescription(card.getName() +" - return Rebel from graveyard to play.");
		  card.addSpellAbility(ability);
    
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Marrow-Gnawer"))
    {
    	final String player = card.getController();
    	
    	final SpellAbility ability = new Ability_Tap(card)
        {
		  private static final long serialVersionUID = 447190529377334168L;

		  public void resolve()
          {
        	  PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
        	  CardList cards = new CardList(play.getCards());
        	  
        	  Card c = getTargetCard();
        	  if (c != null)
        	  {
	        	  AllZone.GameAction.sacrifice(c);
	        	  
	        	  CardList rats = new CardList();
	        	  
	        	  for (int i=0;i < cards.size(); i++)
	              {
	            	  if (cards.get(i).getType().contains("Rat") || cards.get(i).getKeyword().contains("Changeling")){
	            		  Card k = cards.get(i);
	            		  rats.add(k);
	            	  }    
	              } 
	        	  
	        	  if (!c.getName().equals("Marrow-Gnawer"))
	        	  {
		        	  for (int j=0; j < rats.size()-1; j++)
		        	  {
		        		 makeToken(); 
		        	  }
	        	  }
	        	  else //some weird thing when targeting marrow himself, number of rats is different... so here's a hack:
	        	  {
	        		  for (int k=0; k < rats.size(); k++)
	        		  {
	        			  makeToken();
	        		  }
	        	  }
        	  }
          }//resolve()
          
          public boolean canPlayAI()
          {
        	  CardList list = new CardList(AllZone.Computer_Play.getCards());
              list = list.getType("Rat");
              
              for (int i=0;i < list.size(); i++)
              {
              	String name = list.get(i).getName();
              	if (!name.equals("Marrow-Gnawer") && !name.equals("Relentless Rats"))
              		setTargetCard(list.get(i));
              	if (name.equals("B 1 1 Rat"))
              	{
              		setTargetCard(list.get(i));
              		break;
              	}
              	
              }

              if (getTargetCard() == null)
            	  System.out.println("getTargetCard null");
        	  if(getTargetCard() != null && list.size() > 3)
        		  return true;
        	  else
        		  return false;
          }

          
          public void makeToken()
          {
        	  Card c = new Card();

              c.setOwner(card.getController());
              c.setController(card.getController());

              c.setName("Rat");
              c.setImageName("B 1 1 Rat");
              c.setManaCost("B");
              c.setToken(true);

              c.addType("Creature");
              c.addType("Rat");
              c.setBaseAttack(1);
              c.setBaseDefense(1);

              PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
              play.add(c);
          }
          
          
        };//ability
        
        Input runtime = new Input()
        {
		  private static final long serialVersionUID = 8552290582665041908L;

		  public void showMessage()
          {
            CardList rats = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
            rats = rats.getType("Rat");
            
            stopSetNext(CardFactoryUtil.input_targetSpecific(ability, rats, "Select a Rat to sacrifice.", false));
          }
        };
        
        card.addSpellAbility(ability);
        ability.setDescription("Tap, Sacrifice a rat: Put X 1/1 black Rat creature tokens into play, where X is the number of Rats you control.");
        ability.setStackDescription(card.getName() + " - Put X 1/1 black Rat creature tokens into play, where X is the number of Rats you control.");
        ability.setBeforePayMana(runtime);
    	
    	
    }//*************** END ************ END **************************
  //*************** START *********** START **************************
    if(cardName.equals("Arcanis the Omnipotent"))
    {
	    final Ability_Tap ability = new Ability_Tap(card)
	    {
		  private static final long serialVersionUID = 4743686230518855738L;

		  public boolean canPlayAI()
	      {
	    	  return true;
	      }

	      public void resolve()
	      {
	        AllZone.GameAction.drawCard(card.getController());
	        AllZone.GameAction.drawCard(card.getController());
	        AllZone.GameAction.drawCard(card.getController());
	      }
	    };//SpellAbility
	    
	    final SpellAbility ability2 = new Ability(card,"2 U U")
	      {
	    	  public void resolve()
	          {
	    		  PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getOwner());
	    		  
	    		  card.untap();
	    		  AllZone.getZone(card).remove(card);
	    		  if (!card.isToken())
	    			  hand.add(card);
	    		  
	          }
	    	  public boolean canPlayAI()
	    	  {
	    		  return false;
	    	  }
	      }; //ability2
	    
	    card.addSpellAbility(ability);
	    ability.setDescription("tap: Draw three cards.");
	    ability.setStackDescription("Arcanis - " + card.getController() + " draws three cards.");
	    ability.setBeforePayMana(new Input_NoCost_TapAbility(ability));
	    
	    card.addSpellAbility(ability2);
	    ability2.setStackDescription(card.getController() + " returns Arcanis back to owner's hand.");
	    ability2.setDescription("2 U U: Return Arcanis the Omnipotent to its owner's hand.");
	    
  }//*************** END ************ END ************************** 
    
    
  //*************** START *********** START **************************
    if(cardName.equals("Lab Rats"))
    {
      final Command makeToken = new Command()
      {
		private static final long serialVersionUID = -6979735250385389139L;

		public void execute()
        {
            Card c = new Card();

            c.setOwner(card.getController());
            c.setController(card.getController());

            c.setName("Rat");
            c.setImageName("B 1 1 Rat");
            c.setManaCost("B");
            c.setToken(true);

            c.addType("Creature");
            c.addType("Rat");
            c.setBaseAttack(1);
            c.setBaseDefense(1);

            PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
            play.add(c);
        }//execute()
      };//Command

      final SpellAbility spell_one = new Spell(card)
      {
		private static final long serialVersionUID = -8112024383172056976L;

		public boolean canPlayAI() {return false;}

        public void resolve()
        {
          makeToken.execute();
        }//resolve()
      };//SpellAbility

      final SpellAbility spell_two = new Spell(card)
      {
		private static final long serialVersionUID = -7503701530510847636L;

		public void resolve()
        {
          makeToken.execute();

          //return card to the hand
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          AllZone.GameAction.moveTo(hand, card);
        }
        
        public boolean canPlayAI()
        {
           String phase = AllZone.Phase.getPhase();
      	   return phase.equals(Constant.Phase.Main2);
        }
      };//SpellAbility

      spell_one.setManaCost("B");
      spell_two.setManaCost("4 B");

      spell_one.setDescription("Put a 1/1 black Rat token into play.");
      spell_two.setDescription("Buyback 4 - Pay 4B, put this card into your hand as it resolves.");

      spell_one.setStackDescription("Lab Rats - Put a 1/1 black Rat token into play");
      spell_two.setStackDescription("Lab Rats - Buyback, Put a 1/1 black Rat token into play");

      spell_two.setIsBuyBackAbility(true);
      
      card.clearSpellAbility();
      card.addSpellAbility(spell_one);
      card.addSpellAbility(spell_two);
    }//*************** END ************ END **************************

    //*************** START *********** START **************************
    if(cardName.equals("Sprout Swarm"))
    {
      final Command makeToken = new Command()
      {
		private static final long serialVersionUID = 648546709124047998L;

		public void execute()
        {
            Card c = new Card();

            c.setOwner(card.getController());
            c.setController(card.getController());

            c.setName("Saproling");
            c.setImageName("G 1 1 Saproling");
            c.setManaCost("G");
            c.setToken(true);

            c.addType("Creature");
            c.addType("Saproling");
            c.setBaseAttack(1);
            c.setBaseDefense(1);

            PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
            play.add(c);
        }//execute()
      };//Command

      final SpellAbility spell_one = new Spell(card)
      {
		private static final long serialVersionUID = -609007714604161377L;

		public boolean canPlayAI() {return false;}

        public void resolve()
        {
          makeToken.execute();
        }//resolve()
      };//SpellAbility

      final SpellAbility spell_two = new Spell(card)
      {
		private static final long serialVersionUID = -1387385820860395676L;

		public void resolve()
        {
          makeToken.execute();

          //return card to the hand
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          AllZone.GameAction.moveTo(hand, card);
        }
      };//SpellAbility

      spell_one.setManaCost("1 G");
      spell_two.setManaCost("4 G");

      spell_one.setDescription("Put a 1/1 green Saproling token into play. -- Sorry no convoke yet.");
      spell_two.setDescription("Buyback 3 - Pay 4G, put this card into your hand as it resolves.");

      spell_one.setStackDescription("Sprout Swarm - Put a 1/1 green Saproling token into play");
      spell_two.setStackDescription("Sprout Swarm - Buyback, Put a 1/1 green Saproling token into play");
      
      spell_two.setIsBuyBackAbility(true);

      card.clearSpellAbility();
      card.addSpellAbility(spell_one);
      card.addSpellAbility(spell_two);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Threaten") || cardName.equals("Act of Treason"))
    {
      final PlayerZone[] orig = new PlayerZone[1];
      final PlayerZone[] temp = new PlayerZone[1];
      final String[] controllerEOT = new String[1];
      final Card[] target          = new Card[1];

      final Command untilEOT = new Command()
      {
		private static final long serialVersionUID = 5310901886760561889L;

		public void execute()
        {
          //if card isn't in play, do nothing
          if(! AllZone.GameAction.isCardInPlay(target[0]))
            return;

          target[0].setController(controllerEOT[0]);

          ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
          ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);

          //moveTo() makes a new card, so you don't have to remove "Haste"
          //AllZone.GameAction.moveTo(playEOT[0], target[0]);
          temp[0].remove(target[0]);
          orig[0].add(target[0]);
          target[0].untap();
          target[0].removeExtrinsicKeyword("Haste");
          
          ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
          ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
        }//execute()
      };//Command

      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -3447822168516135816L;
		
		public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            orig[0]       = AllZone.getZone(getTargetCard());
            controllerEOT[0] = getTargetCard().getController();
            target[0]        = getTargetCard();

            //set the controller
            getTargetCard().setController(card.getController());

            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);

            PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
            play.add(getTargetCard());
            temp[0] = play;
            orig[0].remove(getTargetCard());

            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);


            getTargetCard().untap();
            getTargetCard().addExtrinsicKeyword("Haste");

            AllZone.EndOfTurn.addUntil(untilEOT);
          }//is card in play?
        }//resolve()
        public boolean canPlayAI()
        {
          //only use this card if creatures power is greater than 2
          CardList list = new CardList(AllZone.Human_Play.getCards());
          for(int i = 0; i < list.size(); i++)
            if(2 < list.get(i).getNetAttack())
              return true;

          return false;
        }//canPlayAI()
        public void chooseTargetAI()
        {
          CardList list = new CardList(AllZone.Human_Play.getCards());
          setTargetCard(CardFactoryUtil.AI_getBestCreature(list));
        }
      };//SpellAbility
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Beacon of Unrest"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -7614131436905786565L;
		
		public void resolve()
        {
          Card c = getTargetCard();
          PlayerZone grave = AllZone.getZone(c);

          if(AllZone.GameAction.isCardInZone(c, grave) && (c.isArtifact() || c.isCreature()))
          {
            //set the correct controller if needed
            c.setController(card.getController());

            //card changes zones
            AllZone.getZone(c).remove(c);
            PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
            play.add(c);

            //shuffle card back into the library
            PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
            library.add(card);
            AllZone.GameAction.shuffle(card.getController());
          }
        }//resolve()
        public boolean canPlay()
        {
          return getCreaturesAndArtifacts().length != 0;
        }

        public Card[] getCreaturesAndArtifacts()
        {
          CardList graveyardCards = new CardList();
          graveyardCards.addAll(AllZone.Human_Graveyard.getCards());
          graveyardCards.addAll(AllZone.Computer_Graveyard.getCards());

          CardList graveyardCreaturesAndArtifacts = graveyardCards.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isArtifact() || c.isCreature();
            }
          });

          return graveyardCreaturesAndArtifacts.toArray();
        }
        public void chooseTargetAI()
        {
          Card c[] = getCreaturesAndArtifacts();
          Card biggest = c[0];
          for(int i = 0; i < c.length; i++)
            if(biggest.getNetAttack() < c[i].getNetAttack())
              biggest = c[i];

          setTargetCard(biggest);
        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      Input target = new Input()
      {
		private static final long serialVersionUID = -83460850846474327L;

		public void showMessage()
        {
          Object check = AllZone.Display.getChoiceOptional("Select creature", getCreaturesAndArtifacts());
          if(check != null)
          {
            spell.setTargetCard((Card)check);
            stopSetNext(new Input_PayManaCost(spell));
          }
          else
            stop();
        }//showMessage()

        //duplicated from SpellAbility above ^^^^^^^^
        public Card[] getCreaturesAndArtifacts()
        {
          CardList graveyardCards = new CardList();
          graveyardCards.addAll(AllZone.Human_Graveyard.getCards());
          graveyardCards.addAll(AllZone.Computer_Graveyard.getCards());

          CardList graveyardCreaturesAndArtifacts = graveyardCards.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isArtifact() || c.isCreature();
            }
          });

          return graveyardCreaturesAndArtifacts.toArray();
        }
      };//Input
      spell.setBeforePayMana(target);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Breath of Life") || cardName.equals("Resurrection") || cardName.equals("False Defeat") || cardName.equals("Zombify"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -5799646914112924814L;
		
		public void resolve()
        {
          Card c = getTargetCard();
          PlayerZone grave = AllZone.getZone(c);

          if(AllZone.GameAction.isCardInZone(c, grave))
          {
            PlayerZone play = AllZone.getZone(Constant.Zone.Play, c.getController());
            AllZone.GameAction.moveTo(play, c);
          }
        }//resolve()
        public boolean canPlay()
        {
          return getCreatures().length != 0;
        }
        public Card[] getCreatures()
        {
          CardList creature = new CardList();
          PlayerZone zone = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          creature.addAll(zone.getCards());
          creature = creature.getType("Creature");
          return creature.toArray();
        }
        public void chooseTargetAI()
        {
          Card c[] = getCreatures();
          Card biggest = c[0];
          for(int i = 0; i < c.length; i++)
            if(biggest.getNetAttack() < c[i].getNetAttack())
              biggest = c[i];

          setTargetCard(biggest);
        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      Input target = new Input()
      {
		private static final long serialVersionUID = -3717723884199321767L;

		public void showMessage()
        {
          Object check = AllZone.Display.getChoiceOptional("Select creature", getCreatures());
          if(check != null)
          {
            spell.setTargetCard((Card)check);
            stopSetNext(new Input_PayManaCost(spell));
          }
          else
            stop();
        }//showMessage()

        public Card[] getCreatures()
        {
          CardList creature = new CardList();
          PlayerZone zone = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          creature.addAll(zone.getCards());
          creature = creature.getType("Creature");
          return creature.toArray();
        }
      };//Input
      spell.setBeforePayMana(target);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Horde of Notions"))
    {
      final Ability ability = new Ability(card, "W U B R G")
      {
        public void resolve()
        {
          Card c = null;
          if (card.getController().equals("Human"))
          {
        	  Object o = AllZone.Display.getChoiceOptional("Select Elemental", getCreatures());
        	  c = (Card)o;    	          	 
        	  
          }
          else 
          {
        	  c = getAIElemental();
          }
          
          PlayerZone grave = AllZone.getZone(c);

          if(AllZone.GameAction.isCardInZone(c, grave))
          {
            PlayerZone play = AllZone.getZone(Constant.Zone.Play, c.getController());
            AllZone.GameAction.moveTo(play, c);
          }
        }//resolve()
        public boolean canPlay()
        {
          return getCreatures().length != 0 && AllZone.GameAction.isCardInPlay(card);
        }
        public Card[] getCreatures()
        {
          CardList creature = new CardList();
          PlayerZone zone = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          creature.addAll(zone.getCards());
          creature = creature.getType("Elemental");
          return creature.toArray();
        }
        public Card getAIElemental()
        {
          Card c[] = getCreatures();
          Card biggest = c[0];
          for(int i = 0; i < c.length; i++)
            if(biggest.getNetAttack() < c[i].getNetAttack())
              biggest = c[i];

          return biggest;
        }
      };//SpellAbility
      card.addSpellAbility(ability);
      
      ability.setDescription("W U B R G: You may play target Elemental card from your graveyard without paying its mana cost.");
      //ability.setBeforePayMana(new Input_);
      ability.setStackDescription("Horde of Notions - play Elemental card from graveyard without paying its mana cost.");
      ability.setBeforePayMana(new Input_PayManaCost(ability));
     
    }//*************** END ************ END **************************
    


    //*************** START *********** START **************************
    if(cardName.equals("Animate Dead"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 182812167945075560L;

		public void resolve()
        {
          Card c = getTargetCard();

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          PlayerZone grave = AllZone.getZone(c);

          if(AllZone.GameAction.isCardInZone(c, grave))
          {
            c.addSemiPermanentAttackBoost(-1);
            c.setController(card.getController());

            play.add(c);
            grave.remove(c);
          }
        }//resolve()
        public boolean canPlay()
        {
          return getCreatures().length != 0;
        }
        public Card[] getCreatures()
        {
          //get all creatures
          CardList list = new CardList();
          list.addAll(AllZone.Human_Graveyard.getCards());
          list.addAll(AllZone.Computer_Graveyard.getCards());
          list = list.getType("Creature");

          return list.toArray();
        }
        public boolean canPlayAI()
        {
          CardList all = new CardList(getCreatures());
          if(all.isEmpty())
            return false;

          Card c = CardFactoryUtil.AI_getBestCreature(all);

          if(2 < c.getNetAttack() && 2 < c.getNetDefense())
            return true;

          return false;
        }

        public void chooseTargetAI()
        {
          Card c[] = getCreatures();
          Card biggest = c[0];
          for(int i = 0; i < c.length; i++)
            if(biggest.getNetAttack() < c[i].getNetAttack())
              biggest = c[i];

          setTargetCard(biggest);
        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      Input target = new Input()
      {
		private static final long serialVersionUID = 9027742835781889044L;

		public void showMessage()
        {
          Object check = AllZone.Display.getChoiceOptional("Select creature", getCreatures());
          if(check != null)
          {
            spell.setTargetCard((Card)check);
            stopSetNext(new Input_PayManaCost(spell));
          }
          else
            stop();
        }//showMessage()

        public Card[] getCreatures()
        {
          //get all creatures
          CardList list = new CardList();
          list.addAll(AllZone.Human_Graveyard.getCards());
          list.addAll(AllZone.Computer_Graveyard.getCards());
          list = list.getType("Creature");

          return list.toArray();
        }
      };//Input
      spell.setBeforePayMana(target);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Blinding Light"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -631672055247954361L;
		
		public void resolve()
        {
          CardList nonwhite = new CardList();
          nonwhite.addAll(AllZone.Human_Play.getCards());
          nonwhite.addAll(AllZone.Computer_Play.getCards());
          nonwhite = nonwhite.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isCreature() && (!CardUtil.getColors(c).contains(Constant.Color.White));
            }
          });
          for(int i = 0; i < nonwhite.size(); i++)
            nonwhite.get(i).tap();
        }//resolve()
        public boolean canPlayAI()
        {
          //the computer seems to play this card at stupid times
          return false;
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Raise the Alarm"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 3022771853846089829L;

		public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          for (int i = 0; i < 2; i++)
          {
            Card c = new Card();

            c.setOwner(card.getController());
            c.setController(card.getController());

            c.setName("Soldier");
            c.setImageName("W 1 1 Soldier");
            c.setManaCost("W");
            c.setToken(true);

            c.addType("Creature");
            c.addType("Soldier");
            c.setBaseAttack(1);
            c.setBaseDefense(1);

            play.add(c);
          }//for
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Dragon Fodder"))
    {
      SpellAbility spell = new Spell(card)
      {
      private static final long serialVersionUID = -6704097906643840324L;

      public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          for (int i = 0; i < 2; i++)
          {
            Card c = new Card();

            c.setOwner(card.getController());
            c.setController(card.getController());

            c.setName("Goblin");
            c.setImageName("R 1 1 Goblin");
            c.setManaCost("R");
            c.setToken(true);

            c.addType("Creature");
            c.addType("Goblin");
            c.setBaseAttack(1);
            c.setBaseDefense(1);

            play.add(c);
          }//for
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Empty the Warrens"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 1439643889038241969L;

		public void resolve()
        {
          int stormCount = 0;

          //get storm count
          CardList list = new CardList();
          list.addAll(AllZone.Human_Graveyard.getCards());
          list.addAll(AllZone.Computer_Graveyard.getCards());

          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());

          for(int i = 0; i < list.size(); i++)
            if(list.get(i).getTurnInZone() == AllZone.Phase.getTurn())
              stormCount++;

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          for (int i = 0; i < 2 * stormCount; i++)
          {
            Card c = new Card();

            c.setOwner(card.getController());
            c.setController(card.getController());

            c.setName("Goblin");
            c.setImageName("R 1 1 Goblin");
            c.setManaCost("R");
            c.setToken(true);

            c.addType("Creature");
            c.addType("Goblin");
            c.setBaseAttack(1);
            c.setBaseDefense(1);

            play.add(c);
          }//for
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Feudkiller's Verdict"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -5532477141899236266L;

		public void resolve()
        {
          PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
          life.addLife(10);

          String opponent = AllZone.GameAction.getOpponent(card.getController());
          PlayerLife oppLife = AllZone.GameAction.getPlayerLife(opponent);

          if(oppLife.getLife() < life.getLife())
            makeToken();
        }//resolve()

        void makeToken()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Giant Warrior");
          c.setImageName("W 5 5 Giant Warrior");
          c.setManaCost("W");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Giant");
          c.addType("Warrior");
          c.setBaseAttack(5);
          c.setBaseDefense(5);

          play.add(c);
        }//makeToken()

      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Reach of Branches"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 2723115210677439611L;

		public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());

          //make token
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Treefolk Shaman");
          c.setImageName("G 2 5 Treefolk Shaman");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Treefolk");
          c.addType("Shaman");
          c.setBaseAttack(2);
          c.setBaseDefense(5);

          play.add(c);
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Pyroclasm"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 8035123529251645470L;
		
		public void resolve()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());
          all = all.getType("Creature");

          for(int i = 0; i < all.size(); i++)
          {
            if (CardFactoryUtil.canDamage(card,all.get(i)))
        	  all.get(i).addDamage(2);
          }
        }
        public boolean canPlayAI()
        {
          CardList human    = new CardList(AllZone.Human_Play.getCards());
          CardList computer = new CardList(AllZone.Computer_Play.getCards());

          human    = human.getType("Creature");
          computer = computer.getType("Creature");

          human = CardListUtil.filterToughness(human, 2);
          computer = CardListUtil.filterToughness(computer, 2);

          //the computer will at least destroy 2 more human creatures
          return computer.size() < human.size()-1;
        }//canPlayAI()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Volcanic Fallout"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 8274309635261086286L;
		public void resolve()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());
          all = all.getType("Creature");

          for(int i = 0; i < all.size(); i++)
          {
            if (CardFactoryUtil.canDamage(card,all.get(i)))
        	  all.get(i).addDamage(2);
          }
          
          PlayerLife compLife = AllZone.GameAction.getPlayerLife(Constant.Player.Computer);
          compLife.subtractLife(2);
          
          PlayerLife humLife = AllZone.GameAction.getPlayerLife(Constant.Player.Human);
          humLife.subtractLife(2);
          
        }
        public boolean canPlayAI()
        {
          CardList human    = new CardList(AllZone.Human_Play.getCards());
          CardList computer = new CardList(AllZone.Computer_Play.getCards());

          human    = human.getType("Creature");
          computer = computer.getType("Creature");

          human = CardListUtil.filterToughness(human, 2);
          computer = CardListUtil.filterToughness(computer, 2);

          PlayerLife compLife = AllZone.GameAction.getPlayerLife(Constant.Player.Computer);
          
          //the computer will at least destroy 2 more human creatures
          return computer.size() < human.size()-1 && compLife.getLife() > 3;
        }//canPlayAI()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Flamebreak"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -4224693616606508949L;
		
		public boolean canPlayAI()
        {
          return AllZone.Computer_Life.getLife()>3;
        }
        public void resolve()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());
          all = all.getType("Creature");

          for(int i = 0; i < all.size(); i++)
            if(! all.get(i).getKeyword().contains("Flying"))
            {
            	if (CardFactoryUtil.canDamage(card, all.get(i)))
            	{            		
            		all.get(i).setShield(0);
            		all.get(i).addDamage(3);
            	}
            }

          AllZone.Human_Life.subtractLife(3);
          AllZone.Computer_Life.subtractLife(3);
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Renewed Faith") || cardName.equals("Dosan's Oldest Chant") || cardName.equals("Nourish"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -1133816506198725425L;

		public boolean canPlay()
        {
          setStackDescription(card.getName() +" - " +card.getController() +" gains 6 life.");
          return super.canPlay();
        }

        public void resolve()
        {
          PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
          life.addLife(6);
        }
      };
      spell.setDescription("You gain 6 life.");

      card.clearSpellAbility();
      card.addSpellAbility(spell);
      if (cardName.equals("Renewed Faith")) {
    	  card.addSpellAbility(CardFactoryUtil.ability_cycle(card, "1 W"));
    	  card.addCycleCommand(new Command(){
			private static final long serialVersionUID = 7699412574052780825L;

			public void execute() 
    		{
				PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
				life.addLife(2);
    		}
    	  });
      }
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("TestLife"))
    {
      SpellAbility ability1 = new Ability_Activated(card, "1")
      {
		private static final long serialVersionUID = -7597743923692184213L;

		public void resolve()
        {
          PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
          life.addLife(1);
        }
      };
      ability1.setStackDescription(card.getController() +" gains 1 life");
      ability1.setDescription("1: gain 1 life");
      card.addSpellAbility(ability1);

      SpellAbility ability2 = new Ability_Activated(card, "1")
      {
		private static final long serialVersionUID = 1423759257249171223L;

		public void resolve()
        {
          PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
          life.subtractLife(1);
        }
      };
      ability2.setStackDescription(card.getController() +" looses 1 life");
      ability2.setDescription("1: loose 1 life");
      card.addSpellAbility(ability2);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Life Burst"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 5653342880372240806L;

		public void resolve()
        {
          CardList count = new CardList();
          count.addAll(AllZone.Human_Graveyard.getCards());
          count.addAll(AllZone.Computer_Graveyard.getCards());
          count = count.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.getName().equals("Life Burst");
            }
          });

          PlayerLife life = AllZone.GameAction.getPlayerLife(getTargetPlayer());
          life.addLife(4 + (4 * count.size()));
        }
      };
      spell.setChooseTargetAI(CardFactoryUtil.AI_targetComputer());
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell));
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Accumulated Knowledge"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -7650377883588723237L;

		public void resolve()
        {
          CardList count = new CardList();
          count.addAll(AllZone.Human_Graveyard.getCards());
          count.addAll(AllZone.Computer_Graveyard.getCards());
          count = count.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.getName().equals("Accumulated Knowledge");
            }
          });

          for (int i=0;i<=count.size();i++)
          {
        	  AllZone.GameAction.drawCard(card.getController());
          }
        }
      };
      spell.setDescription("Draw a card, then draw cards equal to the number of cards named Accumulated Knowledge in all graveyards.");
      spell.setStackDescription(cardName + " - Draw a card, then draw cards equal to the number of cards named Accumulated Knowledge in all graveyards.");
      card.clearSpellAbility();
      card.addSpellAbility(spell);

    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Wit's End"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 3829311830858468029L;

		public void resolve()
        {
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, getTargetPlayer());
          Card c[] = hand.getCards();
          for(int i = 0; i < c.length; i++)
            AllZone.GameAction.discard(c[i]);
        }
      };
      spell.setChooseTargetAI(CardFactoryUtil.AI_targetHuman());
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell));
    }//*************** END ************ END **************************


  //*************** START *********** START **************************
    if(cardName.equals("Cranial Extraction"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 8127696608769903507L;
		
		@SuppressWarnings("unchecked") // Comparator
		public void resolve()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          Card choice = null;

          //check for no cards in library
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, opponent);

          if(library.size() == 0) //this is not right, but leaving it in here for now.
            return;

          //human chooses
          if(opponent.equals(Constant.Player.Computer))
          {
            CardList all = AllZone.CardFactory.getAllCards();
            all.sort(new Comparator()
            {
              public int compare(Object a1, Object b1)
              {
                Card a = (Card)a1;
                Card b = (Card)b1;

                return a.getName().compareTo(b.getName());
              }
            });
            choice = (Card) AllZone.Display.getChoice("Choose", removeLand(all.toArray()));

            Card[] showLibrary = library.getCards();
            Comparator com = new TableSorter(new CardList(showLibrary), 2, true);
            Arrays.sort(showLibrary, com);

            AllZone.Display.getChoiceOptional("Opponent's Library", showLibrary);
            AllZone.GameAction.shuffle(opponent);
          }//if
          else//computer chooses
          {
            //the computer cheats by choosing a creature in the human players library or hand
            CardList all = new CardList();
            all.addAll(AllZone.Human_Hand.getCards());
            all.addAll(AllZone.Human_Library.getCards());

            CardList four = all.filter(new CardListFilter()
            {
              public boolean addCard(Card c)
              {
                if(c.isLand())
                  return false;

                return 3 < CardUtil.getConvertedManaCost(c.getManaCost());
              }
            });
            if(! four.isEmpty())
              choice = CardUtil.getRandom(four.toArray());
            else
              choice = CardUtil.getRandom(all.toArray());

          }//else
          remove(choice, opponent);
          AllZone.GameAction.shuffle(opponent);
        }//resolve()

        void remove(Card c, String player)
        {
          PlayerZone hand    = AllZone.getZone(Constant.Zone.Hand, player);
          PlayerZone grave   = AllZone.getZone(Constant.Zone.Graveyard, player);
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, player);

          CardList all = new CardList();
          all.addAll(hand.getCards());
          all.addAll(grave.getCards());
          all.addAll(library.getCards());

          for(int i = 0; i < all.size(); i++)
            if(all.get(i).getName().equals(c.getName())){
               if(player.equals(Constant.Player.Human)){
                  AllZone.GameAction.moveTo(AllZone.Human_Removed, all.get(i));
               }
               else{
                  AllZone.GameAction.moveTo(AllZone.Computer_Removed, all.get(i));
               }
            }
        }//remove()

        public boolean canPlayAI()
        {
          Card[] c = removeLand(AllZone.Human_Library.getCards());
          return 0 < c.length;
        }
        Card[] removeLand(Card[] in)
        {
          CardList c = new CardList(in);
          c = c.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return !c.isLand();
            }
          });
          return c.toArray();
        }//removeLand()
      };//SpellAbility spell
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(new Input_PayManaCost(spell));
      spell.setStackDescription(card.getName() +" - targeting opponent");
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Coercion"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 7200945225788294439L;

		public void resolve()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          Card choice = null;

          //check for no cards in hand on resolve
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, opponent);
          Card[] handChoices = removeLand(hand.getCards());

          if(handChoices.length == 0)
            return;

          //human chooses
          if(opponent.equals(Constant.Player.Computer))
          {
            choice = (Card) AllZone.Display.getChoice("Choose", handChoices);
          }
          else//computer chooses
          {
            choice = CardUtil.getRandom(handChoices);
          }

          AllZone.GameAction.discard(choice);
        }//resolve()

        public boolean canPlayAI()
        {
          Card[] c = removeLand(AllZone.Human_Hand.getCards());
          return 0 < c.length;
        }

        Card[] removeLand(Card[] in)
        {
          return in;
        }//removeLand()
      };//SpellAbility spell
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(new Input_PayManaCost(spell));
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Brainbite"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 6967309558624188256L;

		public void resolve()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          Card choice = null;

          //check for no cards in hand on resolve
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, opponent);
          Card[] handChoices = removeLand(hand.getCards());

          if(handChoices.length == 0){
        	  AllZone.GameAction.drawCard(card.getController());
        	  return;
          }
            

          //human chooses
          if(opponent.equals(Constant.Player.Computer))
          {
            choice = (Card) AllZone.Display.getChoice("Choose", handChoices);
          }
          else//computer chooses
          {
            choice = CardUtil.getRandom(handChoices);
          }

          AllZone.GameAction.discard(choice);
          AllZone.GameAction.drawCard(card.getController());
        }//resolve()

        public boolean canPlayAI()
        {
          Card[] c = removeLand(AllZone.Human_Hand.getCards());
          return 0 < c.length;
        }

        Card[] removeLand(Card[] in)
        {
          return in;
        }//removeLand()
      };//SpellAbility spell
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(new Input_PayManaCost(spell));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Thoughtseize") || cardName.equals("Distress"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 5338238621454661783L;

		public void resolve()
        {
          if(cardName.equals("Thoughtseize"))
            AllZone.GameAction.getPlayerLife(card.getController()).subtractLife(2);

          Card choice = null;

          //check for no cards in hand on resolve
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, getTargetPlayer());
          Card[] handChoices = removeLand(hand.getCards());

          if(handChoices.length == 0)
            return;

          //human chooses
          if(card.getController().equals(Constant.Player.Human))
          {
            choice = (Card) AllZone.Display.getChoice("Choose", handChoices);
          }
          else//computer chooses
          {
            choice = CardUtil.getRandom(handChoices);
          }

          AllZone.GameAction.discard(choice);
        }//resolve()

        public boolean canPlayAI()
        {
          Card[] c = removeLand(AllZone.Human_Hand.getCards());
          return 0 < c.length;
        }

        Card[] removeLand(Card[] in)
        {
          CardList c = new CardList(in);
          c = c.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return !c.isLand();
            }
          });
          return c.toArray();
        }//removeLand()
      };//SpellAbility spell
      spell.setChooseTargetAI(CardFactoryUtil.AI_targetHuman());
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Douse in Gloom"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 7134826062024728943L;

		public boolean canPlayAI()
        {
          CardList c = getCreature();
          if(c.isEmpty())
            return false;
          else
          {
            setTargetCard(c.get(0));
            return true;
          }
        }//canPlayAI()
        CardList getCreature()
        {
          CardList out = new CardList();
          CardList list = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          list.shuffle();

          for(int i = 0; i < list.size(); i++)
            if((list.get(i).getNetAttack() >= 2) && (list.get(i).getNetDefense() <= 2))
              out.add(list.get(i));

          //in case human player only has a few creatures in play, target anything
          if(out.isEmpty() &&
              0 < CardFactoryUtil.AI_getHumanCreature(2, card, true).size() &&
             3 > CardFactoryUtil.AI_getHumanCreature(card, true).size())
          {
            out.addAll(CardFactoryUtil.AI_getHumanCreature(2, card, true).toArray());
            CardListUtil.sortFlying(out);
          }
          return out;
        }//getCreature()


        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            getTargetCard().addDamage(2);
            AllZone.GameAction.getPlayerLife(card.getController()).addLife(2);
          }
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Echoing Decay"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 3154935854257358023L;

		public boolean canPlayAI()
        {
          CardList c = getCreature();
          if(c.isEmpty())
            return false;
          else
          {
            setTargetCard(c.get(0));
            return true;
          }
        }//canPlayAI()
        CardList getCreature()
        {
          CardList out = new CardList();
          CardList list = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          list.shuffle();

          for(int i = 0; i < list.size(); i++)
            if((list.get(i).getNetAttack() >= 2) && (list.get(i).getNetDefense() <= 2))
              out.add(list.get(i));

          //in case human player only has a few creatures in play, target anything
          if(out.isEmpty() &&
              0 < CardFactoryUtil.AI_getHumanCreature(2, card, true).size() &&
             3 > CardFactoryUtil.AI_getHumanCreature(card, true).size())
          {
            out.addAll(CardFactoryUtil.AI_getHumanCreature(2, card, true).toArray());
            CardListUtil.sortFlying(out);
          }
          return out;
        }//getCreature()


        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            final Card c = getTargetCard();
            
            c.addTempAttackBoost(-2);
          	c.addTempDefenseBoost(-2);

          	AllZone.EndOfTurn.addUntil(new Command()
          	{
				private static final long serialVersionUID = 1327455269456577020L;

				public void execute()
          		{
          			c.addTempAttackBoost(2);
          			c.addTempDefenseBoost(2);
          		}
          	});

            //get all creatures
            CardList list = new CardList();
            list.addAll(AllZone.Human_Play.getCards());
            list.addAll(AllZone.Computer_Play.getCards());

            list = list.getName(getTargetCard().getName());
            list.remove(getTargetCard());
              
            if (!getTargetCard().isFaceDown())
	            for(int i = 0; i < list.size(); i++)
	            {
	            	final Card crd = list.get(i);
	            	
	            	crd.addTempAttackBoost(-2);
	            	crd.addTempDefenseBoost(-2);
	            	
	            	AllZone.EndOfTurn.addUntil(new Command()
	              	{
						private static final long serialVersionUID = 5151337777143949221L;

						public void execute()
	              		{
	              			crd.addTempAttackBoost(2);
	              			crd.addTempDefenseBoost(2);
	              		}
	              	});
	            	//list.get(i).addDamage(2);
	            }
	              
          }//in play?
        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Maelstrom Pulse"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -4050843868789582138L;

		public boolean canPlayAI()
        {
          CardList c = getCreature();
          if(c.isEmpty())
            return false;
          else
          {
            setTargetCard(c.get(0));
            return true;
          }
        }//canPlayAI()
        CardList getCreature()
        {
          CardList out = new CardList();
          CardList list = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          list.shuffle();

          for(int i = 0; i < list.size(); i++)
            if((list.get(i).getNetAttack() >= 2) && (list.get(i).getNetDefense() <= 2))
              out.add(list.get(i));

          //in case human player only has a few creatures in play, target anything
          if(out.isEmpty() &&
              0 < CardFactoryUtil.AI_getHumanCreature(2, card, true).size() &&
             3 > CardFactoryUtil.AI_getHumanCreature(card, true).size())
          {
            out.addAll(CardFactoryUtil.AI_getHumanCreature(2, card, true).toArray());
            CardListUtil.sortFlying(out);
          }
          return out;
        }//getCreature()


        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {

        	AllZone.GameAction.destroy(getTargetCard());
        	
            if(! getTargetCard().isToken() && !getTargetCard().isFaceDown())
            {
              //get all creatures
              CardList list = new CardList();
              list.addAll(AllZone.Human_Play.getCards());
              list.addAll(AllZone.Computer_Play.getCards());

              list = list.getName(getTargetCard().getName());
              list.remove(getTargetCard());
              
              if (!getTargetCard().isFaceDown())
	              for(int i = 0; i < list.size(); i++)
	                AllZone.GameAction.destroy(list.get(i));
            }//is token?
          }//in play?
        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      Input target = new Input()
      {
		private static final long serialVersionUID = -4947592326270275532L;
		
		public void showMessage()
    	{
    	  AllZone.Display.showMessage("Select target non-land permanent for " +spell.getSourceCard());
    	  ButtonUtil.enableOnlyCancel();
    	}
    	public void selectButtonCancel() {stop();}
    	public void selectCard(Card card, PlayerZone zone)
    	{
    	  if(zone.is(Constant.Zone.Play) && !card.isLand())
    	  {
    		spell.setTargetCard(card);
    		stopSetNext(new Input_PayManaCost(spell));
    	  }
    	}
      };//Input
      
      spell.setBeforePayMana(target);
    }//*************** END ************ END **************************
    




    //*************** START *********** START **************************
	if(cardName.equals("Ravenous Rats") || cardName.equals("Corrupt Court Official"))
	{
		final Ability ability = new Ability(card,"0")
	    {
	      public boolean canPlayAI()
	      {
	    	  return true;	       
	      }
	      public void resolve()
	      {
	        if(Constant.Player.Computer.equals(getTargetPlayer()))
	          AllZone.GameAction.discardRandom(getTargetPlayer());
	        else
	          AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
	      }//resolve()
	    };//SpellAbility
	    
	  Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -2028008593708491452L;

		public void execute()
        {
          if(card.getController().equals(Constant.Player.Human))
          {
            AllZone.InputControl.setInput(CardFactoryUtil.input_targetPlayer(ability));
            ButtonUtil.disableAll();
          }
          else//computer
          {
        	ability.setTargetPlayer(Constant.Player.Human);
            AllZone.Stack.add(ability);
          }//else
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);
    
  }//*************** END ************ END **************************
	
 //*************** START *********** START **************************
  if(cardName.equals("Boris Devilboon"))
  {		
		final Ability_Tap tokenAbility1 = new Ability_Tap(card, "2 B R")
	    {
			private static final long serialVersionUID = -6343382804503119405L;

			public boolean canPlayAI()
	        {
	          String phase = AllZone.Phase.getPhase();
	          return phase.equals(Constant.Phase.Main2);
	        }
	        public void chooseTargetAI() {card.tap();}

	        public void resolve()
	        {
	          Card c = new Card();

	          c.setOwner(card.getController());
	          c.setController(card.getController());

	          c.setName("Minor Demon");
	          c.setImageName("BR 1 1 Demon");
	          c.setManaCost("B R");
	          c.setToken(true);

	          c.addType("Creature");
	          c.addType("Demon");

	          c.setBaseAttack(1);
	          c.setBaseDefense(1);

	          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
	          play.add(c);
	        }//resolve()
	      };//SpellAbility

	      card.addSpellAbility(tokenAbility1);

	      tokenAbility1.setDescription("2 B R, tap: Put a 1/1 black and red Demon creature token named Minor Demon onto the battlefield.");
	      tokenAbility1.setStackDescription(card.getName() + " - Put a 1/1 black and red Demon creature token named Minor Demon onto the battlefield.");
	      tokenAbility1.setBeforePayMana(new Input_PayManaCost(tokenAbility1));
  }
	  
  //*************** START *********** START **************************
  if(cardName.equals("Rhys the Redeemed"))
  {		
		final Ability_Tap tokenAbility1 = new Ability_Tap(card, "2 GW")
	      {
			private static final long serialVersionUID = 411298860775527337L;

			public boolean canPlayAI()
	        {
	          String phase = AllZone.Phase.getPhase();
	          return phase.equals(Constant.Phase.Main2);
	        }
	        public void chooseTargetAI() {card.tap();}

	        public void resolve()
	        {
	          Card c = new Card();

	          c.setOwner(card.getController());
	          c.setController(card.getController());

	          c.setName("Elf Warrior");
	          c.setImageName("GW 1 1 Elf Warrior");
	          c.setManaCost("GW");
	          c.setToken(true);

	          c.addType("Creature");
	          c.addType("Elf");
	          c.addType("Warrior");

	          c.setBaseAttack(1);
	          c.setBaseDefense(1);

	          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
	          play.add(c);
	        }//resolve()
	      };//SpellAbility

	      card.addSpellAbility(tokenAbility1);

	      tokenAbility1.setDescription("2 GW, tap: Put a 1/1 green and white Elf Warrior creature token into play.");
	      tokenAbility1.setStackDescription(card.getName() + " - Put a 1/1 green and white Elf Warrior creature token into play.");
	      tokenAbility1.setBeforePayMana(new Input_PayManaCost(tokenAbility1));
	      
	      /////////////////////////////////////////////////////////////////////
	       
	      final Ability_Tap copyTokens1 = new Ability_Tap(card, "4 GW GW")
	      {
			private static final long serialVersionUID = 6297992502069547478L;

			public void resolve()
	    	  {
	    		  PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
	    		  CardList allTokens = new CardList();
	    		  allTokens.addAll(play.getCards());
	    		  allTokens = allTokens.filter(new CardListFilter()
	    		  {
	    			  public boolean addCard(Card c)
	    			  {
	    				  return c.isCreature() && c.isToken();
	    			  }
	    		  });
	    		  
	    		  for (int i=0;i<allTokens.size();i++)
	    		  {
	    			  Card c = allTokens.get(i);
	    			  copyToken(c);
	    		  }  
	    	  }
	    	  
	    	  public void copyToken(Card token)
		      {
		    	  Card copy = new Card();
		    	  copy.setName(token.getName());
		    	  copy.setImageName(token.getImageName());
		    	  
	              copy.setOwner(token.getController());
	              copy.setController(token.getController());
	              copy.setManaCost(token.getManaCost());
	              copy.setToken(true);
	              copy.setType(token.getType());
	              copy.setBaseAttack(token.getBaseAttack());
	              copy.setBaseDefense(token.getBaseDefense());
	              
	              PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
	              play.add(copy);
		      }
	    	  
	    	  public boolean canPlayAI()
	    	  {
	    		  PlayerZone play = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
	    		  CardList tokens = new CardList(play.getCards());
	    		  tokens = tokens.filter(new CardListFilter(){

					public boolean addCard(Card c) {
						return c.isToken();
					}
	    			  
	    		  });
	    		  return tokens.size() >= 2;
	    	  }
	      };
	      
	      card.addSpellAbility(copyTokens1);

	      copyTokens1.setDescription("4 GW GW, tap: For each creature token you control, put a token into play that's a copy of that creature.");
	      copyTokens1.setStackDescription(card.getName() + " - For each creature token you control, put a token into play that's a copy of that creature.");
	      copyTokens1.setBeforePayMana(new Input_PayManaCost(copyTokens1));
	      
	      
	      
  }//*************** END ************ END **************************
	
	//*************** START *********** START **************************
	if(cardName.equals("Bringer of the Green Dawn") || cardName.equals("Bringer of the Blue Dawn")  || 
	   cardName.equals("Bringer of the White Dawn"))
	{
		final SpellAbility diffCost = new Spell(card)
		{
			private static final long serialVersionUID = -1598664186463358630L;
			public void resolve()
			{
				PlayerZone hand = AllZone.getZone(Constant.Zone.Hand ,card.getController());
				PlayerZone play = AllZone.getZone(Constant.Zone.Play ,card.getController());
				
				
				hand.remove(card);
				play.add(card);
				card.comesIntoPlay(); //do i need this?
			}
			public boolean canPlay()
			{
				return AllZone.Phase.getActivePlayer().equals(card.getController()) &&
                !AllZone.Phase.getPhase().equals("End of Turn") && !AllZone.GameAction.isCardInPlay(card);
			}
			
		};
		diffCost.setManaCost("W U B R G");
		diffCost.setDescription("You may pay W U B R G rather than pay "+card.getName() +"'s mana cost. ");
		diffCost.setStackDescription(card.getName() + " - Creature 5/5");
		card.addSpellAbility(diffCost);
		
	
		
	}//*************** END ************ END **************************
	
	//*************** START *********** START **************************
	if(cardName.equals("Thelonite Hermit"))
	{
		
		Command turnsFaceUp = new Command()
	    {    
			private static final long serialVersionUID = -3882798504865405413L;

			public void execute()
	        {
	          makeToken();
	          makeToken();
	          makeToken();
	          makeToken();
	          
	        }//execute()
	        
	        public void makeToken()
	        {
	        	Card c = new Card();


	        	  c.setName("Saproling");
	        	  c.setImageName("G 1 1 Saproling");

	  	          c.setOwner(card.getController());
	  	          c.setController(card.getController());

	  	          c.setManaCost("G");
	  	          c.setToken(true);
	  	         
	  	          c.addType("Creature");
	  	          c.addType("Saproling");
	  	          c.setBaseAttack(1);
	  	          c.setBaseDefense(1);

	  	          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
	  	          play.add(c);
	        }
	      };//Command

		
		card.addTurnFaceUpCommand(turnsFaceUp);
	}//*************** END ************ END **************************

	//*************** START *********** START **************************
	if(cardName.equals("Imperial Hellkite"))
	{
		final String player = card.getController();
		Command turnsFaceUp = new Command()
	    {
			private static final long serialVersionUID = -1407485989096862288L;

			public void execute()
	        {
	        	  PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
		    	  PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
		    	  
		    	  CardList list = new CardList(lib.getCards());
		    	  list = list.getType("Dragon");
		    	  
		    	  if (list.size()==0)
		    		  return;

		    	  
		    	  if (player.equals(Constant.Player.Computer))
		    	  {
		    		  Card dragon = CardFactoryUtil.AI_getBestCreature(list);
		    		  lib.remove(dragon);
		    		  hand.add(dragon);
		    	  }
		    	  else //human
		    	  {
		    		  Object o = AllZone.Display.getChoiceOptional("Select Dragon", list.toArray());
		    		  Card dragon = (Card)o;
		    		  lib.remove(dragon);
		    		  hand.add(dragon);
		    	  }
		    	  AllZone.GameAction.shuffle(card.getController());
	        }//execute()
	    };//Command
		
		card.addTurnFaceUpCommand(turnsFaceUp);
		
	}//*************** END ************ END **************************
	
	//*************** START *********** START **************************
	if(cardName.equals("Corrupt"))
	{
	
		final SpellAbility spell = new Spell(card)
		{
		  private static final long serialVersionUID = 335838994716307031L;
		
		  Card check;
		  public boolean canPlayAI()
		  {
		    if(AllZone.Human_Life.getLife() <= countSwamps(card))
		      return true;
		
		    check = getFlying();
		    return check != null;
		  }
		  
		  public int countSwamps(Card c)
		  {
				PlayerZone play = AllZone.getZone(Constant.Zone.Play, c.getController());
				CardList swamps = new CardList(play.getCards());
				swamps = swamps.getType("Swamp");
				return swamps.size();
		  }
		  
		  public void chooseTargetAI()
		  {
		    if(AllZone.Human_Life.getLife() <= 12) //12? mebbe 15? 
		    {
		      setTargetPlayer(Constant.Player.Human);
		      return;
		    }
		
		    Card c = getFlying();
		    if((c == null) || (! check.equals(c)))
		      throw new RuntimeException(card +" error in chooseTargetAI() - Card c is " +c +",  Card check is " +check);
		
		    setTargetCard(c);
		  }//chooseTargetAI()
		
		//uses "damage" variable
		  Card getFlying()
		  {
		    CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
		    for(int i = 0; i < flying.size(); i++)
		      if(flying.get(i).getNetDefense() <= countSwamps(card))
		        return flying.get(i);
		
		    return null;
		  }
		
		  public void resolve()
		  {
			int damage = countSwamps(card);
		    if(getTargetCard() != null)
		    {
		      if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
		      {
		        Card c = getTargetCard();
		        c.addDamage(damage);
		        AllZone.GameAction.getPlayerLife(card.getController()).addLife(damage);
		      }
		    }
		    else {
		      AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(damage);
		      AllZone.GameAction.getPlayerLife(card.getController()).addLife(damage);
		    }
		  }//resolve()
		};//SpellAbility
		card.clearSpellAbility();
		card.addSpellAbility(spell);
		
		spell.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(spell,true));
	}//*************** END ************ END **************************
		

    //*************** START *********** START **************************
    if(cardName.equals("Sunlance"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -8327380630150660908L;
		
		int damage = 3;
        Card check;
        public boolean canPlayAI()
        {
          check = getFlying();
          return check != null;
        }
        public void chooseTargetAI()
        {
          Card c = getFlying();
          if((c == null) || (! check.equals(c)))
            throw new RuntimeException(card +" error in chooseTargetAI() - Card c is " +c +",  Card check is " +check);

          setTargetCard(c);
        }//chooseTargetAI()

        //uses "damage" variable
        Card getFlying()
        {
          CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          for(int i = 0; i < flying.size(); i++)
            if(flying.get(i).getNetDefense() <= damage &&
               (!CardUtil.getColors(flying.get(i)).contains(Constant.Color.White)))
          {
              return flying.get(i);
          }
          return null;
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
          {
            Card c = getTargetCard();
            c.addDamage(damage);
          }
        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      //target
      Input target = new Input()
      {
		private static final long serialVersionUID = -579427555773493417L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target non-white creature for " +spell.getSourceCard());
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if((!CardUtil.getColors(card).contains(Constant.Color.White)) &&
             card.isCreature()                                          &&
             zone.is(Constant.Zone.Play))
          {
            spell.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }
      };//SpellAbility - target

      spell.setBeforePayMana(target);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Saltblast"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -8701870029034823295L;
		
		Card check;
        public boolean canPlayAI()
        {
          check = getFlying();
          return check != null;
        }
        public void chooseTargetAI()
        {
          Card c = getFlying();
          if((c == null) || (! check.equals(c)))
            throw new RuntimeException(card +" error in chooseTargetAI() - Card c is " +c +",  Card check is " +check);

          setTargetCard(c);
        }//chooseTargetAI()

        //uses "damage" variable
        Card getFlying()
        {
          CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          for(int i = 0; i < flying.size(); i++)
            if(!CardUtil.getColors(flying.get(i)).contains(Constant.Color.White))
          {
              return flying.get(i);
          }
          return null;
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            Card c = getTargetCard();

            if(AllZone.GameAction.isCardInPlay(c))
              AllZone.GameAction.destroy(c);
          }
        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      //target
      Input target = new Input()
      {
		private static final long serialVersionUID = 6040042391157137555L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target non-white permanent for " +spell.getSourceCard());
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if((!CardUtil.getColors(card).contains(Constant.Color.White)) &&
             zone.is(Constant.Zone.Play))
          {
            spell.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }
      };//SpellAbility - target

      spell.setBeforePayMana(target);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Firebolt"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -4100322462753117988L;
		
		int damage = 2;
        Card check;
        
        public boolean canPlayAI()
        {
          if(AllZone.Human_Life.getLife() <= damage)
            return true;
          
          PlayerZone compHand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
          CardList hand = new CardList(compHand.getCards());
               
          if (hand.size() >= 8)
            return true;

          check = getFlying();
          return check != null;
        }
        public void chooseTargetAI()
        {
          if(AllZone.Human_Life.getLife() <= damage)
          {
            setTargetPlayer(Constant.Player.Human);
            return;
          }

          Card c = getFlying();
          if((c == null) || (! check.equals(c)))
            throw new RuntimeException(card +" error in chooseTargetAI() - Card c is " +c +",  Card check is " +check);

          setTargetCard(c);
        }//chooseTargetAI()

        //uses "damage" variable
        Card getFlying()
        {
          CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          for(int i = 0; i < flying.size(); i++)
            if(flying.get(i).getNetDefense() <= damage)
              return flying.get(i);

          return null;
        }

        public void resolve()
        {
          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
            {
              Card c = getTargetCard();
              c.addDamage(damage);
            }
          }
          else
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(damage);
        }
      };//SpellAbility
      
      final SpellAbility flashback = new Spell(card)
      {

		private static final long serialVersionUID = -4811352682106571233L;
		int damage = 2;
        Card check;
        
        public boolean canPlay()
        {
        	PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard ,card.getController());
			String phase         = AllZone.Phase.getPhase();
			String activePlayer  = AllZone.Phase.getActivePlayer();
			
			return AllZone.GameAction.isCardInZone(card, grave) && 
					((phase.equals(Constant.Phase.Main1) || phase.equals(Constant.Phase.Main2)) &&
				    card.getController().equals(activePlayer) && AllZone.Stack.size() == 0 );
        }
        
        public boolean canPlayAI()
        {
          if(AllZone.Human_Life.getLife() <= damage)
            return true;

          check = getFlying();
          return check != null;
        }
        public void chooseTargetAI()
        {
          if(AllZone.Human_Life.getLife() <= damage)
          {
            setTargetPlayer(Constant.Player.Human);
            return;
          }

          Card c = getFlying();
          if((c == null) || (! check.equals(c)))
            throw new RuntimeException(card +" error in chooseTargetAI() - Card c is " +c +",  Card check is " +check);

          setTargetCard(c);
        }//chooseTargetAI()

        //uses "damage" variable
        Card getFlying()
        {
          CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          for(int i = 0; i < flying.size(); i++)
            if(flying.get(i).getNetDefense() <= damage)
              return flying.get(i);

          return null;
        }

        public void resolve()
        {
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard , card.getController());
		  PlayerZone removed = AllZone.getZone(Constant.Zone.Removed_From_Play, card.getController());
        	
          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
            {
              Card c = getTargetCard();
              c.addDamage(damage);
            }
          }
          else
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(damage);
          
          grave.remove(card);
		  removed.add(card);
          
        }
      };//flashback
      flashback.setManaCost("4 R");
      flashback.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(flashback,true));
      flashback.setDescription("Flashback: 4R");
      
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      card.addSpellAbility(flashback);

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(spell,true));
      card.setFlashback(true);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Spark Spray"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 6619448976712515187L;

		public void chooseTargetAI()
        {
          setStackDescription("Spark Spray cycling - Computer draws a card");
        }//chooseTargetAI()

        public void resolve()
        {
          if(card.getController().equals(Constant.Player.Computer))
          {
            AllZone.GameAction.drawCard(Constant.Player.Computer);
            return;
          }

          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
            {
              Card c = getTargetCard();
              c.addDamage(1);
            }
          }
          else
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(1);
        }
      };//SpellAbility
      spell.setDescription("Spark Spray deals 1 damage to target creature or player.");
      card.clearSpellAbility();

      card.addSpellAbility(spell);
      card.addSpellAbility(CardFactoryUtil.ability_cycle(card, "R"));

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(spell,true));
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Cackling Flames"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 2635417318395677454L;
		
		int damage = 3;
        Card check;
        public boolean canPlayAI()
        {
          if(AllZone.Human_Life.getLife() <= damage)
            return true;

          check = getFlying();
          return check != null;
        }
        public void chooseTargetAI()
        {
          if(AllZone.Human_Life.getLife() <= damage)
          {
            setTargetPlayer(Constant.Player.Human);
            return;
          }

          Card c = getFlying();
          if((c == null) || (! check.equals(c)))
            throw new RuntimeException(card +" error in chooseTargetAI() - Card c is " +c +",  Card check is " +check);

          setTargetCard(c);
        }//chooseTargetAI()

        //uses "damage" variable
        Card getFlying()
        {
          CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          for(int i = 0; i < flying.size(); i++)
            if(flying.get(i).getNetDefense() <= damage)
              return flying.get(i);

          return null;
        }



        public void resolve()
        {
          int damage = getDamage();

          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
            {
              Card c = getTargetCard();
              c.addDamage(damage);
            }
          }
          else
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(damage);
        }
        int getDamage()
        {
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          if(hand.size() == 0)
            return 5;

          return 3;
        }
      };//SpellAbility
      card.clearSpellAbility();

      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(spell,true));
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    if(cardName.equals("Mob Justice"))
    {
      final SpellAbility spell = new Spell(card)
      {

		private static final long serialVersionUID = -671093248575416927L;
		
		public boolean canPlayAI()
        {
          int damage = countControlledCreatures(Constant.Player.Computer);

          if(AllZone.Human_Life.getLife() <= damage || damage >= 4)
            return true;
          
          PlayerZone compHand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
          CardList hand = new CardList(compHand.getCards());
          
          if (hand.size() >= 8)
        	return true;
          
          return false;
        }
        public void chooseTargetAI()
        {
          setTargetPlayer(Constant.Player.Human);
        }//chooseTargetAI()

        public void resolve()
        {
        	int damage = countControlledCreatures(card.getController());
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(damage);
        }
        //count basic lands you control
        int countControlledCreatures(String player)
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
          CardList creatures = new CardList(play.getCards());
          creatures = creatures.getType("Creature");

          return creatures.size();
        }//countControlledCreatures();

      };//SpellAbility
      card.clearSpellAbility();

      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Tribal Flames"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -9055422004395136061L;
		
		Card check;
        public boolean canPlayAI()
        {
          int damage = countLandTypes();

          if(AllZone.Human_Life.getLife() <= damage)
            return true;
          
          PlayerZone compHand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
          CardList hand = new CardList(compHand.getCards());
          
          if (hand.size() >= 8)
        	return true;

          check = getFlying();
          return check != null;
        }
        public void chooseTargetAI()
        {
          int damage = countLandTypes();

          if(AllZone.Human_Life.getLife() <= damage)
          {
            setTargetPlayer(Constant.Player.Human);
            return;
          }
          
          PlayerZone compHand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
          CardList hand = new CardList(compHand.getCards());
          
          if(getFlying() == null && hand.size() >= 7 ) //not 8, since it becomes 7 when getting cast
          {
        	  setTargetPlayer(Constant.Player.Human);
        	  return;
          }

          Card c = getFlying();
          if((c == null) || (! check.equals(c)))
            throw new RuntimeException(card +" error in chooseTargetAI() - Card c is " +c +",  Card check is " +check);

          setTargetCard(c);
        }//chooseTargetAI()

        //uses "damage" variable
        Card getFlying()
        {
          int damage = countLandTypes();

          CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          for(int i = 0; i < flying.size(); i++)
            if(flying.get(i).getNetDefense() <= damage)
              return flying.get(i);

          return null;
        }


        public void resolve()
        {
          int damage = countLandTypes();

          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
            {
              Card c = getTargetCard();
              c.addDamage(damage);
            }
          }
          else
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(damage);
        }
        //count basic lands you control
        int countLandTypes()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList land = new CardList(play.getCards());

          String basic[] = {"Forest", "Plains", "Mountain", "Island", "Swamp"};
          int count = 0;

          for(int i = 0; i < basic.length; i++)
          {
            CardList c = land.getType(basic[i]);
            if(! c.isEmpty())
              count++;
          }

          return count;
        }//countLandTypes()

      };//SpellAbility
      card.clearSpellAbility();

      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(spell,true));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Erratic Explosion"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -6003403347798646257L;
		
		int damage = 3;
        Card check;
        public boolean canPlayAI()
        {
          if(AllZone.Human_Life.getLife() <= damage)
            return true;

          check = getFlying();
          return check != null;
        }
        public void chooseTargetAI()
        {
          if(AllZone.Human_Life.getLife() <= damage)
          {
            setTargetPlayer(Constant.Player.Human);
            return;
          }

          Card c = getFlying();
          if((c == null) || (! check.equals(c)))
            throw new RuntimeException(card +" error in chooseTargetAI() - Card c is " +c +",  Card check is " +check);

          setTargetCard(c);
        }//chooseTargetAI()

        //uses "damage" variable
        Card getFlying()
        {
          CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          for(int i = 0; i < flying.size(); i++)
            if(flying.get(i).getNetDefense() <= damage)
              return flying.get(i);

          return null;
        }

        public void resolve()
        {
          int damage = getDamage();

          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
            {
              javax.swing.JOptionPane.showMessageDialog(null, "Erratic Explosion causes " +damage +" to " +getTargetCard());

              Card c = getTargetCard();
              c.addDamage(damage);
            }
          }
          else
          {
            javax.swing.JOptionPane.showMessageDialog(null, "Erratic Explosion causes " +damage +" to " +getTargetPlayer());
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(damage);
          }
        }
        //randomly choose a nonland card
        int getDamage()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          CardList notLand = new CardList(library.getCards());
          notLand = notLand.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return ! c.isLand();
            }
          });
          notLand.shuffle();

          if(notLand.isEmpty())
            return 0;

          Card card = notLand.get(0);
          return CardUtil.getConvertedManaCost(card.getSpellAbility()[0]);
        }
      };//SpellAbility
      card.clearSpellAbility();

      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(spell, true));
    }//*************** END ************ END **************************

  
    //*************** START *********** START **************************
    if(cardName.equals("Char"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -1379875309204771345L;
		
		int damage = 4;
        Card check;
        public boolean canPlayAI()
        {
          if(AllZone.Computer_Life.getLife() < 2)
            return false;

          if(AllZone.Human_Life.getLife() <= damage)
            return true;
          
          PlayerZone compHand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
          CardList hand = new CardList(compHand.getCards());
          
          if (hand.size() >= 8)
        	return true;

          check = getFlying();
          return check != null;
        }
        public void chooseTargetAI()
        {
          if(AllZone.Human_Life.getLife() <= damage)
          {
            setTargetPlayer(Constant.Player.Human);
            return;
          }
          
          PlayerZone compHand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
          CardList hand = new CardList(compHand.getCards());
          
          if(getFlying() == null && hand.size() >= 7 ) //not 8, since it becomes 7 when getting cast
          {
        	  setTargetPlayer(Constant.Player.Human);
        	  return;
          }

          Card c = getFlying();
          if((c == null) || (! check.equals(c)))
            throw new RuntimeException(card +" error in chooseTargetAI() - Card c is " +c +",  Card check is " +check);

          setTargetCard(c);
        }//chooseTargetAI()

        //uses "damage" variable
        Card getFlying()
        {
          CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          for(int i = 0; i < flying.size(); i++)
            if(flying.get(i).getNetDefense() <= damage)
              return flying.get(i);

          return null;
        }
        public void resolve()
        {
          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
            {
              Card c = getTargetCard();
              c.addDamage(damage);
              AllZone.GameAction.getPlayerLife(card.getController()).subtractLife(2);
            }
          }
          else
          {
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(damage);
            AllZone.GameAction.getPlayerLife(card.getController()).subtractLife(2);
          }

        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      Input target = new Input()
      {
		private static final long serialVersionUID = -7645439029870010010L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target Creature, Player or Planeswalker");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if((card.isCreature() || card.isPlaneswalker())&& zone.is(Constant.Zone.Play))
          {
            spell.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }//selectCard()
        public void selectPlayer(String player)
        {
          spell.setTargetPlayer(player);
          stopSetNext(new Input_PayManaCost(spell));
        }
      };
      spell.setBeforePayMana(target);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Psionic Blast"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -5315747587330795963L;
		
		int damage = 4;
        Card check;
        public boolean canPlayAI()
        {
          if(AllZone.Computer_Life.getLife() <= 2)
            return false;

          if(AllZone.Human_Life.getLife() <= damage)
            return true;
          
          PlayerZone compHand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
          CardList hand = new CardList(compHand.getCards());
          
          if (hand.size() >= 8)
        	return true;

          check = getFlying();
          return check != null;
        }
        public void chooseTargetAI()
        {
          if(AllZone.Human_Life.getLife() <= damage)
          {
            setTargetPlayer(Constant.Player.Human);
            return;
          }
          
          PlayerZone compHand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
          CardList hand = new CardList(compHand.getCards());
          
          if(getFlying() == null && hand.size() >= 7 ) //not 8, since it becomes 7 when getting cast
          {
        	  setTargetPlayer(Constant.Player.Human);
        	  return;
          }

          Card c = getFlying();
          if((c == null) || (! check.equals(c)))
            throw new RuntimeException(card +" error in chooseTargetAI() - Card c is " +c +",  Card check is " +check);

          setTargetCard(c);
        }//chooseTargetAI()

        //uses "damage" variable
        Card getFlying()
        {
          CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          for(int i = 0; i < flying.size(); i++)
            if(flying.get(i).getNetDefense() <= damage)
              return flying.get(i);

          return null;
        }
        public void resolve()
        {
          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
            {
              Card c = getTargetCard();
              c.addDamage(damage);
              AllZone.GameAction.getPlayerLife(card.getController()).subtractLife(2);
            }
          }
          else
          {
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(damage);
            AllZone.GameAction.getPlayerLife(card.getController()).subtractLife(2);
          }

        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      Input target = new Input()
      {
		private static final long serialVersionUID = -3883369136409452222L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target Creature, Player or Planeswalker");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if((card.isCreature() || card.isPlaneswalker())&& zone.is(Constant.Zone.Play))
          {
            spell.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }//selectCard()
        public void selectPlayer(String player)
        {
          spell.setTargetPlayer(player);
          stopSetNext(new Input_PayManaCost(spell));
        }
      };
      spell.setBeforePayMana(target);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Hidetsugu's Second Rite"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 176857775451818523L;
		
		public void resolve()
        {
          PlayerLife life = AllZone.GameAction.getPlayerLife(getTargetPlayer());
          if(life.getLife() == 10)
            life.subtractLife(10);
        }
        public boolean canPlay()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          PlayerLife p = AllZone.GameAction.getPlayerLife(opponent);
          return p.getLife() == 10;
        }
      };
      spell.setChooseTargetAI(CardFactoryUtil.AI_targetHuman());
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell));
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Soulscour") )
    {
       SpellAbility spell = new Spell(card)
       {

		private static final long serialVersionUID = -4554873222565897972L;

		public void resolve()
          {
             CardList all = new CardList();
             all.addAll(AllZone.Human_Play.getCards());
             all.addAll(AllZone.Computer_Play.getCards());

             for (int i = 0; i < all.size(); i++)
             {
                Card c = all.get(i);
                if (c.isPermanent() && !c.isArtifact())
                   AllZone.GameAction.destroy(c);
             }
          }// resolve()

          public boolean canPlayAI()
          {
             CardList human = new CardList(AllZone.Human_Play.getCards());
             CardList computer = new CardList(AllZone.Computer_Play.getCards());

             human = human.getType("Creature");
             computer = computer.getType("Creature");

             // the computer will at least destroy 2 more human creatures
             return computer.size() < human.size() - 1 ||
             (AllZone.Computer_Life.getLife() < 7 && !human.isEmpty());
          }
       };// SpellAbility
       card.clearSpellAbility();
       card.addSpellAbility(spell);
    }// *************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("March of Souls"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -1468254925312413359L;
		
		public void resolve()
        {
          change(AllZone.Human_Play, card.getController());
          change(AllZone.Computer_Play, card.getController());
        }
        public void change(PlayerZone play, String owner)
        {
          Card[] c = play.getCards();
          for (int i = 0; i < c.length; i++)
          {
            if(c[i].isCreature())
            {
              AllZone.GameAction.destroyNoRegeneration(c[i]);
              play.add(getCreature(c[i].getController()));
            }
          }
        }//change()
        public Card getCreature(String owner)
        {
          //TODO: owner and controller is NOT the same player sometimes
          //owner is the player who played March of Souls
          //the controller is the player who's creature was destroyed
          Card c = new Card();
          c.setToken(true);
          c.setOwner(owner);
          c.setController(owner);

          c.setName("Spirit");
          c.setImageName("W 1 1 Spirit");
          c.setBaseAttack(1);
          c.setBaseDefense(1);
          c.addIntrinsicKeyword("Flying");

          c.setManaCost("W");
          c.addType("Creature");
          c.addType("Spirit");
          return c;
        }//getCreature()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************


//*************** START *********** START **************************
	if (cardName.equals("Wrath of God") || cardName.equals("Damnation"))
	{
		SpellAbility spell = new Spell(card)
		{
			private static final long serialVersionUID = -18728406578984546L;

			public void resolve()
			{
				CardList all = new CardList();
				all.addAll(AllZone.Human_Play.getCards());
				all.addAll(AllZone.Computer_Play.getCards());

				for (int i = 0; i < all.size(); i++)
				{
					Card c = all.get(i);
					if (c.isCreature())
						AllZone.GameAction.destroyNoRegeneration(c);
				}
			}// resolve()

			public boolean canPlayAI()
			{
				CardList human = new CardList(AllZone.Human_Play.getCards());
				CardList computer = new CardList(AllZone.Computer_Play.getCards());

				human = human.getType("Creature");
				computer = computer.getType("Creature");

				// the computer will at least destroy 2 more human creatures
				return computer.size() < human.size() - 1 || 
				(AllZone.Computer_Life.getLife() < 7 && !human.isEmpty());
			}
		};// SpellAbility
		card.clearSpellAbility();
		card.addSpellAbility(spell);
	}// *************** END ************ END **************************
	
	//*************** START *********** START **************************
	if (cardName.equals("Day of Judgment"))
	{
		SpellAbility spell = new Spell(card)
		{
			
			private static final long serialVersionUID = -2916641841124966207L;

			public void resolve()
			{
				CardList all = new CardList();
				all.addAll(AllZone.Human_Play.getCards());
				all.addAll(AllZone.Computer_Play.getCards());

				for (int i = 0; i < all.size(); i++)
				{
					Card c = all.get(i);
					if (c.isCreature())
						AllZone.GameAction.destroy(c);
				}
			}// resolve()

			public boolean canPlayAI()
			{
				CardList human = new CardList(AllZone.Human_Play.getCards());
				CardList computer = new CardList(AllZone.Computer_Play.getCards());

				human = human.getType("Creature");
				computer = computer.getType("Creature");

				// the computer will at least destroy 2 more human creatures
				return computer.size() < human.size() - 1 || 
				(AllZone.Computer_Life.getLife() < 7 && !human.isEmpty());
			}
		};// SpellAbility
		card.clearSpellAbility();
		card.addSpellAbility(spell);
	}// *************** END ************ END **************************
	
	
	
	//*************** START *********** START **************************
	if (cardName.equals("Planar Cleansing") )
	{
		SpellAbility spell = new Spell(card)
		{

			private static final long serialVersionUID = -4233719265268955876L;

			public void resolve()
			{
				CardList all = new CardList();
				all.addAll(AllZone.Human_Play.getCards());
				all.addAll(AllZone.Computer_Play.getCards());

				for (int i = 0; i < all.size(); i++)
				{
					Card c = all.get(i);
					if (c.isPermanent() && !c.isLand())
						AllZone.GameAction.destroy(c);
				}
			}// resolve()

			public boolean canPlayAI()
			{
				CardList human = new CardList(AllZone.Human_Play.getCards());
				CardList computer = new CardList(AllZone.Computer_Play.getCards());

				human = human.getType("Creature");
				computer = computer.getType("Creature");

				// the computer will at least destroy 2 more human creatures
				return computer.size() < human.size() - 1 || 
				(AllZone.Computer_Life.getLife() < 7 && !human.isEmpty());
			}
		};// SpellAbility
		card.clearSpellAbility();
		card.addSpellAbility(spell);
	}// *************** END ************ END **************************
	
	//*************** START *********** START **************************
	if (cardName.equals("Tranquility") || cardName.equals("Tempest of Light") || cardName.equals("Cleanfall"))
	{
		SpellAbility spell = new Spell(card)
		{

			private static final long serialVersionUID = 3087098751201624354L;

			public void resolve()
			{

				CardList all = new CardList();
				all.addAll(AllZone.Human_Play.getCards());
				all.addAll(AllZone.Computer_Play.getCards());

				for (int i = 0; i < all.size(); i++)
				{
					Card c = all.get(i);
					if (c.isEnchantment())
						AllZone.GameAction.destroy(c);
					
				}
				
					
			}// resolve()

			public boolean canPlayAI()
			{
				CardList human = new CardList(AllZone.Human_Play.getCards());
				CardList computer = new CardList(AllZone.Computer_Play.getCards());

				human = human.getType("Enchantment");
				computer = computer.getType("Enchantment");
				
				
				if (human.size() == 0) 
					return false;
				
				// the computer will at least destroy 2 more human enchantments
				return computer.size() < human.size() - 1 || 
				(AllZone.Computer_Life.getLife() < 7 && !human.isEmpty());
			}
		};// SpellAbility
		card.clearSpellAbility();
		card.addSpellAbility(spell);
	}// *************** END ************ END **************************
	
	//*************** START *********** START **************************
	if (cardName.equals("Hush"))
	{
		SpellAbility spell = new Spell(card)
		{
			private static final long serialVersionUID = -1572271570905127602L;

			public void resolve()
			{

				CardList all = new CardList();
				all.addAll(AllZone.Human_Play.getCards());
				all.addAll(AllZone.Computer_Play.getCards());

				for (int i = 0; i < all.size(); i++)
				{
					Card c = all.get(i);
					if (c.isEnchantment())
						AllZone.GameAction.destroy(c);
				}

			}// resolve()

			public boolean canPlayAI()
			{
				CardList human = new CardList(AllZone.Human_Play.getCards());
				CardList computer = new CardList(AllZone.Computer_Play.getCards());

				human = human.getType("Enchantment");
				computer = computer.getType("Enchantment");
				
				
				if (human.size() == 0) 
					return false;
				
				// the computer will at least destroy 2 more human enchantments
				return computer.size() < human.size() - 1 || 
				(AllZone.Computer_Life.getLife() < 7 && !human.isEmpty());
			}
		};// SpellAbility

		spell.setDescription("Destroy all enchantments.");
		card.clearSpellAbility();
	    card.addSpellAbility(spell);
	    card.addSpellAbility(CardFactoryUtil.ability_cycle(card, "2"));
	}// *************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Incendiary Command"))
    {
      //not sure what to call variables, so I just made up something
      final String[] m_player = new String[1];
      final Card[] m_land = new Card[1];

      final ArrayList<String> userChoice = new ArrayList<String>();

      final String[] cardChoice = {
        "Incendiary Command deals 4 damage to target player",
        "Incendiary Command deals 2 damage to each creature",
        "Destroy target nonbasic land",
        "Each player discards all cards in his or her hand, then draws that many cards"
      };

      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 9178547049760990376L;

		public void resolve()
        {
//          System.out.println(userChoice);
//          System.out.println(m_land[0]);
//          System.out.println(m_player[0]);

          //"Incendiary Command deals 4 damage to target player",
          if(userChoice.contains(cardChoice[0]))
            AllZone.GameAction.getPlayerLife(m_player[0]).subtractLife(4);

          //"Incendiary Command deals 2 damage to each creature",
          if(userChoice.contains(cardChoice[1]))
          {
            //get all creatures
            CardList list = new CardList();
            list.addAll(AllZone.Human_Play.getCards());
            list.addAll(AllZone.Computer_Play.getCards());
            list = list.getType("Creature");

            for(int i = 0; i < list.size(); i++)
              list.get(i).addDamage(2);
          }

          //"Destroy target nonbasic land",
          if(userChoice.contains(cardChoice[2]))
            AllZone.GameAction.destroy(m_land[0]);

          //"Each player discards all cards in his or her hand, then draws that many cards"
          if(userChoice.contains(cardChoice[3]))
          {
            discardDraw(Constant.Player.Computer);
            discardDraw(Constant.Player.Human);
          }
        }//resolve()

        void discardDraw(String player)
        {
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, player);
          int n = hand.size();

          //technically should let the user discard one card at a time
          //in case graveyard order matters
          for(int i = 0; i < n; i++)
            AllZone.GameAction.discardRandom(player);

          for(int i = 0; i < n; i++)
            AllZone.GameAction.drawCard(player);
        }
        public boolean canPlayAI()
        {
          return false;
        }
      };//SpellAbility

      final Command setStackDescription = new Command()
	  {		
	  
	  	private static final long serialVersionUID = -4833850318955216009L;

		public void execute()
        {
          ArrayList<String> a = new ArrayList<String>();
          if(userChoice.contains(cardChoice[0]))
            a.add("deals 4 damage to " +m_player[0]);

          if(userChoice.contains(cardChoice[1]))
            a.add("deals 2 damage to each creature");

          if(userChoice.contains(cardChoice[2]))
            a.add("destroy " +m_land[0]);

          if(userChoice.contains(cardChoice[3]))
            a.add("each player discards all cards in his or her hand, then draws that many cards");

          String s = a.get(0) +", " +a.get(1);
          spell.setStackDescription(card.getName() +" - " +s);
        }
      };//Command


      final Input targetLand = new Input()
      {
		private static final long serialVersionUID = 1485276539154359495L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target nonbasic land");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          if(c.isLand() &&
             zone.is(Constant.Zone.Play) &&
             !c.getType().contains("Basic"))
          {
            m_land[0] = c;
            setStackDescription.execute();

            stopSetNext(new Input_PayManaCost(spell));
          }//if
        }//selectCard()
      };//Input targetLand

      final Input targetPlayer = new Input()
      {
		private static final long serialVersionUID = -2636869617248434242L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target player");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectPlayer(String player)
        {
          m_player[0] = player;
          setStackDescription.execute();

          //if user needs to target nonbasic land
          if(userChoice.contains(cardChoice[2]))
            stopSetNext(targetLand);
          else
          {
            stopSetNext(new Input_PayManaCost(spell));
          }
        }//selectPlayer()
      };//Input targetPlayer


      Input chooseTwoInput = new Input()
      {
		private static final long serialVersionUID = 5625588008756700226L;

		public void showMessage()
        {
          //reset variables
          m_player[0] = null;
          m_land[0] = null;

          userChoice.clear();

          ArrayList<String> display = new ArrayList<String>();

          //get all
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());

          CardList land = list.getType("Land");
          CardList basicLand = list.getType("Basic");

          display.add("Incendiary Command deals 4 damage to target player");
          display.add("Incendiary Command deals 2 damage to each creature");
          if(land.size() != basicLand.size())
            display.add("Destroy target nonbasic land");
          display.add("Each player discards all cards in his or her hand, then draws that many cards");

          ArrayList<String> a = chooseTwo(display);
          //everything stops here if user cancelled
          if(a == null)
          {
            stop();
            return;
          }

          userChoice.addAll(a);

          if(userChoice.contains(cardChoice[0]))
            stopSetNext(targetPlayer);
          else if(userChoice.contains(cardChoice[2]))
            stopSetNext(targetLand);
          else
          {
            setStackDescription.execute();

            stopSetNext(new Input_PayManaCost(spell));
          }
        }//showMessage()

        ArrayList<String> chooseTwo(ArrayList<String> choices)
        {
          ArrayList<String> out = new ArrayList<String>();
          Object o = AllZone.Display.getChoiceOptional("Choose Two", choices.toArray());
          if(o == null)
            return null;

          out.add((String) o);

          choices.remove(out.get(0));
          o = AllZone.Display.getChoiceOptional("Choose Two", choices.toArray());
          if(o == null)
            return null;

          out.add((String) o);

          return out;
        }//chooseTwo()
      };//Input chooseTwoInput

      card.clearSpellAbility();
      card.addSpellAbility(spell);
      spell.setBeforePayMana(chooseTwoInput);
    }//*************** END ************ END **************************

    //*************** START *********** START **************************
    if(cardName.equals("Boil") || cardName.equals("Boiling Seas"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -5951776248246552958L;
		
		public void resolve()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());

          for(int i = 0; i < all.size(); i++)
          {
            Card c = all.get(i);
            if(c.getType().contains("Island"))
              AllZone.GameAction.destroy(c);
          }
        }//resolve()
        public boolean canPlayAI()
        {
          CardList list = new CardList(AllZone.Human_Play.getCards());
          list = list.getType("Island");

          return 3 < list.size();
        }
      };//SpellAbility
      spell.setStackDescription(card.getName() + " - destroy all Islands.");
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Plague Wind"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 6008660207658995400L;

		public void resolve()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, opponent);

          CardList all = new CardList(play.getCards());
          all = all.getType("Creature");

          for(int i = 0; i < all.size(); i++)
          {
            Card c = all.get(i);
            if(c.isCreature())
              AllZone.GameAction.destroyNoRegeneration(c);
          }
        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Overwhelming Forces"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -7165356050118574287L;

		public void resolve()
        {
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, opponent);

          CardList all = new CardList(play.getCards());
          all = all.getType("Creature");

          for(int i = 0; i < all.size(); i++)
          {
            Card c = all.get(i);
            if(c.isCreature())
              AllZone.GameAction.destroy(c);
              AllZone.GameAction.drawCard(card.getController());
          }
        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Path of Anger's Flame"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -4070937328002003491L;
		
		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public Card getAttacker()
        {
          //target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();
          Card[] att = c.getAttackers();
          if(att.length != 0)
            return att[0];
          else
            return null;
        }//getAttacker()
        public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList start = new CardList(play.getCards());
          final CardList list = start.getType("Creature");

          for(int i = 0; i < list.size(); i++)
            list.get(i).addTempAttackBoost(2);

          play.updateObservers();

          Command untilEOT = new Command()
          {
			private static final long serialVersionUID = 6078548097470388679L;

			public void execute()
            {
              for(int i = 0; i < list.size(); i++)
                if(AllZone.GameAction.isCardInPlay(list.get(i)))
                  list.get(i).addTempAttackBoost(-2);
            }
          };
          AllZone.EndOfTurn.addUntil(untilEOT);
        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Kjeldoran War Cry"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -7384618531690849205L;
		
		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public Card getAttacker()
        {
          //target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();
          Card[] att = c.getAttackers();
          if(att.length != 0)
            return att[0];
          else
            return null;
        }//getAttacker()
        public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList start = new CardList(play.getCards());
          final CardList list = start.getType("Creature");

          final int boost = countCards();

          for(int i = 0; i < list.size(); i++)
          {
            list.get(i).addTempAttackBoost(boost);
            list.get(i).addTempDefenseBoost(boost);
          }

          play.updateObservers();

          Command untilEOT = new Command()
          {
			private static final long serialVersionUID = -2803160667440730370L;

			public void execute()
            {
              for(int i = 0; i < list.size(); i++)
                if(AllZone.GameAction.isCardInPlay(list.get(i)))
                {
                  list.get(i).addTempAttackBoost(- boost);
                  list.get(i).addTempDefenseBoost(- boost);
                }
            }
          };
          AllZone.EndOfTurn.addUntil(untilEOT);
        }//resolve()
        int countCards()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Graveyard.getCards());
          all.addAll(AllZone.Computer_Graveyard.getCards());

          all = all.getName("Kjeldoran War Cry");
          return all.size() + 1;
        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Akroma's Vengeance") ||
       cardName.equals("Devastation") ||
       cardName.equals("Jokulhaups") ||
       cardName.equals("Purify") ||
       cardName.equals("Shatterstorm") ||
       cardName.equals("Obliterate"))
    {
      final SpellAbility spell = new Spell(card)
      {
      private static final long serialVersionUID = -7384618531690849205L;

      public void resolve()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());

          for(int i = 0; i < all.size(); i++)
          {
            Card c = all.get(i);
           
            if(cardName.equals("Akroma's Vengeance") && (c.isCreature() || c.isArtifact() || c.isEnchantment())) // Destroy Enchantment rather than Land
               AllZone.GameAction.destroy(c); // Can regenerate
            if(cardName.equals("Devastation") && (c.isCreature() || c.isLand()))
               AllZone.GameAction.destroy(c); // Can regenerate
            if((cardName.equals("Jokulhaups") || cardName.equals("Obliterate") ) && (c.isCreature() || c.isArtifact() || c.isLand()))
                AllZone.GameAction.destroyNoRegeneration(c); // CAN'T regenerate
            if(cardName.equals("Purify") && (c.isArtifact() || c.isEnchantment()))
               AllZone.GameAction.destroy(c); // Can regenerate
            if(cardName.equals("Shatterstorm") && (c.isArtifact()))
               AllZone.GameAction.destroyNoRegeneration(c); // CAN'T regenerate
          }
        }//resolve()
      };//SpellAbility
     
      if(cardName.equals("Akroma's Vengeance"))
      {
    	  spell.setStackDescription("Akroma's Vengeance - Destroy all artifacts, creatures, and enchantments."); // add stack description
          spell.setDescription("Destroy all artifacts, creatures, and enchantments."); // add spell detail description
      }
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      if(cardName.equals("Akroma's Vengeance")) //add cycling
         card.addSpellAbility(CardFactoryUtil.ability_cycle(card, "3"));
      if(cardName.equals("Obliterate"))
    	 card.setText("Obliterate can't be countered. \r\n" + card.getText());
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Wheel of Fortune"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -7707418370887790709L;
		
		public void resolve()
        {
          discardDraw7(Constant.Player.Human);
          discardDraw7(Constant.Player.Computer);
        }//resolve()
        void discardDraw7(String player)
        {
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, player);
          Card[] c = hand.getCards();
          for(int i = 0; i < c.length; i++)
            AllZone.GameAction.discard(c[i]);

          for(int i = 0; i < 7; i++)
            AllZone.GameAction.drawCard(player);
        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Armageddon") || cardName.equals("Ravages of War"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 432601263297207029L;
		
		public void resolve()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());

          for(int i = 0; i < all.size(); i++)
          {
            Card c = all.get(i);
            if(c.isLand())
              AllZone.GameAction.destroy(c);
          }
        }//resolve()
        public boolean canPlayAI()
        {
          int human    = countPower(AllZone.Human_Play);
          int computer = countPower(AllZone.Computer_Play);

          return human < computer || MyRandom.percentTrue(10);
        }
        public int countPower(PlayerZone play)
        {
          CardList list = new CardList(play.getCards());
          list = list.getType("Creature");
          int power = 0;
          for(int i = 0; i < list.size(); i++)
            power += list.get(i).getNetAttack();

          return power;
        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************


    //*************** START *********** START **************************
    if(cardName.equals("Remove Soul") || cardName.equals("False Summoning") || cardName.equals("Essence Scatter") || cardName.equals("Preemptive Strike"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 4685055135070191326L;
		
		public void resolve()
        {
          SpellAbility sa = AllZone.Stack.pop();
          AllZone.GameAction.moveToGraveyard(sa.getSourceCard());
        }
        public boolean canPlay()
        {
          if(AllZone.Stack.size() == 0)
            return false;

          //see if spell is on stack and that opponent played it
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          SpellAbility sa = AllZone.Stack.peek();

          //is spell?, did opponent play it?, is this a creature spell?
          return sa.isSpell() &&
                 opponent.equals(sa.getSourceCard().getController()) &&
                 sa.getSourceCard().getType().contains("Creature");
        }//canPlay()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Counterspell") || cardName.equals("Cancel") || cardName.equals("Last Word"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -2489268054171391552L;
		
		public void resolve()
        {
          SpellAbility sa = AllZone.Stack.pop();
          AllZone.GameAction.moveToGraveyard(sa.getSourceCard());
        }
        public boolean canPlay()
        {
          if(AllZone.Stack.size() == 0)
            return false;

          //see if spell is on stack and that opponent played it
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          SpellAbility sa = AllZone.Stack.peek();

          return sa.isSpell() && opponent.equals(sa.getSourceCard().getController()) 
          		 && CardFactoryUtil.isCounterable(sa.getSourceCard());
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Remand"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 7259402997927108504L;
		
		public void resolve()
        {
          //counter spell, return it to owner's hand
          SpellAbility sa = AllZone.Stack.pop();
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, sa.getSourceCard().getOwner());
          AllZone.GameAction.moveTo(hand, sa.getSourceCard());

          //draw card
          AllZone.GameAction.drawCard(card.getController());
        }
        public boolean canPlay()
        {
          if(AllZone.Stack.size() == 0)
            return false;

          //see if spell is on stack and that opponent played it
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          SpellAbility sa = AllZone.Stack.peek();

          return sa.isSpell() && opponent.equals(sa.getSourceCard().getController())
          		 && CardFactoryUtil.isCounterable(sa.getSourceCard());
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Regress"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 4207725827500789300L;

		public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            if(getTargetCard().isToken())
              AllZone.getZone(getTargetCard()).remove(getTargetCard());
            else
            {
              PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, getTargetCard().getOwner());
              AllZone.GameAction.moveTo(hand, getTargetCard());
            }
          }
        }//resolve()
		
		public void chooseTargetAI()
		{
			PlayerZone hPlay = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
			CardList hum = new CardList(hPlay.getCards());
			
			Card best = CardFactoryUtil.AI_getMostExpensivePermanent(hum, card, true);
	        if (best!=null)
	        	setTargetCard(best);
		}
		public boolean canPlayAI()
		{
			PlayerZone hPlay = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
			CardList hum = new CardList(hPlay.getCards());
			
			return hum.size()>0;
		}
      };
      //spell.setChooseTargetAI(CardFactoryUtil.AI_targetType("All", AllZone.Human_Play));

      spell.setBeforePayMana(CardFactoryUtil.input_targetType(spell, "All"));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Echoing Truth"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 563933533543239220L;

		public boolean canPlayAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          return 4 < AllZone.Phase.getTurn() && 0 < human.size();
        }
        public void chooseTargetAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          setTargetCard(CardFactoryUtil.AI_getBestCreature(human));
        }

        public void resolve()
        {
          //if target card is not in play, just quit
          if(! AllZone.GameAction.isCardInPlay(getTargetCard()) || !CardFactoryUtil.canTarget(card, getTargetCard()) )
            return;

          //get all permanents
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());

          CardList sameName = all.getName(getTargetCard().getName());

          if (!getTargetCard().isFaceDown())
          {
	          //bounce all permanents with the same name
	          for(int i = 0; i < sameName.size(); i++)
	          {
	            if(sameName.get(i).isToken())
	              AllZone.GameAction.destroy(sameName.get(i));
	            else
	            {
	              PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, sameName.get(i).getOwner());
	              AllZone.GameAction.moveTo(hand, sameName.get(i));
	            }
	          }//for
          }//if (!isFaceDown())
          else
          {
        	  PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, getTargetCard().getOwner());
        	  AllZone.GameAction.moveTo(hand, getTargetCard());
          }
        }//resolve()
      };//SpellAbility
      Input target = new Input()
      {
		private static final long serialVersionUID = -3978705328511825933L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target non-land permanent for " +spell.getSourceCard());
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if(! card.isLand() && zone.is(Constant.Zone.Play) && CardFactoryUtil.canTarget(spell, card))
          {
            spell.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }
      };//Input

      spell.setBeforePayMana(target);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Repulse"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 7586791617021788730L;

		public boolean canPlayAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          return 3 < AllZone.Phase.getTurn() && 0 < human.size();
        }
        public void chooseTargetAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          setTargetCard(CardFactoryUtil.AI_getBestCreature(human));
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            if(getTargetCard().isToken())
              AllZone.getZone(getTargetCard()).remove(getTargetCard());
            else
            {
              PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, getTargetCard().getOwner());
              @SuppressWarnings("unused") // play
			  PlayerZone play = AllZone.getZone(Constant.Zone.Play, getTargetCard().getOwner());
              AllZone.GameAction.moveTo(hand, getTargetCard());
              
              //play.remove(getTargetCard());
              //hand.add(getTargetCard());
            }
            AllZone.GameAction.drawCard(card.getController());
          }//if
        }//resolve()
      };//SpellAbility
      Input target = new Input()
      {
		private static final long serialVersionUID = -4976281514575975012L;
		
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target creature for " +spell.getSourceCard());
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        { 
          if(!CardFactoryUtil.canTarget(spell, card)){
        	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }
        	
          else if(card.isCreature() && zone.is(Constant.Zone.Play))
          {
            spell.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }
      };//Input

      spell.setBeforePayMana(target);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    if(cardName.equals("Unsummon"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -4920446621228732642L;

		public boolean canPlayAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          return 2 < AllZone.Phase.getTurn() && 0 < human.size();
        }
        public void chooseTargetAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          setTargetCard(CardFactoryUtil.AI_getBestCreature(human));
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            if(getTargetCard().isToken())
              AllZone.getZone(getTargetCard()).remove(getTargetCard());
            else
            {
              PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, getTargetCard().getOwner());
              @SuppressWarnings("unused") // play
			  PlayerZone play = AllZone.getZone(Constant.Zone.Play, getTargetCard().getOwner());
              AllZone.GameAction.moveTo(hand, getTargetCard());
              
              //play.remove(getTargetCard());
              //hand.add(getTargetCard());
            }
          }//if
        }//resolve()
      };//SpellAbility
      Input target = new Input()
      {
		private static final long serialVersionUID = -7657949950004365660L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target creature for " +spell.getSourceCard());
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        { 
          if(!CardFactoryUtil.canTarget(spell, card)){
        	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }
        	
          else if(card.isCreature() && zone.is(Constant.Zone.Play))
          {
            spell.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }
      };//Input

      spell.setBeforePayMana(target);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Impulse"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -6793636573741251978L;

		public boolean canPlayAI() {return false;}

        public void resolve()
        {
          CardList top = new CardList();
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());

          Card c;
          int j = 4;
          if (library.size() < 4)
        	  j = library.size();
          for(int i = 0; i < j; i++)
          {
            c = library.get(0);
            library.remove(0);
            top.add(c);
          }

          if (top.size() >= 1)
          {
	          //let user get choice
	          Card chosen = (Card) AllZone.Display.getChoice("Choose a card to put into your hand", top.toArray());
	          top.remove(chosen);
	
	          //put card in hand
	          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
	          hand.add(chosen);
	
	          //add cards to bottom of library
	          for(int i = 0; i < top.size(); i++)
	            library.add(top.get(i));
          }
        }//resolve()
      };//SpellAbility

      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Bribery"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -4267653042039058744L;
		public void resolve()
        {
          String player = card.getController();
          if(player.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void humanResolve()
        {
          //choose creature from opponents library to put into play
          //shuffle opponent's library
          String opponent    = AllZone.GameAction.getOpponent(card.getController());
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, opponent);
          CardList choices   = new CardList(library.getCards());

          choices = choices.getType("Creature");
          Object o = AllZone.Display.getChoiceOptional("Choose a creature", choices.toArray());
          if(o != null)
            resolve((Card)o);
        }
        public void computerResolve()
        {
          CardList all = new CardList(AllZone.Human_Library.getCards());
          all = all.getType("Creature");

          CardList flying = all.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.getKeyword().contains("Flying");
            }
          });
          //get biggest flying creature
          Card biggest = null;
          if(flying.size() != 0)
          {
            biggest = flying.get(0);

            for(int i = 0; i < flying.size(); i++)
              if(biggest.getNetAttack() < flying.get(i).getNetAttack())
                biggest = flying.get(i);
          }

          //if flying creature is small, get biggest non-flying creature
          if(all.size() != 0 &&
            (biggest == null || biggest.getNetAttack() < 3))
          {
            biggest = all.get(0);

            for(int i = 0; i < all.size(); i++)
              if(biggest.getNetAttack() < all.get(i).getNetAttack())
                biggest = all.get(i);
          }
          if(biggest != null)
            resolve(biggest);
        }//computerResolve()
        public void resolve(Card selectedCard)
        {
          String opponent    = AllZone.GameAction.getOpponent(card.getController());
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, opponent);

          Card c = selectedCard;
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());

          //need to set controller before adding it to "play"
          c.setController(card.getController());
          c.setSickness(true);

          library.remove(c);
          play.add(c);


          AllZone.GameAction.shuffle(opponent);
        }//resolve()
      };

      spell.setBeforePayMana(new Input_PayManaCost(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Words of Wisdom"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -7394898791285593737L;

		public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());
          AllZone.GameAction.drawCard(card.getController());

          String opponent = AllZone.GameAction.getOpponent(card.getController());
          AllZone.GameAction.drawCard(opponent);
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Counsel of the Soratami") || cardName.equals("Inspiration") || cardName.equals("Touch of Brilliance"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -1889094576060845154L;

		public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());
          AllZone.GameAction.drawCard(card.getController());
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Concentrate") || cardName.equals("Harmonize") )
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -3561111468549060269L;

		public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());
          AllZone.GameAction.drawCard(card.getController());
          AllZone.GameAction.drawCard(card.getController());
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Amnesia"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -5456164079438881319L;

		public void resolve()
        {
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, getTargetPlayer());
          Card[] c = hand.getCards();

          for(int i = 0; i < c.length; i++)
            if(! c[i].isLand())
              AllZone.GameAction.discard(c[i]);
        }
      };
      spell.setChooseTargetAI(CardFactoryUtil.AI_targetHuman());

      spell.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell));

      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Evacuation"))
    {
      SpellAbility spell = new Spell(card)
      {
 		private static final long serialVersionUID = -6305494177352031326L;

		public void resolve()
        {
          CardList all = new CardList();
          all.addAll(AllZone.Human_Play.getCards());
          all.addAll(AllZone.Computer_Play.getCards());
          all = all.getType("Creature");

          for(int i = 0; i < all.size(); i++)
          {
            //if is token, remove token from play, else return creature to hand
            if(all.get(i).isToken())
              getPlay(all.get(i)).remove(all.get(i));
            else
              AllZone.GameAction.moveTo(getHand(all.get(i)), all.get(i));
          }
        }//resolve()
        PlayerZone getPlay(Card c)
        {
          return AllZone.getZone(Constant.Zone.Play, c.getController());
        }

        PlayerZone getHand(Card c)
        {
          return AllZone.getZone(Constant.Zone.Hand, c.getOwner());
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    if (cardName.equals("Lockjaw Snapper"))
    {
    	
    	final Ability ability = new Ability(card, "0")
        {
          public void resolve()
          {
        	PlayerZone hPlay = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
  			PlayerZone cPlay = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
  			
  			CardList creatures = new CardList();
  			creatures.addAll(hPlay.getCards());
  			creatures.addAll(cPlay.getCards());
  			creatures = creatures.filter(new CardListFilter()
  			{
					public boolean addCard(Card c) {
						return c.getCounters(Counters.M1M1) > 0;
					}
  			});
  			
  			for (int i=0; i<creatures.size();i++)
  			{
  				Card c = creatures.get(i);
  				c.addCounter(Counters.M1M1, 1);
  			}
          }
        };
    	
    	Command destroy = new Command()
    	{
    		private static final long serialVersionUID = 6389028698247230474L;

			public void execute()
    		{
    			ability.setStackDescription(card.getName()+ " - put -1/-1 counter on each creature that has a -1/-1 counter on it.");
                AllZone.Stack.add(ability);
    		}
    	};//command
    	card.addDestroyCommand(destroy);
    }
    //*************** START *********** START **************************
    if(cardName.equals("Serra Avatar"))
    {
      Command leavesPlay = new Command()
      {
        private static final long serialVersionUID = -2274397219668820020L;

		public void execute()
        {
          //moveto library
          PlayerZone libraryZone = AllZone.getZone(Constant.Zone.Library, card.getOwner());
          AllZone.GameAction.moveTo(libraryZone, card);
          //shuffle library
          AllZone.GameAction.shuffle(card.getOwner());
        }//execute()
      };//Command
      card.addDestroyCommand(leavesPlay);
    }//***************


    //*************** START *********** START **************************
    if(cardName.equals("Ancestral Recall"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = 4696857462510589599L;
		public void resolve()
        {
          AllZone.GameAction.drawCard(getTargetPlayer());
          AllZone.GameAction.drawCard(getTargetPlayer());
          AllZone.GameAction.drawCard(getTargetPlayer());
        }
        public boolean canPlayAI()
        {
          return AllZone.Computer_Hand.getCards().length <= 5;
        }
      };
      spell.setChooseTargetAI(CardFactoryUtil.AI_targetComputer());

      spell.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Deep Analysis"))
    {
      SpellAbility spell = new Spell(card)
      {

		private static final long serialVersionUID = 6317660847906461825L;
		public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());
          AllZone.GameAction.drawCard(card.getController());
        }
        public boolean canPlayAI()
        {
          return AllZone.Computer_Hand.getCards().length <= 6;
        }
      };
      spell.setDescription("Target player draws two cards.");
      spell.setStackDescription(card.getName() + " - " + card.getController() + " draws two cards.");
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      
      card.addSpellAbility(CardFactoryUtil.ability_Flashback(card, "1 U", "3"));
      card.setFlashback(true);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Allied Strategies"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = 2730790148899002194L;

		public void resolve()
        {
          int n = countLandTypes();

          for(int i = 0; i < n; i++)
            AllZone.GameAction.drawCard(getTargetPlayer());
        }

        int countLandTypes()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, getTargetPlayer());
          CardList land = new CardList(play.getCards());

          String basic[] = {"Forest", "Plains", "Mountain", "Island", "Swamp"};
          int count = 0;

          for(int i = 0; i < basic.length; i++)
          {
            CardList c = land.getType(basic[i]);
            if(! c.isEmpty())
              count++;
          }

          return count;
        }//countLandTypes()

        public boolean canPlayAI() {return AllZone.Computer_Hand.getCards().length <= 5;}
      };
      spell.setChooseTargetAI(CardFactoryUtil.AI_targetComputer());

      spell.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Opt"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = 6002051826637535590L;
		public void resolve()
        {
          String player = card.getController();
          if(player.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void computerResolve()
        {
          //if top card of library is a land, put it on bottom of library
          if(AllZone.Computer_Library.getCards().length != 0)
          {
            Card top = AllZone.Computer_Library.get(0);
            if(top.isLand())
            {
              AllZone.Computer_Library.remove(top);
              AllZone.Computer_Library.add(top);
            }
          }
          AllZone.GameAction.drawCard(card.getController());
        }//computerResolve()
        public void humanResolve()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());

          //see if any cards are in library
          if(library.getCards().length != 0)
          {
            Card top = library.get(0);

            Object o = top;
            while(o instanceof Card)
              o = AllZone.Display.getChoice("Do you want draw this card?", new Object[] {top, "Yes", "No"});

            if(o.toString().equals("No"))
            {
              library.remove(top);
              library.add(top);
            }
          }//if
          AllZone.GameAction.drawCard(card.getController());
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Needle Storm"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = 1477280027897731860L;

		public void resolve()
        {
          CardList list = new CardList();
          list.addAll(AllZone.Human_Play.getCards());
          list.addAll(AllZone.Computer_Play.getCards());
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isCreature() && c.getKeyword().contains("Flying");
            }
          });

          for(int i = 0; i < list.size(); i++)
            list.get(i).addDamage(4);
        }//resolve()

        public boolean canPlayAI() {return CardFactoryUtil.AI_getHumanCreature("Flying", card, false).size() != 0;}
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************







    //*************** START *********** START **************************
    if(cardName.equals("Wandering Stream"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = 8777120667537357240L;
		public void resolve()
        {
          PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
          life.addLife(countLandTypes() * 2);
        }//resolve()
        int countLandTypes()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList land = new CardList(play.getCards());

          String basic[] = {"Forest", "Plains", "Mountain", "Island", "Swamp"};
          int count = 0;

          for(int i = 0; i < basic.length; i++)
          {
            CardList c = land.getType(basic[i]);
            if(! c.isEmpty())
              count++;
          }

          return count;
        }//countLandTypes()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Worldly Tutor") || cardName.equals("Sylvan Tutor"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 6624899562868794463L;
		public boolean canPlayAI()
        {
          return 6 < AllZone.Phase.getTurn();
        }

        public void resolve()
        {
          String player = card.getController();
          if(player.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void computerResolve()
        {
          CardList creature = new CardList(AllZone.Computer_Library.getCards());
          creature = creature.getType("Creature");
          if(creature.size() != 0)
          {
            Card c = creature.get(0);
            AllZone.GameAction.shuffle(card.getController());

            //move to top of library
            AllZone.Computer_Library.remove(c);
            AllZone.Computer_Library.add(c, 0);
          }
        }//computerResolve()
        public void humanResolve()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());

          CardList list = new CardList(library.getCards());
          list = list.getType("Creature");

          if(list.size() != 0)
          {
            Object o = AllZone.Display.getChoiceOptional("Select a creature", list.toArray());

            AllZone.GameAction.shuffle(card.getController());
            if(o != null)
            {
              //put creature on top of library
              library.remove(o);
              library.add((Card)o, 0);
            }
          }//if
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Enlightened Tutor"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 2281623056004772379L;
		public boolean canPlayAI()
        {
          return 4 < AllZone.Phase.getTurn();
        }

        public void resolve()
        {
          String player = card.getController();
          if(player.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void computerResolve()
        {
          CardList list = new CardList(AllZone.Computer_Library.getCards());
          CardList encharts = new CardList();
          
          for (int i=0;i<list.size();i++)
          {
        	  if (list.get(i).getType().contains("Artifact") || list.get(i).getType().contains("Enchantment"))
        		  encharts.add(list.get(i));
          }
          
          if(encharts.size() != 0)
          {
        	  //comp will just grab the first one it finds
            Card c = encharts.get(0);
            AllZone.GameAction.shuffle(card.getController());
            
            
            //move to top of library
            AllZone.Computer_Library.remove(c);
            AllZone.Computer_Library.add(c, 0);
          }
        }//computerResolve()
        public void humanResolve()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          
          CardList list = new CardList(library.getCards());
          CardList encharts = new CardList();
          
          for (int i=0;i<list.size();i++)
          {
        	  if (list.get(i).getType().contains("Artifact") || list.get(i).getType().contains("Enchantment"))
        		  encharts.add(list.get(i));
          }


          if(encharts.size() != 0)
          {
            Object o = AllZone.Display.getChoiceOptional("Select an artifact or enchantment", encharts.toArray());

            AllZone.GameAction.shuffle(card.getController());
            if(o != null)
            {
              //put card on top of library
              library.remove(o);
              library.add((Card)o, 0);
            }
          }//if
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Pulse of the Tangle"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 523613120207836692L;

		public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Beast");
          c.setImageName("G 3 3 Beast");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Beast");
          c.setBaseAttack(3);
          c.setBaseDefense(3);

          play.add(c);

          //return card to hand if necessary
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          PlayerZone oppPlay = AllZone.getZone(Constant.Zone.Play, opponent);
          PlayerZone myPlay  = AllZone.getZone(Constant.Zone.Play, card.getController());

          CardList oppList = new CardList(oppPlay.getCards());
          CardList myList = new CardList(myPlay.getCards());

          oppList = oppList.getType("Creature");
          myList  = myList.getType("Creature");

          //if true, return card to hand
          if(myList.size() < oppList.size())
          {
            PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
            hand.add(card);
          }
          else
            AllZone.GameAction.moveToGraveyard(card);
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Think Twice"))
    {
    	SpellAbility spell = new Spell(card)
    	{
			private static final long serialVersionUID = 2571730013113893086L;

			public void resolve()
	        {
	  			AllZone.GameAction.drawCard(card.getController());
	        }//resolve()
        };
        card.clearSpellAbility();
        card.setFlashback(true);
        card.addSpellAbility(spell);
    	card.addSpellAbility(CardFactoryUtil.ability_Flashback(card, "2 U", "0"));
    	
  	}//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Call of the Herd"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 1959302998030377554L;

		public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Elephant");
          c.setImageName("G 3 3 Elephant");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Elephant");
          c.setBaseAttack(3);
          c.setBaseDefense(3);

          play.add(c);

        }//resolve()
      };
      
      spell.setDescription("Put a 3/3 green Elephant creature token into play.");
      spell.setStackDescription(card.getController() + " puts a 3/3 green Elephant creature token into play.");
      
      card.setFlashback(true);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      card.addSpellAbility(CardFactoryUtil.ability_Flashback(card, "3 G", "0"));
      
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Elephant Ambush"))
    {
      SpellAbility spell = new Spell(card)
      {

		private static final long serialVersionUID = 1808366787563573082L;

		public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Elephant");
          c.setImageName("G 3 3 Elephant");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Elephant");
          c.setBaseAttack(3);
          c.setBaseDefense(3);

          play.add(c);

        }//resolve()
      };
      
      spell.setDescription("Put a 3/3 green Elephant creature token into play.");
      spell.setStackDescription(card.getController() + " puts a 3/3 green Elephant creature token into play.");
      
      card.setFlashback(true);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      card.addSpellAbility(CardFactoryUtil.ability_Flashback(card, "6 G G", "0"));
      
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Chatter of the Squirrel"))
    {
      SpellAbility spell = new Spell(card)
      {

		private static final long serialVersionUID = 3787460988525779623L;
		public void resolve()
        {	
	      makeToken();
        }
		public void makeToken()
		{
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Squirrel");
          c.setName("G 1 1 Squirrel");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Squirrel");
          c.setBaseAttack(1);
          c.setBaseDefense(1);

          play.add(c);

        }//resolve()
      };
      
      spell.setDescription("Put a 1/1 green Squirrel creature token into play.");
      spell.setStackDescription(card.getController() + " puts a 1/1 green Squirrel creature token into play.");
      
      card.setFlashback(true);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      card.addSpellAbility(CardFactoryUtil.ability_Flashback(card, "1 G", "0"));
      
    }//*************** END ************ END **************************

  //*************** START *********** START **************************
    if(cardName.equals("Acorn Harvest"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 4779507778950336252L;
		public void resolve()
        {	
	      makeToken();
	      makeToken();
        }
		public void makeToken()
		{
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Squirrel");
          c.setImageName("G 1 1 Squirrel");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Squirrel");
          c.setBaseAttack(1);
          c.setBaseDefense(1);

          play.add(c);

        }//resolve()
      };
      
      spell.setDescription("Put two 1/1 green Squirrel creature tokens into play.");
      spell.setStackDescription(card.getController() + " puts two 1/1 green Squirrel creature tokens into play.");
      
      card.setFlashback(true);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      card.addSpellAbility(CardFactoryUtil.ability_Flashback(card, "1 G", "3"));
      
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Beast Attack"))
    {
      SpellAbility spell = new Spell(card)
      {
    	  
		private static final long serialVersionUID = 381753184772980686L;
		public void resolve()
        {	
	      makeToken();
        }
		//for some reason, without this the AI can keep casting Beast Attack over and over.
		public boolean canPlayAI()
		{
			return !AllZone.GameAction.isCardInGrave(card);
		}
		
		public void makeToken()
		{
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Beast");
          c.setImageName("G 4 4 Beast");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Beast");
          c.setBaseAttack(4);
          c.setBaseDefense(4);

          play.add(c);

        }//resolve()
      };
      
      spell.setDescription("Put a 4/4 green Beast creature token into play.");
      spell.setStackDescription(card.getController() + " put a 4/4 green Beast creature token into play.");
      
      card.setFlashback(true);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      card.addSpellAbility(CardFactoryUtil.ability_Flashback(card, "2 G G G", "0"));
      
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Roar of the Wurm"))
    {
      SpellAbility spell = new Spell(card)
      {

		private static final long serialVersionUID = -7861877439125080643L;
		public void resolve()
        {	
	      makeToken();
        }
		public void makeToken()
		{
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Wurm");
          c.setImageName("G 6 6 Wurm");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Wurm");
          c.setBaseAttack(6);
          c.setBaseDefense(6);

          play.add(c);

        }//resolve()
      };
      
      spell.setDescription("Put a 6/6 green Wurm creature token into play.");
      spell.setStackDescription(card.getController() + " put a 6/6 green Wurm creature token into play.");
      
      card.setFlashback(true);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      card.addSpellAbility(CardFactoryUtil.ability_Flashback(card, "3 G", "0"));
      
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Crush of Wurms"))
    {
      SpellAbility spell = new Spell(card)
      {

		private static final long serialVersionUID = 3917531146741977318L;
		public void resolve()
        {	
	      makeToken();
	      makeToken();
	      makeToken();
        }
		public void makeToken()
		{
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Wurm");
          c.setImageName("G 6 6 Wurm");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Wurm");
          c.setBaseAttack(6);
          c.setBaseDefense(6);

          play.add(c);

        }//resolve()
      };
      
      spell.setDescription("Put three 6/6 green Wurm creature tokens into play.");
      spell.setStackDescription(card.getController() + " Put three 6/6 green Wurm creature tokens into play.");
      
      card.setFlashback(true);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      card.addSpellAbility(CardFactoryUtil.ability_Flashback(card, "9 G G G", "0"));
      
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Grizzly Fate"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 731860438110589738L;
		public void resolve()
        {	
		  PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
		  CardList list = new CardList(grave.getCards());
	      makeToken();
	      makeToken();
	      if (list.size() >= 7)
	      {
	    	  makeToken();
	    	  makeToken();
	      }
        }
		public void makeToken()
		{
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Bear");
          c.setImageName("G 2 2 Bear");
          c.setManaCost("G");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Bear");
          c.setBaseAttack(2);
          c.setBaseDefense(2);

          play.add(c);

        }//resolve()
      };
      
      spell.setDescription("Put two 2/2 green Bear creature tokens into play. Threshold - Put four 2/2 green Bear creature tokens into play instead if seven or more cards are in your graveyard. ");
      spell.setStackDescription(card.getController() + " Puts 2/2 green Bear tokens into play.");
      
      card.setFlashback(true);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      card.addSpellAbility(CardFactoryUtil.ability_Flashback(card, "5 G G", "0"));
      
    }//*************** END ************ END **************************

    //*************** START *********** START **************************
    if(cardName.equals("Sprout"))
    {
      SpellAbility spell = new Spell(card)
      {

		private static final long serialVersionUID = 1299216756153970592L;
		public void resolve()
        {   
         makeToken();
        }
	    public void makeToken()
	    {
	          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
	          Card c = new Card();
	
	          c.setOwner(card.getController());
	          c.setController(card.getController());
	
	          c.setName("Saproling");
	          c.setImageName("G 1 1 Saproling");
	          c.setManaCost("G");
	          c.setToken(true);
	
	          c.addType("Creature");
	          c.addType("Saproling");
	          c.setBaseAttack(1);
	          c.setBaseDefense(1);
	
	          play.add(c);
	
	    	}//resolve()
	     };
	     
	     spell.setDescription("Put a 1/1 green Saproling creature token into play.");
	     spell.setStackDescription(card.getController() + " put a 1/1 green Saproling creature token into play.");
	     
	     card.clearSpellAbility();
	     card.addSpellAbility(spell);
    }//*************** END ************ END **************************

    

    //*************** START *********** START **************************
    if(cardName.equals("Delirium Skeins"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 7901561313373975648L;

		public void resolve()
        {
          for(int i = 0; i < 3; i++)
            AllZone.GameAction.discardRandom(Constant.Player.Computer);

          AllZone.InputControl.setInput(CardFactoryUtil.input_discard(3));
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Wrap in Vigor"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -4235465815975050436L;

		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public Card getAttacker()
        {
          //target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();
          Card[] att = c.getAttackers();
          if(att.length != 0)
            return att[0];
          else
            return null;
        }//getAttacker()

        public void resolve()
        {
          final Card[] c = AllZone.getZone(Constant.Zone.Play, card.getController()).getCards();

          for(int i = 0; i < c.length; i++)
            if(c[i].isCreature())
              c[i].addShield();

          AllZone.EndOfTurn.addUntil(new Command()
          {
            private static final long serialVersionUID = -3946800525315027053L;

			public void execute()
            {
              for(int i = 0; i < c.length; i++)
                c[i].resetShield();
            }
          });

        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Smother"))
    {
      final SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = 6479035316340603704L;

		public boolean canPlayAI()
        {
          CardList c = CardFactoryUtil.AI_getHumanCreature(true, 3, card, true);
          CardListUtil.sortAttack(c);
          CardListUtil.sortFlying(c);

          if(c.isEmpty())
            return false;
          else
          {
            setTargetCard(c.get(0));
            return true;
          }
        }//canPlayAI()

        public void resolve()
        {
          Card c = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(c) && CardUtil.getConvertedManaCost(card.getManaCost()) <= 3 && CardFactoryUtil.canTarget(card, getTargetCard()) )
            AllZone.GameAction.destroyNoRegeneration(c);
        }//resolve()
      };//SpellAbility

      Input target = new Input()
      {
        private static final long serialVersionUID = 1877945605889747187L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target creature for " +card.getName() +" - creature must have a converted manacost of 3 or less");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if(!CardFactoryUtil.canTarget(spell, card)){
          	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }
          if(card.isCreature() && zone.is(Constant.Zone.Play) && CardUtil.getConvertedManaCost(card.getManaCost()) <= 3)
          {
            spell.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }
      };//Input
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      spell.setBeforePayMana(target);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Strangling Soot"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -3598479453933951865L;

		public boolean canPlayAI()
        {
          CardList c = CardFactoryUtil.AI_getHumanCreature(3, card, true);
          CardListUtil.sortAttack(c);
          CardListUtil.sortFlying(c);

          if(c.isEmpty())
            return false;
          else
          {
            setTargetCard(c.get(0));
            return true;
          }
        }//canPlayAI()

        public void resolve()
        {
          
          Card c = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(c) && c.getNetDefense() <= 3 && CardFactoryUtil.canTarget(card, getTargetCard()) )
            AllZone.GameAction.destroy(c);
          
        }//resolve()
      };//SpellAbility
      
      final SpellAbility flashback = new Spell(card)
      {

		private static final long serialVersionUID = -4009531242109129036L;

		public boolean canPlay()
    	{
    		PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard ,card.getController());

			return AllZone.GameAction.isCardInZone(card, grave);
    	}
		public boolean canPlayAI()
        {
          CardList c = CardFactoryUtil.AI_getHumanCreature(3, card, true);
          CardListUtil.sortAttack(c);
          CardListUtil.sortFlying(c);

          if(c.isEmpty())
            return false;
          else
          {
            setTargetCard(c.get(0));
            return true;
          }
        }//canPlayAI()

        public void resolve()
        {
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard , card.getController());
    	  PlayerZone removed = AllZone.getZone(Constant.Zone.Removed_From_Play, card.getController());
    		  
          Card c = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(c) && c.getNetDefense() <= 3 && CardFactoryUtil.canTarget(card, getTargetCard()) )
            AllZone.GameAction.destroy(c);
          
          grave.remove(card);
		  removed.add(card);
        }//resolve()
      };//flashback
      
      Input targetFB = new Input()
      {
		
		private static final long serialVersionUID = -5469698194749752297L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target creature for " +card.getName() +" - creature must have a toughness of 3 or less");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if(!CardFactoryUtil.canTarget(flashback, card)){
          	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }
          if(card.isCreature() && zone.is(Constant.Zone.Play) && card.getNetDefense() <= 3)
          {
            flashback.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(flashback));
          }
        }
      };//Input
      
      flashback.setManaCost("5 R");
      flashback.setBeforePayMana(targetFB);
      flashback.setDescription("Flashback: 5 R");

      Input target = new Input()
      {
		private static final long serialVersionUID = -198153850086215235L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target creature for " +card.getName() +" - creature must have a toughness of 3 or less");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if(!CardFactoryUtil.canTarget(spell, card)){
          	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }
          if(card.isCreature() && zone.is(Constant.Zone.Play) && card.getNetDefense() <= 3)
          {
            spell.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }
      };//Input
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      spell.setBeforePayMana(target);
      
      card.addSpellAbility(flashback);
      
      card.setFlashback(true);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Minions' Murmurs"))
    {
      final SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = 7270026936498671973L;

		public boolean canPlayAI()
        {
          int n = countCreatures();
          return 0 < n && n < AllZone.Computer_Life.getLife();
        }//canPlayAI()

        public void resolve()
        {
          int n = countCreatures();
          for(int i = 0; i < n; i++)
            AllZone.GameAction.drawCard(card.getController());

          AllZone.GameAction.getPlayerLife(card.getController()).subtractLife(n);
        }//resolve()

        int countCreatures()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList list = new CardList(play.getCards());
          list = list.getType("Creature");
          return list.size();
        }
      };//SpellAbility

      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Tendrils of Corruption"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -618587752177627111L;

		public boolean canPlayAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          return 0 < human.size();
        }//canPlayAI()

        public void chooseTargetAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          CardListUtil.sortAttack(human);
          setTargetCard(human.get(0));
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            int n = countSwamps();
            getTargetCard().addDamage(n);

            PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
            life.addLife(n);
          }
        }//resolve()

        int countSwamps()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList list = new CardList(play.getCards());
          list = list.getType("Swamp");
          return list.size();
        }
      };//SpellAbility
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));

      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Ichor Slick"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -273970706213674570L;

		public boolean canPlayAI()
        {
          CardList c = CardFactoryUtil.AI_getHumanCreature(3, card, true);
          CardListUtil.sortAttack(c);
          CardListUtil.sortFlying(c);

          if(c.isEmpty())
            return false;
          else
          {
            setTargetCard(c.get(0));
            return true;
          }
        }//canPlayAI()

        public void resolve()
        {
        	final Card[] target = new Card[1];
            final Command untilEOT = new Command()
            {
				private static final long serialVersionUID = -1615047325868708734L;

			public void execute()
              {
                if(AllZone.GameAction.isCardInPlay(target[0]) )
                {
                  target[0].addTempAttackBoost(3);
                  target[0].addTempDefenseBoost(3);
                }
              }
            };

            target[0] = getTargetCard();
            if(AllZone.GameAction.isCardInPlay(target[0]) && CardFactoryUtil.canTarget(card, target[0]))
            {
              target[0].addTempAttackBoost(-3);
              target[0].addTempDefenseBoost(-3);

              AllZone.EndOfTurn.addUntil(untilEOT);
            }
        }//resolve()
      };//SpellAbility

      Input target = new Input()
      {
        private static final long serialVersionUID = -7381927922574152604L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target creature for " +card.getName());
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if(!CardFactoryUtil.canTarget(spell, card)){
          	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }	
          else if(card.isCreature() && zone.is(Constant.Zone.Play))
          {
            spell.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }
      };//Input
      spell.setDescription("Target creature gets -3/-3 until end of turn");

      card.clearSpellAbility();
      card.addSpellAbility(spell);
      card.addSpellAbility(CardFactoryUtil.ability_cycle(card, "2"));

      spell.setBeforePayMana(target);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Funeral Charm"))
    {
      //discard
      final SpellAbility spell_one = new Spell(card)
      {
        private static final long serialVersionUID = 8273875515630095127L;
		public boolean canPlayAI()
        {
          setTargetPlayer(Constant.Player.Human);
          return MyRandom.random.nextBoolean();
        }
        public void resolve()
        {
          if(Constant.Player.Computer.equals(getTargetPlayer()))
            AllZone.GameAction.discardRandom(getTargetPlayer());
          else
            AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
        }//resolve()
      };//SpellAbility
      spell_one.setDescription("Target player discards a card.");
      spell_one.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell_one));


      //creature gets +2/-1
      final SpellAbility spell_two = new Spell(card)
      {
        private static final long serialVersionUID = -4554812851052322555L;


		public boolean canPlayAI()
        {
          CardList list = new CardList(ComputerUtil.getAttackers().getAttackers());
          list = list.filter(new CardListFilter()
          {
            public boolean addCard(Card c) {return 1 < c.getNetDefense();}
          });

          list.shuffle();
          if(list.size() > 0)
            setTargetCard(list.get(0));

          return (list.size() > 0) && MyRandom.random.nextBoolean();
        }


        public void resolve()
        {
          final Card c = getTargetCard();

          if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, c) )
          {
            c.addTempAttackBoost(2);
            c.addTempDefenseBoost(-1);

            Command until = new Command()
            {
				private static final long serialVersionUID = 4674846621452044251L;

			public void execute()
              {
                c.addTempAttackBoost(-2);
                c.addTempDefenseBoost(1);
              }
            };//Command
            AllZone.EndOfTurn.addUntil(until);
          }//if card in play?
        }//resolve()
      };//SpellAbility
      spell_two.setDescription("Target creature gets +2/-1 until end of turn.");
      spell_two.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell_two));

      card.clearSpellAbility();
      card.addSpellAbility(spell_one);
      card.addSpellAbility(spell_two);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Regrowth"))
    {
      final SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -1771016287736735113L;
		public void resolve()
        {
          PlayerZone hand      = AllZone.getZone(Constant.Zone.Hand     , card.getController());
          PlayerZone graveyard = AllZone.getZone(Constant.Zone.Graveyard, card.getController());

          if(AllZone.GameAction.isCardInZone(getTargetCard(), graveyard))
          {
            graveyard.remove(getTargetCard());
            hand.add(getTargetCard());
          }
        }//resolve()
        public boolean canPlay()
        {
          PlayerZone graveyard = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          return graveyard.getCards().length != 0 && super.canPlay();
        }
      };
      Input runtime = new Input()
      {
        private static final long serialVersionUID = 3687454413838053102L;

		public void showMessage()
        {
          PlayerZone graveyard = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          Object o = AllZone.Display.getChoiceOptional("Select target card", graveyard.getCards());
          if(o == null)
            stop();
          else
          {
            spell.setStackDescription("Return " +o +" to its owner's hand");
            spell.setTargetCard((Card)o);

            stopSetNext(new Input_PayManaCost(spell));
          }
        }//showMessage()
      };
      spell.setChooseTargetAI(CardFactoryUtil.AI_targetType("All", AllZone.Computer_Graveyard));
      spell.setBeforePayMana(runtime);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Commune with Nature"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -7652317332073733242L;
		public boolean canPlayAI() {return false;}

        public void resolve()
        {
          String player = card.getController();
          if(player.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void computerResolve()
        {
          //get top 5 cards of library
          CardList top = new CardList();
          int limit = AllZone.Computer_Library.getCards().length;

          for(int i = 0; i < 5 && i < limit; i++)
          {
            top.add(AllZone.Computer_Library.get(0));
            AllZone.Computer_Library.remove(0);
          }

          //put creature card in hand, if there is one
          CardList creature = top.getType("Creature");
          if(creature.size() != 0)
          {
            AllZone.Computer_Hand.add(creature.get(0));
            top.remove(creature.get(0));
          }

          //put cards on bottom of library
          for(int i = 0; i < top.size(); i++)
            AllZone.Computer_Library.add(top.get(i));
        }//computerResolve()
        public void humanResolve()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          PlayerZone hand    = AllZone.getZone(Constant.Zone.Hand   , card.getController());

          CardList list = new CardList();
          for(int i = 0; i < 5 && i < library.getCards().length; i++)
            list.add(library.get(i));

          //optional, select a creature
          Object o = AllZone.Display.getChoiceOptional("Select a creature", list.toArray());
          if(o != null && ((Card)o).isCreature())
          {
            AllZone.GameAction.moveTo(hand, (Card)o);
            list.remove((Card)o);
          }

          //put remaining cards on the bottom of the library
          for(int i = 0; i < list.size(); i++)
          {
            library.remove(list.get(i));
            library.add(list.get(i));
          }
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Kodama's Reach"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -3361422153566629825L;

		public void resolve()
        {
          String player = card.getController();

          if(player.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void computerResolve()
        {
          CardList land = new CardList(AllZone.Computer_Library.getCards());
          land = land.getType("Basic");

          //just to make the computer a little less predictable
          land.shuffle();

          //3 branches: 1-no land in deck, 2-one land in deck, 3-two or more land in deck
          if(land.size() != 0)
          {
            //branch 2 - at least 1 land in library
            Card tapped = land.remove(0);
            tapped.tap();

            AllZone.Computer_Play.add(tapped);
            AllZone.Computer_Library.remove(tapped);

            //branch 3
            if(land.size() != 0)
            {
              Card toHand = land.remove(0);
              AllZone.Computer_Hand.add(toHand);
              AllZone.Computer_Library.remove(toHand);
            }
          }
        }//computerResolve()

        public void humanResolve()
        {
          PlayerZone play    = AllZone.getZone(Constant.Zone.Play   , card.getController());
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          PlayerZone hand    = AllZone.getZone(Constant.Zone.Hand   , card.getController());

          CardList list = new CardList(library.getCards());
          list = list.getType("Basic");

          //3 branches: 1-no land in deck, 2-one land in deck, 3-two or more land in deck

          //branch 1
          if(list.size() == 0)
            return;

          //branch 2
          Object o = AllZone.Display.getChoiceOptional("Put into play tapped", list.toArray());
          if(o != null)
          {
            Card c = (Card)o;
            c.tap();
            list.remove(c);

            library.remove(c);
            play.add(c);

            if(list.size() == 0)
              return;

            o = AllZone.Display.getChoiceOptional("Put into your hand", list.toArray());
            if(o != null)
            {
              //branch 3
              library.remove(o);
              hand.add(o);
            }
            AllZone.GameAction.shuffle(card.getController());
          }//if
        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Pestermite"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
    	  public void resolve()
          {
            Card c = getTargetCard();

            if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, c))
            {
	          	if(c.isTapped())
	          		c.untap();
	          	else 
	               c.tap();
            }
          }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 5202575895575352408L;

		public void execute()
        {
        	CardList all = new CardList();
        	all.addAll(AllZone.Human_Play.getCards());
        	all.addAll(AllZone.Computer_Play.getCards());
        	
        	CardList hum = new CardList();
        	hum.addAll(AllZone.Human_Play.getCards());
        	
        	if (all.size() != 0) {
        		
        		if(card.getController().equals(Constant.Player.Human)) {
        			AllZone.InputControl.setInput(CardFactoryUtil.input_targetSpecific(ability, all, "Select target permanent to tap/untap.", true));
        			ButtonUtil.enableAll();
        		}
        		else if (card.getController().equals(Constant.Player.Computer)) {
        			Card human = CardFactoryUtil.AI_getBestCreature(hum);
        			ability.setTargetCard(human);
        			AllZone.Stack.add(ability);
        		}
        	}
          
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = -3055232264358172133L;

		public boolean canPlayAI()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(card, true);
          list = list.filter(new CardListFilter(){
			public boolean addCard(Card c) {
				return c.isUntapped();
			}
          });
          
          return (list.size() > 0) && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Angel of Despair"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
    	  public void resolve()
          {
            Card c = getTargetCard();

            if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, c))
            {
	          	if(c.isToken())
	          		AllZone.getZone(c).remove(c);
	
	          	else 
	                AllZone.GameAction.destroy(c);
            }
          }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -3583483691705438214L;

		public void execute()
        {
        	CardList all = new CardList();
        	all.addAll(AllZone.Human_Play.getCards());
        	all.addAll(AllZone.Computer_Play.getCards());
        	
        	CardList hum = new CardList();
        	hum.addAll(AllZone.Human_Play.getCards());
        	
        	if (all.size() != 0) {
        		
        		if(card.getController().equals(Constant.Player.Human)) {
        			AllZone.InputControl.setInput(CardFactoryUtil.input_targetSpecific(ability, all, "Select target permanent.", true));
        			ButtonUtil.disableAll();
        		}
        		else if (card.getController().equals(Constant.Player.Computer)) {
        			Card human = CardFactoryUtil.AI_getBestCreature(hum);
        			ability.setTargetCard(human);
        			AllZone.Stack.add(ability);
        		}
        	}
          
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = -173202865726476053L;

		public boolean canPlayAI()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(card, true);

          return (list.size() > 0) && AllZone.getZone(getSourceCard()).is(Constant.Zone.Hand);
        }
      });
    }//*************** END ************ END **************************    

  //*************** START *********** START **************************
    else if(cardName.equals("Yawgmoth's Bargain")){
        final SpellAbility ability = new Ability(card, "0")
        {
          public void resolve()
          {
            PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
            PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
            if(library.size() != 0)
            {
              Card c = library.get(0);
              library.remove(0);
              hand.add(c);
            }
          }

          public boolean canPlayAI()
          {
            return false;
          }
        };//SpellAbility

        ability.setDescription("Pay 1 life: Draw a card.");
        ability.setStackDescription(card.getName() +" - Pay 1 life: Draw a card.");

        card.addSpellAbility(ability);

        //instead of paying mana, pay life and add to stack
        //Input showMessage() is always the first method called
        Input payLife = new Input()
        {

			private static final long serialVersionUID = 8660593629867722192L;

			public void showMessage()
			{
				AllZone.GameAction.getPlayerLife(card.getController()).subtractLife(1);

				//this order is very important, do not change
				stop();
				AllZone.Stack.push(ability);
			}
        };//Input
        ability.setBeforePayMana(payLife);
      }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Necropotence"))
    {
      final CardList necroCards = new CardList();

      final Command necro = new Command()
      {
        private static final long serialVersionUID = 4511445425867383336L;

		public void execute()
        {
          if(AllZone.GameAction.isCardInPlay(card))
          {
            //put cards removed by Necropotence into player's hand
            if(necroCards.size() > 0){
              PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());

              for(int i = 0;i<necroCards.size();i++){
                hand.add(necroCards.get(i));
              }
              necroCards.clear();
            }
          }
        }
      };

      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());

          if(library.size() != 0)
          {
            Card c = library.get(0);
            library.remove(0);
            necroCards.add(c); //add card to necro so that it goes into hand at end of turn
            AllZone.EndOfTurn.addAt(necro);
          }
        }

        public boolean canPlayAI()
        {
          return false;
        }
      };//SpellAbility

      ability.setDescription("1 life: Set aside the top card of your library face down. At the end of your turn, put that card into your hand.");
      ability.setStackDescription(card.getName() +" - 1 life: Set aside the top card of your library face down. At the end of your turn, put that card into your hand.");

      card.addSpellAbility(ability);

      //instead of paying mana, pay life and add to stack
      //Input showMessage() is always the first method called
      Input payLife = new Input()
      {
		private static final long serialVersionUID = -3846772748411690084L;

		public void showMessage()
        {
          AllZone.GameAction.getPlayerLife(card.getController()).subtractLife(1);

          //this order is very important, do not change
          stop();
          AllZone.Stack.push(ability);
        }
      };//Input
      ability.setBeforePayMana(payLife);

    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if (cardName.equals("Storm Herd"))
    {
      final SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = 1578037279604088948L;

		public void resolve()
        {
          int life = AllZone.GameAction.getPlayerLife(card.getController()).getLife();

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());

          //we need a new Card object for each token
          //can't just add the same Card object over and over again
          for (int i = 0; i < life; i++)
          {
            play.add(getToken());
          }
        }//resolve()

        Card getToken()
        {
          Card c = new Card();
          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Pegasus");
          c.setImageName("W 1 1 Pegasus");
          c.setManaCost("W");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Pegasus");

          c.setBaseAttack(1);
          c.setBaseDefense(1);

          c.addIntrinsicKeyword("Flying");
          return c;
        }//getToken()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Festival of Trokin"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 1140489859175764227L;

		public boolean canPlay()
        {
          setStackDescription(card.getName() + " - " + card.getController() + " gains " + calculateLife() + " life.");

          return super.canPlay();
        }

        public boolean canPlayAI()
        {
          CardList creatureList = new CardList(AllZone.Computer_Play.getCards());
          creatureList = creatureList.getType("Creature");

          return creatureList.size() > 0;
        }

        int calculateLife()
        {
          PlayerZone zone = AllZone.getZone(Constant.Zone.Play, card.getController());

          CardList creatureList = new CardList(zone.getCards());
          creatureList = creatureList.getType("Creature");

          return 2 * creatureList.size();
        }

        public void resolve()
        {
          AllZone.GameAction.getPlayerLife(card.getController()).addLife(calculateLife());
        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Mystic Snake"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          if(AllZone.Stack.size() > 0) {
        	  SpellAbility sa = AllZone.Stack.peek();
        	  if (sa.isSpell() && CardFactoryUtil.isCounterable(sa.getSourceCard()) ) {
        		  sa = AllZone.Stack.pop();
        		  AllZone.GameAction.moveToGraveyard(sa.getSourceCard());
        	  }
          }
        }//resolve()
      };//SpellAbility
      Command intoPlay = new Command()
      {
        private static final long serialVersionUID = -6564365394043612388L;

		public void execute()
        {
          if(AllZone.Stack.size() > 0) {
        	ability.setStackDescription("Mystic Snake counters " +AllZone.Stack.peek().getSourceCard().getName());
        	AllZone.Stack.add(ability);
          }
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
      
      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = 6440845807532409545L;

		public boolean canPlayAI()
        {
          return false;
        }
      });

    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Absorb"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -2007620906017942538L;
		public void resolve()
        {
          SpellAbility sa = AllZone.Stack.pop();
          AllZone.GameAction.moveToGraveyard(sa.getSourceCard());

		  PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
          life.addLife(3);
        }
        public boolean canPlay()
        {
          if(AllZone.Stack.size() == 0)
            return false;

          //see if spell is on stack and that opponent played it
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          SpellAbility sa = AllZone.Stack.peek();

          return sa.isSpell() && opponent.equals(sa.getSourceCard().getController())
          		 && CardFactoryUtil.isCounterable(sa.getSourceCard());
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************

    
	//*************** START *********** START **************************
    if(cardName.equals("Undermine"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -4999966043862729936L;
		public void resolve()
        {
          SpellAbility sa = AllZone.Stack.pop();
          AllZone.GameAction.moveToGraveyard(sa.getSourceCard());

		  String opponent = AllZone.GameAction.getOpponent(card.getController());
          AllZone.GameAction.getPlayerLife(opponent).subtractLife(3);

        }
        public boolean canPlay()
        {
          if(AllZone.Stack.size() == 0)
            return false;

          //see if spell is on stack and that opponent played it
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          SpellAbility sa = AllZone.Stack.peek();

          return sa.isSpell() && opponent.equals(sa.getSourceCard().getController())
          		 && CardFactoryUtil.isCounterable(sa.getSourceCard());
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Punish Ignorance"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = 6845184687406705133L;
		public void resolve()
        {
          SpellAbility sa = AllZone.Stack.pop();
          AllZone.GameAction.moveToGraveyard(sa.getSourceCard());

		  String opponent = AllZone.GameAction.getOpponent(card.getController());
          AllZone.GameAction.getPlayerLife(opponent).subtractLife(3);
          
          String player = card.getController();
          AllZone.GameAction.getPlayerLife(player).addLife(3);

        }
        public boolean canPlay()
        {
          if(AllZone.Stack.size() == 0)
            return false;

          //see if spell is on stack and that opponent played it
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          SpellAbility sa = AllZone.Stack.peek();

          return sa.isSpell() && opponent.equals(sa.getSourceCard().getController())
          		 && CardFactoryUtil.isCounterable(sa.getSourceCard());
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Exclude"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -5615796501064636046L;
		public void resolve()
        {
          SpellAbility sa = AllZone.Stack.pop();
          AllZone.GameAction.moveToGraveyard(sa.getSourceCard());
		  AllZone.GameAction.drawCard(card.getController());
        }
        public boolean canPlay()
        {
          if(AllZone.Stack.size() == 0)
            return false;

          //see if spell is on stack and that opponent played it
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          SpellAbility sa = AllZone.Stack.peek();

          //is spell?, did opponent play it?, is this a creature spell?
          return sa.isSpell() &&
                 opponent.equals(sa.getSourceCard().getController()) &&
                 sa.getSourceCard().getType().contains("Creature")
                 && CardFactoryUtil.isCounterable(sa.getSourceCard());
        }//canPlay()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Eladamri's Call"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -6495398165357932918L;
		public void resolve()
    	{
    	  String player = card.getController();
    	  if(player.equals(Constant.Player.Human))
    		humanResolve();
    	  else
    		computerResolve();
    	}
    	public void humanResolve()
    	{
    	  CardList creatures = new CardList(AllZone.Human_Library.getCards());
    	  creatures = creatures.getType("Creature");

    	  Object check = AllZone.Display.getChoiceOptional("Select creature", creatures.toArray());
    	  if(check != null)
    	  {
    		PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
    		AllZone.GameAction.moveTo(hand, (Card)check);
    	  }
    	  AllZone.GameAction.shuffle(Constant.Player.Human);
    	}
    	public void computerResolve()
    	{
    	  Card[] library = AllZone.Computer_Library.getCards();
    	  CardList list = new CardList(library);
    	  list = list.getType("Creature");


    	  //pick best creature
    	  Card c = CardFactoryUtil.AI_getBestCreature(list);
    	  if(c == null)
    		c = library[0];
    	  AllZone.Computer_Library.remove(c);
    	  AllZone.Computer_Hand.add(c);
    	}
    	public boolean canPlay()
    	{
    	  PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
    	  return library.getCards().length != 0;
    	}
    	public boolean canPlayAI()
    	{
    	  CardList creature = new CardList();
    	  creature.addAll(AllZone.Computer_Library.getCards());
    	  creature = creature.getType("Creature");
    	  return creature.size() != 0;
    	}
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Dismiss"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -7959473218345045760L;
		public void resolve()
        {
          SpellAbility sa = AllZone.Stack.pop();
          AllZone.GameAction.moveToGraveyard(sa.getSourceCard());

          AllZone.GameAction.drawCard(card.getController());

        }
        public boolean canPlay()
        {
          if(AllZone.Stack.size() == 0)
            return false;

          //see if spell is on stack and that opponent played it
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          SpellAbility sa = AllZone.Stack.peek();

          return sa.isSpell() && opponent.equals(sa.getSourceCard().getController()) 
          		 && CardFactoryUtil.isCounterable(sa.getSourceCard());
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Global Ruin"))
    {
     final CardList target = new CardList();
     //need to use arrays so we can declare them final and still set the values in the input and runtime classes. This is a hack.
     final int[] index = new int[1];
     final int[] countBase = new int[1];
     final Vector<String> humanBasic = new Vector<String>();

     final SpellAbility spell = new Spell(card)
     {
	   private static final long serialVersionUID = 5739127258598357186L;
	   
	   public boolean canPlayAI()
       {
    	 return false;
    	 //should check if computer has land in hand, or if computer has more basic land types than human.
       }
       @SuppressWarnings("unchecked") // computerBasic
	   public void resolve()
       {
    	 //add computer's lands to target
    	 @SuppressWarnings("unused") // computerCountBasic
		 int computerCountBase = 0;
    	 @SuppressWarnings("unused") // computerBasic
		 Vector<?> computerBasic = new Vector();

       //figure out which basic land types the computer has
       CardList land = new CardList(AllZone.Computer_Play.getCards());
       String basic[] = {"Forest", "Plains", "Mountain", "Island", "Swamp"};

       for (int i = 0; i < basic.length; i++)
       {
    	 CardList cl = land.getType(basic[i]);
    	 if (!cl.isEmpty())
    	 {
    	   //remove one land of this basic type from this list
    	   //the computer AI should really jump in here and select the land which is the best.
    	   //to determine the best look at which lands have enchantments, which lands are tapped
    	   cl.remove(cl.get(0));
    	   //add the rest of the lands of this basic type to the target list, this is the list which will be sacrificed.
    	   target.addAll(cl.toArray());
    	 }
       }

    	 //when this spell resolves all basic lands which were not selected are sacrificed.
    	 for(int i = 0; i < target.size(); i++)
    	   if(AllZone.GameAction.isCardInPlay(target.get(i)))
    		 AllZone.GameAction.sacrifice(target.get(i));
       }//resolve()
     };//SpellAbility


     final Input input = new Input()
     {
		private static final long serialVersionUID = 1739423591445361917L;
		private int count;
       public void showMessage()
       { //count is the current index we are on.
    	 //countBase[0] is the total number of basic land types the human has
    	 //index[0] is the number to offset the index by
    	 count = countBase[0] - index[0] - 1; //subtract by one since humanBasic is 0 indexed.
    	 if(count<0){
    		//need to reset the variables in case they cancel this spell and it stays in hand.
    		humanBasic.clear();
    		countBase[0] = 0;
    		index[0] = 0;
    		stop();
    	 }
    	 else{
    		AllZone.Display.showMessage("Select target " + humanBasic.get(count) +" land to not sacrifice");
    		ButtonUtil.enableOnlyCancel();
    	 }
       }
       public void selectButtonCancel() {stop();}
       public void selectCard(Card c, PlayerZone zone)
       {
    	 if(c.isLand() && zone.is(Constant.Zone.Play) && c.getController().equals(Constant.Player.Human) && c.getName().equals(humanBasic.get(count)))
    	 {
    	   //get all other basic[count] lands human player controls and add them to target
    	  PlayerZone humanPlay = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
    	   CardList land = new CardList(humanPlay.getCards());
    	   CardList cl = land.getType((String)humanBasic.get(count));
    	   cl.remove(c);
    	   target.addAll(cl.toArray());

    	   index[0]++;
    	   showMessage();

    	   if(index[0] >= humanBasic.size())
    		 stopSetNext(new Input_PayManaCost(spell));
    	 }
       }//selectCard()
     };//Input

     Input runtime = new Input()
     {
       private static final long serialVersionUID = -122635387376995855L;

	public void showMessage()
       {
    	 countBase[0] = 0;
    	//figure out which basic land types the human has
    	//put those in an set to use later
    	CardList land = new CardList(AllZone.Human_Play.getCards());
    	String basic[] = {"Forest", "Plains", "Mountain", "Island", "Swamp"};

    	for (int i = 0; i < basic.length; i++)
    	{
    	  CardList c = land.getType(basic[i]);
    	  if (!c.isEmpty())
    	  {
    		humanBasic.add(basic[i]);
    		countBase[0]++;
    	  }
    	}
    	if(countBase[0] == 0){
    	   //human has no basic land, so don't prompt to select one.
    	   stop();
    	}
    	else{
    	   index[0] = 0;
    	   target.clear();
    	   stopSetNext(input);
    	}
       }
     };//Input

     card.clearSpellAbility();
     card.addSpellAbility(spell);
     spell.setBeforePayMana(runtime);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Gerrard's Verdict"))
    {
      SpellAbility spell = new Spell(card)
      {
    	  
    	private static final long serialVersionUID = 4734024742326763385L;
		public boolean canPlayAI() 
    	{
    		PlayerZone humanHand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Human);
    		if (humanHand.size() >= 2)
    			return true;
    		else
    			return false;
    	}
    	  
    	public void resolve()
        {
          String player = card.getController();
          if(player.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void humanResolve()
        {
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
          CardList list = new CardList(hand.getCards());
          list.shuffle();
          
          if (list.size()== 0)
        	  return;
          
          Card c1 = list.get(0);
          list.remove(c1);
          AllZone.Computer_Graveyard.add(c1);
          AllZone.Computer_Hand.remove(c1);          
          
          if (list.size()== 0)
        	  return;
          
          Card c2 = list.get(0);
          list.remove(c2);
          AllZone.Computer_Graveyard.add(c2);
          AllZone.Computer_Hand.remove(c2);    
          
          if (c1.getType().contains("Land")) {
        	  PlayerLife life = AllZone.GameAction.getPlayerLife(Constant.Player.Human);
        	  life.addLife(3);
          }
          
          if (c2.getType().contains("Land")) {
        	  PlayerLife life = AllZone.GameAction.getPlayerLife(Constant.Player.Human);
        	  life.addLife(3);
          }         
          

        }//resolve()
        public void computerResolve()
        {
        	PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Human);
        	PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, Constant.Player.Human);
            CardList list = new CardList(hand.getCards());
            
            if (list.size() > 0){
            
	            Object o = AllZone.Display.getChoiceOptional("First card to discard", list.toArray());
	            
	            Card c = (Card)o;
	      		list.remove(c);
	
	      		hand.remove(c);
	      		grave.add(c);
	      		
	      		if(c.getType().contains("Land")) {
	      			PlayerLife life = AllZone.GameAction.getPlayerLife(Constant.Player.Computer);
	      			life.addLife(3);
	      		}
	      		
	      		if (list.size() > 0)
	      		{
		      		Object o2 = AllZone.Display.getChoiceOptional("Second card to discard", list.toArray());
		            
		            Card c2 = (Card)o2;
		      		list.remove(c2);
		
		      		hand.remove(c2);
		      		grave.add(c2);
		      		
		      		if(c2.getType().contains("Land")) {
		      			PlayerLife life = AllZone.GameAction.getPlayerLife(Constant.Player.Computer);
		      			life.addLife(3);
		      		}
	      		}
            }
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Temporal Spring"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 2649912511833536966L;

		public boolean canPlayAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          return 3 < AllZone.Phase.getTurn() && 0 < human.size();
        }
        public void chooseTargetAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          setTargetCard(CardFactoryUtil.AI_getBestCreature(human));
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            if(getTargetCard().isToken())
              AllZone.getZone(getTargetCard()).remove(getTargetCard());
            else
            {
              AllZone.GameAction.moveToTopOfLibrary(getTargetCard());
            }
          }//if
        }//resolve()
      };//SpellAbility
      Input target = new Input()
      { 

		private static final long serialVersionUID = 3852696858086356864L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target permanent for " +spell.getSourceCard());
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          if(!CardFactoryUtil.canTarget(spell, c)){
          	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }
          else if(zone.is(Constant.Zone.Play))
          {
            spell.setTargetCard(c);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }
      };//Input

      spell.setBeforePayMana(target);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    else if(cardName.equals("Boomerang") || cardName.equals("Eye of Nowhere"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 5383879224433456795L;

		public boolean canPlayAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          return 3 < AllZone.Phase.getTurn() && 0 < human.size();
        }
        public void chooseTargetAI()
        {
          CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
          setTargetCard(CardFactoryUtil.AI_getBestCreature(human));
        }

        public void resolve()
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
            if(getTargetCard().isToken())
              AllZone.getZone(getTargetCard()).remove(getTargetCard());
            else
            {
              PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, getTargetCard().getOwner());
              AllZone.GameAction.moveTo(hand, getTargetCard());
            }
            @SuppressWarnings("unused") // targetManaCost
			String targetManaCost = getTargetCard().getManaCost();
            //System.out.println("target card has a converted manacost of: " +CardUtil.getConvertedManaCost(targetManaCost));
          }//if
        }//resolve()
      };//SpellAbility
      Input target = new Input()
      {
        private static final long serialVersionUID = 7717499561403038165L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target permanent for " +spell.getSourceCard());
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card c, PlayerZone zone)
        {
          if(!CardFactoryUtil.canTarget(spell, c)){
          	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }
          else if(zone.is(Constant.Zone.Play))
          {
            spell.setTargetCard(c);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }
      };//Input

      spell.setBeforePayMana(target);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Culling Sun"))
    {
     SpellAbility spell = new Spell(card)
    {
    private static final long serialVersionUID = 2169815434022673011L;
	public void resolve()
    {
    CardList all = new CardList();
    all.addAll(AllZone.Human_Play.getCards());
    all.addAll(AllZone.Computer_Play.getCards());

    for(int i = 0; i < all.size(); i++)
    {
      Card c = all.get(i);
      int convertedManaCost = CardUtil.getConvertedManaCost(c.getManaCost());
      if(c.isCreature() && (convertedManaCost <= 3))
        AllZone.GameAction.destroy(c);
    }
    }//resolve()
    public boolean canPlayAI()
    {
    CardList human    = new CardList(AllZone.Human_Play.getCards());
    CardList computer = new CardList(AllZone.Computer_Play.getCards());

    human    = human.getType("Creature");
    computer = computer.getType("Creature");

    //the computer will at least destroy 2 more human creatures
    return computer.size() < human.size()-1  || (AllZone.Computer_Life.getLife() < 7 && !human.isEmpty());
    }
    };//SpellAbility
    card.clearSpellAbility();
    card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Retribution of the Meek"))
    {
     SpellAbility spell = new Spell(card)
    {
    	 private static final long serialVersionUID = 4989080454206680708L;
    	 public void resolve()
	     {
	    	CardList all = new CardList();
		    all.addAll(AllZone.Human_Play.getCards());
		    all.addAll(AllZone.Computer_Play.getCards());
		
		    for(int i = 0; i < all.size(); i++)
			{
			      Card c = all.get(i);
			      int power = c.getNetAttack();
			      if(c.isCreature() && (power >= 4))
			        AllZone.GameAction.destroyNoRegeneration(c);
			}
	    }//resolve()
	    public boolean canPlayAI()
	    {
		    CardList human    = new CardList(AllZone.Human_Play.getCards());
		    CardList computer = new CardList(AllZone.Computer_Play.getCards());
		
		    human    = human.getType("Creature");
		    computer = computer.getType("Creature");
		    
		    human = human.filter(new CardListFilter()
		    {
				public boolean addCard(Card c) {
					return c.getNetAttack() >= 4;
				}	
		    });
		    
		    human = human.filter(new CardListFilter()
		    {
				public boolean addCard(Card c) {
					return c.getNetAttack() >= 4;
				} 	
		    });
		
		    //the computer will at least destroy 2 more human creatures
		    return computer.size() < human.size()-1  || (AllZone.Computer_Life.getLife() < 7 && !human.isEmpty());
		}
	 };//SpellAbility
	 card.clearSpellAbility();
	 card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Mass Calcify"))
    {
     SpellAbility spell = new Spell(card)
    {
    private static final long serialVersionUID = -3985301372801316515L;
	public void resolve()
    {
    CardList all = new CardList();
    all.addAll(AllZone.Human_Play.getCards());
    all.addAll(AllZone.Computer_Play.getCards());

    for(int i = 0; i < all.size(); i++)
    {
      Card c = all.get(i);
      //int convertedManaCost = CardUtil.getConvertedManaCost(c.getManaCost());
      if(c.isCreature() && !CardUtil.getColors(c).contains(Constant.Color.White))
        AllZone.GameAction.destroy(c);
    }
    }//resolve()
    public boolean canPlayAI()
    {
    CardList human    = new CardList(AllZone.Human_Play.getCards());
    CardList computer = new CardList(AllZone.Computer_Play.getCards());

    human    = human.getType("Creature");
    computer = computer.getType("Creature");

    //the computer will at least destroy 2 more human creatures
    return computer.size() < human.size()-1  || (AllZone.Computer_Life.getLife() < 7 && !human.isEmpty());
    }
    };//SpellAbility
    card.clearSpellAbility();
    card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Cleanse"))
    {
     SpellAbility spell = new Spell(card)
    {
		private static final long serialVersionUID = 6329910910925881386L;
		public void resolve()
	    {
	    CardList all = new CardList();
	    all.addAll(AllZone.Human_Play.getCards());
	    all.addAll(AllZone.Computer_Play.getCards());
	
	    for(int i = 0; i < all.size(); i++)
	    {
	      Card c = all.get(i);
	      
	      if(c.isCreature() && CardUtil.getColors(c).contains(Constant.Color.Black))
	        AllZone.GameAction.destroy(c);
	    }
	    }//resolve()
	    public boolean canPlayAI()
	    {
	    CardList hum = new CardList(AllZone.Human_Play.getCards());
	    CardList comp = new CardList(AllZone.Computer_Play.getCards());
	
	    hum = hum.getType("Creature");
	    comp = comp.getType("Creature");
	    
	    CardList human = new CardList();    
	    CardList computer = new CardList();
	    
	    for (int i=0; i<hum.size();i++)
	    {
	    	Card c = hum.getCard(i);
	    	if (CardUtil.getColors(c).contains(Constant.Color.Black)) {
	    		human.add(c);
	    	}
	    }
	    for (int i=0; i<comp.size();i++)
	    {
	    	Card c = comp.getCard(i);
	    	if (CardUtil.getColors(c).contains(Constant.Color.Black)) {
	    		computer.add(c);
	    	}
	    }
	    
	    //the computer will at least destroy 2 more human creatures
	    return computer.size() < human.size()-1;
	    }
    };//SpellAbility
    card.clearSpellAbility();
    card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Nature's Ruin"))
    {
     SpellAbility spell = new Spell(card)
    {
	private static final long serialVersionUID = -2465672405076170648L;
	
	public void resolve()
    {
    CardList all = new CardList();
    all.addAll(AllZone.Human_Play.getCards());
    all.addAll(AllZone.Computer_Play.getCards());

    for(int i = 0; i < all.size(); i++)
    {
      Card c = all.get(i);
      
      if(c.isCreature() && CardUtil.getColors(c).contains(Constant.Color.Green))
        AllZone.GameAction.destroy(c);
    }
    }//resolve()
    public boolean canPlayAI()
    {
    CardList hum = new CardList(AllZone.Human_Play.getCards());
    CardList comp = new CardList(AllZone.Computer_Play.getCards());

    hum = hum.getType("Creature");
    comp = comp.getType("Creature");
    
    CardList human = new CardList();    
    CardList computer = new CardList();
    
    for (int i=0; i<hum.size();i++)
    {
    	Card c = hum.getCard(i);
    	if (CardUtil.getColors(c).contains(Constant.Color.Green)) {
    		human.add(c);
    	}
    }
    for (int i=0; i<comp.size();i++)
    {
    	Card c = comp.getCard(i);
    	if (CardUtil.getColors(c).contains(Constant.Color.Green)) {
    		computer.add(c);
    	}
    }
    
    //the computer will at least destroy 2 more human creatures
    return computer.size() < human.size()-1;
    }
    };//SpellAbility
    card.clearSpellAbility();
    card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Perish"))
    {
     SpellAbility spell = new Spell(card)
    {
	private static final long serialVersionUID = -9022470313385775867L;
	
	public void resolve()
    {
    CardList all = new CardList();
    all.addAll(AllZone.Human_Play.getCards());
    all.addAll(AllZone.Computer_Play.getCards());

    for(int i = 0; i < all.size(); i++)
    {
      Card c = all.get(i);
      
      if(c.isCreature() && CardUtil.getColors(c).contains(Constant.Color.Green))
        AllZone.GameAction.destroyNoRegeneration(c);
    }
    }//resolve()
    public boolean canPlayAI()
    {
    CardList hum = new CardList(AllZone.Human_Play.getCards());
    CardList comp = new CardList(AllZone.Computer_Play.getCards());

    hum = hum.getType("Creature");
    comp = comp.getType("Creature");
    
    CardList human = new CardList();    
    CardList computer = new CardList();
    
    for (int i=0; i<hum.size();i++)
    {
    	Card c = hum.getCard(i);
    	if (CardUtil.getColors(c).contains(Constant.Color.Green)) {
    		human.add(c);
    	}
    }
    for (int i=0; i<comp.size();i++)
    {
    	Card c = comp.getCard(i);
    	if (CardUtil.getColors(c).contains(Constant.Color.Green)) {
    		computer.add(c);
    	}
    }
    
    //the computer will at least destroy 2 more human creatures
    return computer.size() < human.size()-1;
    }
    };//SpellAbility
    card.clearSpellAbility();
    card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Virtue's Ruin"))
    {
     SpellAbility spell = new Spell(card)
    {

		private static final long serialVersionUID = -4805304550512861722L;
		public void resolve()
	    {
	    CardList all = new CardList();
	    all.addAll(AllZone.Human_Play.getCards());
	    all.addAll(AllZone.Computer_Play.getCards());
	
	    for(int i = 0; i < all.size(); i++)
	    {
	      Card c = all.get(i);
	      
	      if(c.isCreature() && CardUtil.getColors(c).contains(Constant.Color.White))
	        AllZone.GameAction.destroy(c);
	    }
	    }//resolve()
	    public boolean canPlayAI()
	    {
	    CardList hum = new CardList(AllZone.Human_Play.getCards());
	    CardList comp = new CardList(AllZone.Computer_Play.getCards());
	
	    hum = hum.getType("Creature");
	    comp = comp.getType("Creature");
	    
	    CardList human = new CardList();    
	    CardList computer = new CardList();
	    
	    for (int i=0; i<hum.size();i++)
	    {
	    	Card c = hum.getCard(i);
	    	if (CardUtil.getColors(c).contains(Constant.Color.White)) {
	    		human.add(c);
	    	}
	    }
	    for (int i=0; i<comp.size();i++)
	    {
	    	Card c = comp.getCard(i);
	    	if (CardUtil.getColors(c).contains(Constant.Color.White)) {
	    		computer.add(c);
	    	}
	    }
	    
	    //the computer will at least destroy 2 more human creatures
	    return computer.size() < human.size()-1;
	    }
    };//SpellAbility
    card.clearSpellAbility();
    card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Overwhelming Intellect"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -8825219868732813877L;
		public void resolve()
        {
          SpellAbility sa = AllZone.Stack.pop();
          AllZone.GameAction.moveToGraveyard(sa.getSourceCard());
          
          int convertedManaCost = CardUtil.getConvertedManaCost(sa.getSourceCard().getManaCost());
          for (int i=0;i < convertedManaCost; i++){
        	  AllZone.GameAction.drawCard(card.getController());
          }

        }
        public boolean canPlay()
        {
          if(AllZone.Stack.size() == 0)
            return false;

          //see if spell is on stack and that opponent played it
          String opponent = AllZone.GameAction.getOpponent(card.getController());
          SpellAbility sa = AllZone.Stack.peek();
          return sa.isSpell() &&
          	opponent.equals(sa.getSourceCard().getController()) &&
          	sa.getSourceCard().getType().contains("Creature") && 
          	CardFactoryUtil.isCounterable(sa.getSourceCard());
          
        
        }
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
  
  //*************** START *********** START **************************
    else if(cardName.equals("Captain Sisay"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
		private static final long serialVersionUID = 7978812786945030021L;
		public void resolve()
        {
        	String player = card.getController();
            if(player.equals(Constant.Player.Human))
              humanResolve();
            else
              computerResolve();
        }//resolve()
        public void humanResolve()
        {
          CardList cards = new CardList(AllZone.Human_Library.getCards());
          //legends = legends.getType().contains("Legendary");
          CardList legends = new CardList();
          
          for (int i=0;i < cards.size(); i++)
          {
        	  //System.out.println("type: " +cards.get(i).getType());
        	  if (cards.get(i).getType().contains("Legendary")){
        		  //System.out.println(cards.get(i).getName());
        		  Card c = cards.get(i);
        		  legends.add(c);
        		  
        	  }
          }
          
          if (legends.size() != 0) {          
	          Object check = AllZone.Display.getChoiceOptional("Select Legend", legends.toArray());
	          if(check != null)
	          {
	            PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
	            AllZone.GameAction.moveTo(hand, (Card)check);
	          }
	          AllZone.GameAction.shuffle(Constant.Player.Human);
          }
        }
        public void computerResolve()
        {
          Card[] library = AllZone.Computer_Library.getCards();
          CardList list = new CardList(library);
          CardList legends = new CardList();
          //list = list.getType("Creature");

          for (int i=0;i < list.size(); i++)
          {
        	  if (list.get(i).getType().contains("Legendary")){
        		  Card k = list.get(i);
        		  legends.add(k);
        	  }
          
          }
          
          //pick best creature
          if (legends.size() != 0){
	          Card c = CardFactoryUtil.AI_getBestCreature(legends);
	          if(c == null)
	            c = library[0];
	          System.out.println("computer picked - " +c);
	          AllZone.Computer_Library.remove(c);
	          AllZone.Computer_Hand.add(c);
          }
        }
        
        
      };//SpellAbility
      //card.addSpellAbility(ability);
      ability.setDescription("tap: Search your library for a Legend or legendary card, reveal that card, and put it into your hand. Then shuffle your library.");
      ability.setBeforePayMana(new Input_NoCost_TapAbility((Ability_Tap) ability));
      ability.setStackDescription("Captain Sisay searches for a Legend or Legendary card...");
      card.addSpellAbility(ability);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Siege-Gang Commander"))
    {
    	
    	final SpellAbility comesIntoPlayAbility = new Ability(card, "0")
        {
          public void resolve()
          {
            makeToken();
            makeToken();
            makeToken();
          }//resolve()
          
          public void makeToken()
	      {
        	  Card c = new Card();

        	  c.setName("Goblin");
  	          c.setImageName("R 1 1 Goblin");

  	          c.setOwner(card.getController());
  	          c.setController(card.getController());

  	          c.setManaCost("R");
  	          c.setToken(true);
  	         
  	          c.addType("Creature");
  	          c.addType("Goblin");
  	          c.setBaseAttack(1);
  	          c.setBaseDefense(1);

  	          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
  	          play.add(c);
	        }

        }; //comesIntoPlayAbility
        
        Command intoPlay = new Command()
        {
			private static final long serialVersionUID = 8778828278589063477L;

			public void execute()
	          {
	            comesIntoPlayAbility.setStackDescription(card.getName() + " - put three 1/1 red Goblin creature tokens into play.");
	            AllZone.Stack.add(comesIntoPlayAbility);
	          }
        };
        
        card.addComesIntoPlayCommand(intoPlay);
    	
    
    	final SpellAbility ability = new Ability(card, "1 R")
        {

			private static final long serialVersionUID = -6653781740344703908L;

			public void resolve()
	        {
	        	  String player = card.getController();
	              if(player.equals(Constant.Player.Human))
	                humanResolve();
	              else
	                computerResolve();
	        }//resolve()
	          
	        public void humanResolve() {
	        	  String player = card.getController();
	        	  
	        	  PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
	        	  CardList cards = new CardList(play.getCards());
	        	  
	        	  CardList creatures = new CardList();
	        	  
	        	  for (int i=0;i < cards.size(); i++)
	              {
	            	  if (cards.get(i).getType().contains("Goblin") || cards.get(i).getKeyword().contains("Changeling")){
	            		  Card k = cards.get(i);
	            		  creatures.add(k);
	            	  }    
	              } 
	        	  
	        	  if (creatures.size() != 0) {          
	    	          Object check = AllZone.Display.getChoiceOptional("Select Goblin to Sacrifice", creatures.toArray());
	    	          if(check != null)
	    	          {
	    	            Card c = (Card)check;
	    	            if(AllZone.GameAction.isCardInPlay(c))
	    	            {
	    	            	AllZone.GameAction.sacrifice(c);
	    	            	
	    	            	if(getTargetCard() != null)
	    	                {
	    	                  if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
	    	                  {
	    	                      Card crd = getTargetCard();
	    	                      //c.addDamage(damage);
	    	                      AllZone.GameAction.addDamage(crd, 2);
	    	                  }
	    	                }
	    	                else
	    	                  AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(2);
	    	            	
	    	            }
	    	          }
	              }
	        }//humanResolve
	          
	        public void computerResolve() {
	        	  String player = card.getController();
	        	  
	        	  PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
	        	  CardList cards = new CardList(play.getCards());
	        	  
	        	  CardList creatures = new CardList();
	        	  
	        	  for (int i=0;i < cards.size(); i++)
	              {
	            	  if (cards.get(i).getType().contains("Goblin") || cards.get(i).getType().contains("Changeling")){
	            		  Card k = cards.get(i);
	            		  creatures.add(k);
	            	  }    
	              } 
	        	  //.... TODO
	        	  
	          }//compResolve
	          
	          public boolean canPlayAI()
	          {
	        	  return false;
	          }
          
        };//ability
        
        card.addSpellAbility(ability);
        ability.setDescription("1 R, Sacrifice a goblin: Siege-Gang Commander deals 2 damage to target creature or player .");
        ability.setStackDescription("Siege-Gang Commander deals 2 damage to target creature or player");
        ability.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(ability, true));
  	}//*************** END ************ END **************************
    
    
    //*************** START *********** START **************************
    else if(cardName.equals("Brion Stoutarm"))
    {
    
    	final SpellAbility ability = new Ability_Tap(card, "R")
        {
       		private static final long serialVersionUID = -7755879134314608010L;

			public void resolve()
	        {
	        	  String player = card.getController();
	              if(player.equals(Constant.Player.Human))
	                humanResolve();
	              else
	                computerResolve();
	        }//resolve()
	          
	        public void humanResolve() {
	        	  String player = card.getController();
	        	  
	        	  PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
	        	  CardList cards = new CardList(play.getCards());
	        	  
	        	  CardList creatures = new CardList();
	        	  
	        	  for (int i=0;i < cards.size(); i++)
	              {
	            	  if (cards.get(i).getType().contains("Creature") && !cards.get(i).getName().equals("Brion Stoutarm")){
	            		  Card k = cards.get(i);
	            		  creatures.add(k);
	            	  }    
	              } 
	        	  
	        	  if (creatures.size() != 0) {          
	    	          Object check = AllZone.Display.getChoiceOptional("Select Creature to Sacrifice", creatures.toArray());
	    	          if(check != null)
	    	          {
	    	            Card c = (Card)check;
	    	            if(AllZone.GameAction.isCardInPlay(c))
	    	            {
	    	            	int power = c.getNetAttack();
	    	            	AllZone.GameAction.sacrifice(c);
	    	            	String opponent = AllZone.GameAction.getOpponent(player);
	    	            	
	    	            	PlayerLife life = AllZone.GameAction.getPlayerLife(opponent);
	    	            	life.subtractLife(power);
	    	            	
	    	            	GameActionUtil.executeLifeLinkEffects(card, power);
	    	            	for(int i=0; i < CardFactoryUtil.hasNumberEnchantments(card, "Guilty Conscience"); i++)
	                     	   GameActionUtil.executeGuiltyConscienceEffects(card, power);
	    	            	
	    	            	card.setDealtDmgToOppThisTurn(true);
	    	            }
	    	          }
	              }
	          }//humanResolve
	          
	          public void computerResolve() {
	        	  String player = card.getController();
	        	  
	        	  PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
	        	  CardList cards = new CardList(play.getCards());
	        	  
	        	  CardList creatures = new CardList();
	        	  
	        	  for (int i=0;i < cards.size(); i++)
	              {
	            	  if (cards.get(i).getType().contains("Creature") && !cards.get(i).getName().equals("Brion Stoutarm")){
	            		  Card k = cards.get(i);
	            		  creatures.add(k);
	            	  }    
	              } 
	        	  //.... TODO
	        	  
	          }//compResolve
	          
	          public boolean canPlayAI()
	          {
	        	  return false;
	          }
	          
        };//ability
        
        card.addSpellAbility(ability);
        ability.setDescription("R, tap, Sacrifice a creature other than Brion Stoutarm: Brion Stoutarm deals damage equal to the sacrificed creature's power to target player .");
        ability.setStackDescription("Brion Stoutarm deals damage equal to sacrificed creature's power");
  	}//*************** END ************ END **************************
    
    
    //*************** START *********** START **************************
    else if(cardName.equals("Duress"))
    {
      final SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = 2180416205027322268L;

		public void resolve()
        {

          Card choice = null;

          //check for no cards in hand on resolve
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, getTargetPlayer());
          CardList cards = new CardList(hand.getCards());
          
          CardList nonCreatureCards = new CardList();
          
          
          for (int i=0;i < cards.size(); i++)
          {
        	  if(!cards.get(i).getType().contains("Creature") && !cards.get(i).getType().contains("Land")) //remove land + creats
        	  {
        		  //System.out.println("Duress: " + cards.get(i).getType());
        		  //cards.remove(i);
        		  nonCreatureCards.add(cards.get(i));
          	  }
        	  
          }
               
          if(nonCreatureCards.size() == 0)
            return;

          //human chooses
          if(card.getController().equals(Constant.Player.Human))
          {
            choice = (Card) AllZone.Display.getChoice("Choose", nonCreatureCards.toArray());
          }
          else//computer chooses
          {
            choice = CardUtil.getRandom(nonCreatureCards.toArray());
          }

          AllZone.GameAction.discard(choice);
        }//resolve()

        public boolean canPlayAI()
        {
          Card[] c = removeLandAndCreats(AllZone.Human_Hand.getCards());
          return 0 < c.length;
        }

        Card[] removeLandAndCreats(Card[] in)
        {
          CardList c = new CardList(in);
          c = c.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              //return !c.isLand();
            	if (!c.isLand() && !c.isCreature())
            		return true;
            	else return false;
            }
          });
          return c.toArray();
        }//removeLand()
      };//SpellAbility spell
      spell.setChooseTargetAI(CardFactoryUtil.AI_targetHuman());
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell));
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    else if(cardName.equals("Ostracize"))
    {
      final SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -8919895406095857866L;

		public void resolve()
        {

          Card choice = null;

          //check for no cards in hand on resolve
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, getTargetPlayer());
          CardList cards = new CardList(hand.getCards());
          CardList creatureCards = new CardList();
          
          
          for (int i=0;i < cards.size(); i++)
          {
        	  if(cards.get(i).getType().contains("Creature"))
        	  {
        		  System.out.println("ostracize: " + cards.get(i).getType());
        		  creatureCards.add(cards.get(i));
        	  }
        		 
          }
               
          if(creatureCards.size() == 0)
            return;

          //human chooses
          if(card.getController().equals(Constant.Player.Human))
          {
            choice = (Card) AllZone.Display.getChoice("Choose", creatureCards.toArray());
          }
          else//computer chooses
          {
            choice = CardUtil.getRandom(creatureCards.toArray());
          }

          AllZone.GameAction.discard(choice);
        }//resolve()

        public boolean canPlayAI()
        {
          Card[] c = removeNonCreats(AllZone.Human_Hand.getCards());
          return 0 < c.length;
        }

        Card[] removeNonCreats(Card[] in)
        {
          CardList c = new CardList(in);
          c = c.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return c.isCreature();
            }
          });
          return c.toArray();
        }//removeLand()
      };//SpellAbility spell
      spell.setChooseTargetAI(CardFactoryUtil.AI_targetHuman());
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      spell.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell));
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Trinket Mage"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          if(AllZone.GameAction.isCardInZone(getTargetCard(), lib))
          {
        	Card c = getTargetCard();
        	AllZone.GameAction.shuffle(card.getController());
        	lib.remove(c);
	        hand.add(c);	

          }
        }//resolve()
      };
      Command intoPlay = new Command()
      {

		/**
		 * 
		 */
		private static final long serialVersionUID = 4022442363194287539L;

		public void execute()
        {
          PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
          CardList cards = new CardList(lib.getCards());
          CardList arts = new CardList();
          
          for (int i=0;i<cards.size();i++)
          {
        	  if(cards.get(i).getType().contains("Artifact") && CardUtil.getConvertedManaCost(cards.get(i).getManaCost()) <= 1 )
        	  {
        		  arts.add(cards.get(i));
        	  }
          }

          String controller = card.getController();

          if(arts.size() == 0)
            return;

          if(controller.equals(Constant.Player.Human))
          {
            Object o = AllZone.Display.getChoiceOptional("Select target card", arts.toArray());
            if(o != null)
            {
              ability.setTargetCard((Card)o);
              AllZone.Stack.add(ability);
            }
          }
          else //computer
          {
            arts.shuffle();
            ability.setTargetCard(arts.get(0));
            AllZone.Stack.add(ability);
          }

        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    else if(cardName.equals("Goblin Matron"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          if(AllZone.GameAction.isCardInZone(getTargetCard(), lib))
          {
        	Card c = getTargetCard();
        	AllZone.GameAction.shuffle(card.getController());
        	lib.remove(c);
	        hand.add(c);	

          }
        }//resolve()
      };
      Command intoPlay = new Command()
      {


		/**
		 * 
		 */
		private static final long serialVersionUID = 4022442363194287539L;

		public void execute()
        {
          PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
          CardList cards = new CardList(lib.getCards());
          CardList goblins = new CardList();
          
          for (int i=0;i<cards.size();i++)
          {
        	  if(cards.get(i).getType().contains("Goblin") || cards.get(i).getKeyword().contains("Changeling"))
        	  {
        		  goblins.add(cards.get(i));
        	  }
          }

          String controller = card.getController();

          if(goblins.size() == 0)
            return;

          if(controller.equals(Constant.Player.Human))
          {
            Object o = AllZone.Display.getChoiceOptional("Select target card", goblins.toArray());
            if(o != null)
            {
              ability.setTargetCard((Card)o);
              AllZone.Stack.add(ability);
            }
          }
          else //computer
          {
            goblins.shuffle();
            ability.setTargetCard(goblins.get(0));
            AllZone.Stack.add(ability);
          }

        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    else if(cardName.equals("Kithkin Harbinger"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
          if(AllZone.GameAction.isCardInZone(getTargetCard(), lib))
          {
        	Card c = getTargetCard();
        	AllZone.GameAction.shuffle(card.getController());
        	lib.remove(c);
	        lib.add(c, 0);  	
        	

          }
        }//resolve()
      };
      Command intoPlay = new Command()
      {
        private static final long serialVersionUID = 4022442363194287539L;

		public void execute()
        {
          PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
          CardList cards = new CardList(lib.getCards());
          CardList kithkin = new CardList();
          
          for (int i=0;i<cards.size();i++)
          {
        	  if(cards.get(i).getType().contains("Kithkin") || cards.get(i).getKeyword().contains("Changeling"))
        	  {
        		  kithkin.add(cards.get(i));
        	  }
          }

          String controller = card.getController();

          if(kithkin.size() == 0)
            return;

          if(controller.equals(Constant.Player.Human))
          {
            Object o = AllZone.Display.getChoiceOptional("Select target card", kithkin.toArray());
            if(o != null)
            {
              ability.setTargetCard((Card)o);
              AllZone.Stack.add(ability);
            }
          }
          else //computer
          {
            kithkin.shuffle();
            ability.setTargetCard(kithkin.get(0));
            AllZone.Stack.add(ability);
          }

        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Treefolk Harbinger"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
          if(AllZone.GameAction.isCardInZone(getTargetCard(), lib))
          {
        	Card c = getTargetCard();
        	AllZone.GameAction.shuffle(card.getController());
        	lib.remove(c);
        	lib.add(c, 0);  	

          }
        }//resolve()
      };
      Command intoPlay = new Command()
      {
        private static final long serialVersionUID = 9170723718484515120L;

		public void execute()
        {
          PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
          CardList cards = new CardList(lib.getCards());
          CardList treefolkForests = new CardList();
          
          for (int i=0;i<cards.size();i++)
          {
        	  if((cards.get(i).getType().contains("Treefolk") || cards.get(i).getKeyword().contains("Changeling")) 
        		|| cards.get(i).getType().contains("Forest"))
        	  {
        		  treefolkForests.add(cards.get(i));
        	  }
          }

          String controller = card.getController();

          if(treefolkForests.size() == 0)
            return;

          if(controller.equals(Constant.Player.Human))
          {
            Object o = AllZone.Display.getChoiceOptional("Select target card", treefolkForests.toArray());
            if(o != null)
            {
              ability.setTargetCard((Card)o);
              AllZone.Stack.add(ability);
            }
          }
          else //computer
          {
            treefolkForests.shuffle();
            ability.setTargetCard(treefolkForests.get(0));
            AllZone.Stack.add(ability);
          }

        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Lightning Helix"))
    {
      final SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = -2880908876263802588L;
		int damage = 3;
        Card check;
        public boolean canPlayAI()
        {
          if(AllZone.Human_Life.getLife() <= damage)
            return true;
          
          PlayerZone compHand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
          CardList hand = new CardList(compHand.getCards());
          
          if (hand.size() >= 8)
        	return true;

          check = getFlying();
          return check != null;
        }
        public void chooseTargetAI()
        {
          if(AllZone.Human_Life.getLife() <= damage)
          {
            setTargetPlayer(Constant.Player.Human);
            return;
          }

          Card c = getFlying();
          if((c == null) || (! check.equals(c)))
            throw new RuntimeException(card +" error in chooseTargetAI() - Card c is " +c +",  Card check is " +check);

          if (c == null) {
        	  setTargetPlayer(Constant.Player.Human);
        	  return;
          }
          setTargetCard(c);
        }//chooseTargetAI()

        //uses "damage" variable
        Card getFlying()
        {
          CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
          for(int i = 0; i < flying.size(); i++)
            if(flying.get(i).getNetDefense() <= damage)
              return flying.get(i);

          return null;
        }

        public void resolve()
        {
          if(getTargetCard() != null)
          {
            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
            {
              Card c = getTargetCard();
              c.addDamage(damage);
            }
          }
          else
            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(damage);
          AllZone.GameAction.getPlayerLife(card.getController()).addLife(3);
          
        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);

      Input target = new Input()
      {
		private static final long serialVersionUID = -924544537419004913L;
		public void showMessage()
        {
          AllZone.Display.showMessage("Select target Creature, Player or Planeswalker");
          ButtonUtil.enableOnlyCancel();
        }
        public void selectButtonCancel() {stop();}
        public void selectCard(Card card, PlayerZone zone)
        {
          if(!CardFactoryUtil.canTarget(spell, card)){
          	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
          }
          else if((card.isCreature() || card.isPlaneswalker()) && zone.is(Constant.Zone.Play))
          {
            spell.setTargetCard(card);
            stopSetNext(new Input_PayManaCost(spell));
          }
        }//selectCard()
        public void selectPlayer(String player)
        {
          spell.setTargetPlayer(player);
          stopSetNext(new Input_PayManaCost(spell));
        }
      };
      spell.setBeforePayMana(target);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Archon of Justice"))
    {
        final SpellAbility ability = new Ability(card, "0")
        {
          public void resolve()
          {
            if(getTargetCard() != null){
                if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
                {
                	AllZone.GameAction.removeFromGame(getTargetCard());
                }
            }
          }
        };
        ability.setStackDescription("Archon of Justice - Remove target permament from the game.");
       
        Command leavesPlay = new Command()
        {
          private static final long serialVersionUID = 7552566264976488465L;

		public void execute()
          {
            if(card.getController().equals(Constant.Player.Human))
              AllZone.InputControl.setInput(CardFactoryUtil.input_targetPermanent(ability));
            else
            {
                //if computer controlled Archon of Justice have it select the best creature, or enchantment, or artifact, whatever the human controllers, and as a last option a card it controls
               
               CardList human_list = new CardList(AllZone.Human_Play.getCards());
               ability.setTargetCard(CardFactoryUtil.AI_getBestCreature(human_list));
               if(ability.getTargetCard() == null){
                  ability.setTargetCard(CardFactoryUtil.AI_getBestEnchantment(human_list, card, true));
               }
               if(ability.getTargetCard() == null){
                  ability.setTargetCard(CardFactoryUtil.AI_getBestArtifact(human_list));
               }
               if(ability.getTargetCard() == null){
                  if(human_list.size() == 0){
                     CardList computer_list = new CardList(AllZone.Computer_Play.getCards());
                     if(computer_list.size() == 0){
                        return; //we have nothing in play to destroy.
                     }
                     else{
                        ability.setTargetCard(computer_list.get(0)); //should determine the worst card to destroy, but this case wont be hit much.
                     }
                  }
                  ability.setTargetCard(human_list.get(0));
               }
              AllZone.Stack.add(ability);
            }
          }//execute()
        };//Command
        card.addDestroyCommand(leavesPlay);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Knight of the Reliquary"))
    {
    	final Ability_Tap ability = new Ability_Tap(card)
    	{
    		private static final long serialVersionUID = 7554368501399705784L;
			public void resolve()
    		{
    			PlayerZone lib  = AllZone.getZone(Constant.Zone.Library, card.getController());
    			PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController()); 
    			
    			Card c = getTargetCard();
    			if (AllZone.GameAction.isCardInPlay(c))
    			{
	    			AllZone.GameAction.sacrifice(c);
	    			
	    			CardList landInLib  = new CardList(lib.getCards());
	    			landInLib = landInLib.getType("Land");
	    			
	    			if (landInLib.size() > 0)
	    			{
	    				if (card.getController().equals(Constant.Player.Computer))
	    				{
	    					lib.remove(landInLib.get(0));
	    					play.add(landInLib.get(0));
	    				}
	    				else
	    				{
	    					Object o = AllZone.Display.getChoiceOptional("Select land card to put into play: ", landInLib.toArray());
	       	       			if (o != null)
	       	       			{	
	       	       				Card crd = (Card)o;
	       	       				lib.remove(crd);
	       	       				play.add(crd);
	       	       			}
	    				}
	    				AllZone.GameAction.shuffle(card.getController());
	    			}
    			}//if(isCardInPlay)
    		}

    		public boolean canPlayAI()
    		{
    			CardList landInLib  = new CardList(AllZone.getZone(Constant.Zone.Library, Constant.Player.Computer).getCards());
    			CardList landInPlay = new CardList(AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer).getCards());
    			
    			landInLib  = landInLib.getType("Land");
    			landInPlay = landInPlay.getType("Land");
    			
    			if (landInLib.size() > 0 && landInPlay.size() > 0)
    				return true;
    			else
    				return false;
    				
    		}
    		public void chooseTargetAI()
    		{
    			CardList land = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
                land = land.filter(new CardListFilter()
                {
                    public boolean addCard(Card c)
                    {
                    	if(c.getType().contains("Plains") || c.getType().contains("Forest"))
                    		return true;
                    	else
                    		return false;
                    }
                });
                if(land.size()>0)
                	setTargetCard(land.get(0));
    		}
    	};
    	
    	Input runtime = new Input()
        {
          private static final long serialVersionUID = -4320917612145305541L;

		public void showMessage()
          {
            CardList land = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
            land = land.filter(new CardListFilter()
            {
                public boolean addCard(Card c)
                {
                	if(c.getType().contains("Plains") || c.getType().contains("Forest"))
                		return true;
                	else
                		return false;
                }
            });
            
            stopSetNext(CardFactoryUtil.input_targetSpecific(ability, land, "Select a Plains or Forest to sacrifice.", false));
          }
        };
        ability.setBeforePayMana(runtime);
    	ability.setDescription("T, Sacrifice a Forest or Plains: Search your library for a land card, put it into play, then shuffle your library.");
    	ability.setStackDescription(card.getName() + " - Search your library for a card and put it into play, then shuffle your library");
    	card.addSpellAbility(ability);
    	
    }
    
  //*************** START *********** START **************************
    if(cardName.equals("Knight of the White Orchid"))
    {
    	final Ability ability = new Ability(card, "0")
        {
          public void resolve()
          {
       	   
            PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
   	        PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
   	       
   	       
   	        CardList basic = new CardList(lib.getCards());
   	        basic = basic.getType("Plains");
   	        
   	                	
   	        
   	       	if (card.getController().equals(Constant.Player.Computer))
   	       	{
   	       		if (basic.size() > 0)
   	       		{
   	       			Card c = basic.get(0);
   	       			lib.remove(c);
   	       			play.add(c);
   	       			
   	       		}
   	       	}
   	       	else // human
   	       	{
   	       		if (basic.size() > 0) 
   	       		{
   	       			Object o = AllZone.Display.getChoiceOptional("Select Plains card to put into play: ", basic.toArray());
   	       			if (o != null)
   	       			{	
   	       				Card c = (Card)o;
   	       				lib.remove(c);
   	       				play.add(c);
   	       			}
   	       		}
   	       	}
   	       	AllZone.GameAction.shuffle(card.getController());
          }//resolve()
                    
        };//Ability
   	 
   	 Command fetchBasicLand = new Command()
        {

           private static final long serialVersionUID = -1086551054597721988L;

		public void execute()
           {
        	    String player = card.getController();
        	    PlayerZone oppPlay = AllZone.getZone(Constant.Zone.Play, AllZone.GameAction.getOpponent(player));
        	    PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
        	    
      	        CardList self = new CardList(play.getCards());
      	        CardList opp = new CardList(oppPlay.getCards());

      	        self = self.getType("Land");
      	        opp = opp.getType("Land");
      	       	
      	        if (self.size() < opp.size())
      	        {
      	        	ability.setStackDescription(card.getName()+ " - search library for a plains and put it into play");
      	        	AllZone.Stack.add(ability);
      	        }
           }
        };
        
        card.addComesIntoPlayCommand(fetchBasicLand);
     
       
      
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Niv-Mizzet, the Firemind"))
    {
      final Ability_Tap ability = new Ability_Tap(card)
      {
        private static final long serialVersionUID = 8670005059055071206L;
		public boolean canPlayAI() {return false;}
        public void resolve()
        {
          AllZone.GameAction.drawCard(card.getController());
        } 
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("tap: Draw a card.");
      ability.setStackDescription(card.getName() + " - draw a card.");
      ability.setBeforePayMana(new Input_NoCost_TapAbility(ability));
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Hoofprints of the Stag")) 
    {
    	Command intoPlay = new Command()
        {
    	   private static final long serialVersionUID = -7275454992618058248L;
		public boolean firstTime = true;
           public void execute()
           {

             if(firstTime){
           	  card.setCounter(Counters.HOOFPRINT, 0); 
             }
             firstTime = false;
           }
         };
         
         card.addComesIntoPlayCommand(intoPlay);
         
         final SpellAbility a2 = new Ability(card, "2 W")
 	     {
 	        public void resolve()
 	        {
 	           card.subtractCounter(Counters.HOOFPRINT, 4);

 	           Card c = new Card();

 	           c.setOwner(card.getController());
 	           c.setController(card.getController());

 	           c.setName("Elemental");
 	           c.setImageName("W 4 4 Elemental");
 	           c.setManaCost("W");
 	           c.setToken(true);
 	           
 	           c.addType("Creature");
 	           c.addType("Elemental");
 	           c.addIntrinsicKeyword("Flying");
 	           c.setBaseAttack(4);
 	           c.setBaseDefense(4);
 	           
 	           PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
 	           play.add(c);
 	        
 	        }
 	        
 	       public boolean canPlay()
 	       {
 	    	  SpellAbility sa;
 	    	  for (int i=0; i<AllZone.Stack.size(); i++)
 	    	  {
 	    	       sa = AllZone.Stack.peek(i);
 	    	       if (sa.getSourceCard().equals(card))
 	    	             return false;
 	    	  }
 	    	  
 	          return card.getCounters(Counters.HOOFPRINT) >= 4 && AllZone.getZone(card).is(Constant.Zone.Play) &&
 	          						  AllZone.Phase.getActivePlayer().equals(card.getController()) &&
 	          						  !AllZone.Phase.getPhase().equals("End of Turn");
 	       }//canPlay()
 	       public boolean canPlayAI()
 	       {
 	    	   return true;
 	       }
 	     };//spellAbility
 	     
 	     a2.setDescription("2 W, Remove four hoofprint counters from Hoofprints of the Stag: Put a 4/4 white Elemental creature token with flying into play. Play this ability only during your turn.");
 	     a2.setStackDescription(card.getName() + " - put a 4/4 white Elemental creature token with flying into play.");
 	     
 	     card.addSpellAbility(a2);
 	     
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    else if(cardName.equals("Elvish Farmer") || cardName.equals("Mycologist")) 
    {
    	Command intoPlay = new Command()
        {
		   private static final long serialVersionUID = 882942955555047018L;
		   public boolean firstTime = true;
           public void execute()
           {

             if(firstTime){
           	  card.setCounter(Counters.SPORE, 0); 
             }
             firstTime = false;
           }
         };
         
         card.addComesIntoPlayCommand(intoPlay);

  	    final SpellAbility a2 = new Ability(card, "0")
	    {
  	    	public void chooseTargetAI()
  	    	{
  	    		PlayerZone play = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
	        	CardList saps = new CardList(play.getCards());
	        	saps = saps.filter(new CardListFilter()
	        	{

					public boolean addCard(Card c) {
						if((c.getType().contains("Saproling") || c.getKeyword().contains("Changeling")) &&
							AllZone.GameAction.isCardInPlay(c)	)
							return true;
						return false;
					}
	        	
	        	});
	        	
	        	if (saps.size() != 0)
	        		setTargetCard(saps.getCard(0));
  	    	}
	        public void resolve()
	        {
	          //get all saprolings:
	          Card c = getTargetCard();
	          if(c == null )
	        	  return;
	          
	          if (!AllZone.GameAction.isCardInPlay(c))
	        	  return;
	          
	          if(AllZone.GameAction.isCardInPlay(c))
	          {
	            //AllZone.getZone(c).remove(c);
	        	AllZone.GameAction.sacrifice(c);
	        	  
	        	PlayerLife life = AllZone.GameAction.getPlayerLife(c.getController());
	        	life.addLife(2);
	          }
	        }//resolve
	        public boolean canPlayAI()
	        {
	        	PlayerZone play = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
	        	CardList saps = new CardList(play.getCards());
	        	saps = saps.filter(new CardListFilter()
	        	{

					public boolean addCard(Card c) {
						if(c.getType().contains("Saproling") || c.getKeyword().contains("Changeling") &&
							AllZone.GameAction.isCardInPlay(c))
							return true;
						return false;
					}
	        	
	        	});
	        	if(AllZone.Computer_Life.getLife() < 6 && saps.size() > 0)
	        		return true;
	        	else
	        		return false;
	        }
	      };//SpellAbility
	      
	      Input runtime = new Input()
	      {
	        private static final long serialVersionUID = -4803541385354247499L;

			public void showMessage()
	        {
	          CardList saps = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
	          saps = saps.getType("Saproling");
	          
	          stopSetNext(CardFactoryUtil.input_targetSpecific(a2, saps, "Select a Saproling to sacrifice.", false));
	        }
	      };  
	      
	      card.addSpellAbility(a2);
	      a2.setDescription("Sacrifice a Saproling: You gain 2 life.");
	      a2.setStackDescription(card.getController() + " gains 2 life.");
	      a2.setBeforePayMana(runtime);
    	
	  
    }//*************** END ************ END **************************
    
    else if (cardName.equals("Pallid Mycoderm"))
    {
    	
    	Command intoPlay = new Command()
        {
    	  private static final long serialVersionUID = 3400057700040211691L;
		public boolean firstTime = true;
          public void execute()
          {

            if(firstTime){
          	  card.setCounter(Counters.SPORE, 0); 
            }
            firstTime = false;
          }
        };
         
        card.addComesIntoPlayCommand(intoPlay);
         
	    final SpellAbility a2 = new Ability(card, "0")
	    {
	      final Command eot1 = new Command()
	      {
	        private static final long serialVersionUID = -4485431571276851181L;

			public void execute()
	        {
	        	String player = card.getController();
	        	PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
	        	
	        	CardList creats = new CardList(play.getCards());
	        	creats = creats.getType("Creature");
	        		
	        	for (int i=0; i < creats.size(); i++)
		        {
		      		Card creat = creats.get(i);
		      		
		      		if (creat.getType().contains("Fungus") || creat.getType().contains("Saproling") || creat.getKeyword().contains("Changeling"))
		      		{
		      			creat.addTempAttackBoost(-1);
		      			creat.addTempDefenseBoost(-1);
		      		}         	
		        }
		      	
	         }
	      };
	      public void resolve()
	      {
	        //get all player controls saprolings:
	        String player = card.getController();
	    	  
	        PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
	        
	        CardList creats = new CardList(play.getCards());
	        creats = creats.getType("Creature");
	        
	        @SuppressWarnings("unused") // saps
			CardList saps = new CardList();
	        
	        Card c = getTargetCard();
	        @SuppressWarnings("unused") // hand
			PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, c.getOwner());
	
	        if(AllZone.GameAction.isCardInPlay(c))
	        {
	          //AllZone.getZone(c).remove(c);
	      	AllZone.GameAction.sacrifice(c);
	      	  
	          
	      	for (int i=0; i < creats.size(); i++)
	        {
	        	Card creat = creats.get(i);
	        	
	        	if (creat.getType().contains("Fungus") || creat.getType().contains("Saproling"))
	        	{
	      			creat.addTempAttackBoost(1);
	      			creat.addTempDefenseBoost(1);
	        	}
	        }
	          
	        }
	        AllZone.EndOfTurn.addUntil(eot1);
	      }
	      public boolean canPlayAI()
	      {
	        return false;
	      }
	    };//SpellAbility
	    
	    Input runtime = new Input()
	    {
	      private static final long serialVersionUID = 6754180514935882692L;

		public void showMessage()
	      {
	        CardList saps = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
	        saps = saps.getType("Saproling");
	        
	        stopSetNext(CardFactoryUtil.input_targetSpecific(a2, saps, "Select a Saproling to sacrifice.", false));
	      }
	    };
	    
	    card.addSpellAbility(a2);
	    a2.setDescription("Sacrifice a Saproling: Each Fungus and each Saproling you control gets +1/+1 until end of turn");
	    a2.setStackDescription("Saprolings and Fungi you control get +1/+1 until end of turn.");
	
	    a2.setBeforePayMana(runtime);
  }//*************** END ************ END **************************
    //*************** START *********** START **************************
  else if(cardName.equals("Psychotrope Thallid"))
  {
	  Command intoPlay = new Command()
      {
  	   private static final long serialVersionUID = 8020106056714209199L;
	public boolean firstTime = true;
         public void execute()
         {

           if(firstTime){
         	  card.setCounter(Counters.SPORE, 0); 
           }
           firstTime = false;
         }
       };
       
       card.addComesIntoPlayCommand(intoPlay);

	    final SpellAbility a2 = new Ability(card, "1")
	    {
	        public void resolve()
	        {
	         	
	          Card c = getTargetCard();
	
	          if(AllZone.GameAction.isCardInPlay(c))
	          {
	            //AllZone.getZone(c).remove(c);
	        	AllZone.GameAction.sacrifice(c);
	        	  
	        	AllZone.GameAction.drawCard(c.getController());
	          }
	        }//resolve
	        public boolean canPlayAI()
	        {
	          //TODO: make AI able to use this
	          return false;
	        }
	      };//SpellAbility
	      
	      Input runtime = new Input()
	      {
	        private static final long serialVersionUID = -6388866343458002392L;

			public void showMessage()
	        {
	          CardList saps = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
	          saps = saps.getType("Saproling");
	          
	          stopSetNext(CardFactoryUtil.input_targetSpecific(a2, saps, "Select a Saproling to sacrifice.", false));
	        }
	      };  
	      
	      card.addSpellAbility(a2);
	      a2.setDescription("1, Sacrifice a Saproling: You draw a card.");
	      a2.setStackDescription(card.getController() + " draws a card.");
	      a2.setBeforePayMana(runtime);
    
    	
  }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
  else if(cardName.equals("Wall of Mulch"))
  {

	    final SpellAbility a2 = new Ability(card, "G")
	    {
	        public void resolve()
	        {

	          Card c = getTargetCard();
	
	          if(AllZone.GameAction.isCardInPlay(c))
	          {
	            //AllZone.getZone(c).remove(c);
	        	AllZone.GameAction.sacrifice(c);
	        	AllZone.GameAction.drawCard(c.getController());
	          }
	        }//resolve
	        public boolean canPlayAI()
	        {
	          //TODO: make AI able to use this
	          return false;
	        }
	      };//SpellAbility
	      
	      Input runtime = new Input()
	      {
	        private static final long serialVersionUID = -4390488827563977718L;

			public void showMessage()
	        {
	          CardList walls = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
	          walls = walls.getType("Wall");
	          
	          stopSetNext(CardFactoryUtil.input_targetSpecific(a2, walls, "Select a Wall to sacrifice.", false));
	        }
	      };  
	      
	      card.addSpellAbility(a2);
	      a2.setDescription("G, Sacrifice a Wall: You draw a card.");
	      a2.setStackDescription(card.getController() + " draws a card.");
	      a2.setBeforePayMana(runtime);
    
    	
  }//*************** END ************ END **************************
    

 //*************** START *********** START **************************
    else if (cardName.equals("Rootwater Thief"))
    {
        //final String player = card.getController();
        //final String opponent = AllZone.GameAction.getOpponent(player);
  	
	  	final Ability ability2 = new Ability(card, "2")
	  	{
	  		public void resolve()
	  		{
	  			String opponent = AllZone.GameAction.getOpponent(card.getController());
	  			PlayerZone lib = AllZone.getZone(Constant.Zone.Library, opponent);
	  			CardList cards = new CardList(lib.getCards());
	  			
	  			if (cards.size() > 0 )
	  			{
		  			if (card.getController().equals(Constant.Player.Human))
		  			{
		  				Object o = AllZone.Display.getChoiceOptional("Select card to remove: ", cards.toArray());
		  				Card c = (Card)o;
		  				AllZone.GameAction.removeFromGame(c);
		  				AllZone.GameAction.shuffle(opponent);
		  			}
		  			else
		  			{
		  				Card c = lib.get(0);
		  				AllZone.GameAction.removeFromGame(c);
		  				AllZone.GameAction.shuffle(opponent);
		  			}
	  			}
	  			
	  		}
	  		public boolean canPlay()
	  		{
	  			//this is set to false, since it should only TRIGGER
	  			return false;
	  		}
	  	};// ability2
	  	//card.clearSpellAbility();
	  	card.addSpellAbility(ability2);
	  	ability2.setStackDescription(card.getName() + " - search opponent's library and remove a card from game.");
	  	
   }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if (cardName.equals("Goblin Trenches"))
    {
    	final String player = card.getController();
    	
    	final SpellAbility ability = new Ability(card, "2")
        {
    		public boolean canPlay()
    		{
    			PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
    	    	
    	    	CardList lands = new CardList();
    	    	lands.addAll(play.getCards());
    	    	lands = lands.getType("Land");
    	    	
    			if (lands.size() >= 1 && AllZone.GameAction.isCardInPlay(card))
    				return true;
    			else
    				return false;
    		}
    		
    		public void chooseTargetAI()
            {
              Card c = getTappedLand(); //first, try to get a tapped land to sac
              if (c!=null)
              {
            	  setTargetCard(c);
            	  
              }
              else
              {
            	PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
      	    	
      	    	CardList lands = new CardList();
      	    	lands.addAll(play.getCards());
      	    	lands = lands.getType("Land");
      	    	
      	    	setTargetCard(c);
            	  
              }
            }
            public Card getTappedLand()
            {
            	//target creature that is going to attack
            	PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
    	    	
    	    	CardList lands = new CardList();
    	    	lands.addAll(play.getCards());
    	    	lands = lands.getType("Land");
    	    	
    	    	for(int i=0;i<lands.size();i++)
    	    	{
    	    		if (lands.get(i).isTapped())
    	    			return lands.get(i);
    	    	}
    	    	
    	    	return null;
            }//getAttacker()
    		
    		
    		public boolean canPlayAI()
    		{
    		   String phase = AllZone.Phase.getPhase();
         	   return phase.equals(Constant.Phase.Main2);
    		}
    		
    		public void resolve()
    		{

    			Card c = getTargetCard();
    			if (AllZone.GameAction.isCardInPlay(c)){
	    			AllZone.GameAction.sacrifice(c);
	    	    	makeToken();
	    	    	makeToken();
    			}
    	    	
    	    	
    		}//resolve
    		
    		public void makeToken()
    		{
    			Card c = new Card();

    			  c.setName("Goblin Soldier");
    	          c.setImageName("RW 1 1 Goblin Soldier");

    	          c.setOwner(card.getController());
    	          c.setController(card.getController());

    	          c.setManaCost("R W");
    	          c.setToken(true);
    	         
    	          c.addType("Creature");
    	          c.addType("Goblin");
    	          c.addType("Soldier");
    	          c.setBaseAttack(1);
    	          c.setBaseDefense(1);

    	          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
    	          play.add(c);
    			
    		}
        };
        
        Input runtime = new Input()
        {
		  private static final long serialVersionUID = -7823269301012427007L;

		  public void showMessage()
          {
        	PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
  	    	
        	CardList lands = new CardList();
  	    	lands.addAll(play.getCards());
  	    	lands = lands.getType("Land");

            stopSetNext(CardFactoryUtil.input_targetSpecific(ability, lands, "Select a land to sacrifice", false));

          }//showMessage()
        };//Input
        
    	card.addSpellAbility(ability);
    	ability.setDescription("2, Sacrifice a land: Put two 1/1 red and white Goblin Soldier creature tokens into play.");
    	ability.setStackDescription(card.getName() + " - put two 1/1 red and white Goblin Soldier creature tokens into play.");
    	ability.setBeforePayMana(runtime);
    
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    else if (cardName.equals("Dark Depths"))
    {
    	Command intoPlay = new Command()
        {
		   private static final long serialVersionUID = 6805304924956145866L;
		  
		   public boolean firstTime = true;
           public void execute()
           {

             if(firstTime){
           	  card.setCounter(Counters.ICE, 10); 
             }
             firstTime = false;
           }
         };
         
         card.addComesIntoPlayCommand(intoPlay);
         
         final SpellAbility ability = new Ability(card, "3")
         {
           public boolean canPlay()
           {
         	  SpellAbility sa;
         	  for (int i=0; i<AllZone.Stack.size(); i++)
         	  {
         	       sa = AllZone.Stack.peek(i);
         	       if (sa.getSourceCard().equals(card))
         	             return false;
         	  }
         	  
         	  if (card.getCounters(Counters.ICE) > 0 && AllZone.GameAction.isCardInPlay(card))
         		  return true;
         	  else
         		  return false;
           }
           public boolean canPlayAI() {
        	   String phase = AllZone.Phase.getPhase();
        	   return phase.equals(Constant.Phase.Main2);
           }

           public void resolve()
           {
        	 card.subtractCounter(Counters.ICE, 1);
        	 
        	 if (card.getCounters(Counters.ICE) == 0)
        	 {
	             PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
	
	             //make token
	             Card c = new Card();
	
	             c.setOwner(card.getController());
	             c.setController(card.getController());
	
	             c.setName("Marit Lage");
	             c.setManaCost("B");
	             c.setToken(true);
	
	             c.addType("Legendary");
	             c.addType("Creature");
	             c.addType("Avatar");
	             c.addIntrinsicKeyword("Flying");
	             c.addExtrinsicKeyword("Indestructible");
	             c.setBaseAttack(20);
	             c.setBaseDefense(20);
	
	             play.add(c);
	             AllZone.GameAction.sacrifice(card);
        	 }// if counters == 0
           }
         };
         ability.setDescription("3: Remove an ice counter from Dark Depths.");
         ability.setStackDescription(card.getName() +" - remove an ice counter.");
         
         card.addSpellAbility(ability);
    	
 }//*************** END ************ END **************************
  /*
  //*************** START *********** START **************************
    else if (cardName.equals("Acridian"))
    {
    	final String player = card.getController();

	  	final Ability echo = new Ability(card, "1 G")
	  	{
	  		public void resolve()
	  		{
	  			card.setEchoPaid(true);
	  			System.out.println("set echo to true");
	  		}
	  		public boolean canPlay()
	  		{
	  			//this is set to false, since it should only TRIGGER
	  			return false;
	  		}
	  	};// ability2
	  	//card.clearSpellAbility();
	  	card.addSpellAbility(echo);
	  	echo.setStackDescription(card.getName() + " - " + player + " paid echo.");
	  	
	  	Command paid = new Command() {public void execute() {AllZone.Stack.add(echo);}};
	  	
	  	//echo.setBeforePayMana(new Input_PayManaCost_Ability(echo.getManaCost(), paid));
	  	echo.setAfterPayMana(new Input_PayManaCost_Ability(echo.getManaCost(), paid));
		
	  	
   }//*************** END ************ END **************************

	*/

  //*************** START *********** START **************************
    else if (cardName.equals("Oros, the Avenger"))
    {
    	final String player = card.getController();

	  	final Ability ability2 = new Ability(card, "2 W")
	  	{
	  		public void resolve()
	  		{
	  			if (player.equals("Human"))
	  			{
	  				CardList cards = new CardList();
	  				PlayerZone hum = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
	  				PlayerZone comp = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
	  				cards.addAll(hum.getCards());
	  				cards.addAll(comp.getCards());
	  				cards = cards.getType("Creature");
	  				
	  				for (int i=0;i<cards.size(); i++)
	  				{
	  					if (!CardUtil.getColors(cards.get(i)).contains(Constant.Color.White))
	  					{
	  						cards.get(i).addDamage(3);
	  					}
	  				}
	  				
	  			}
	  		}
	  		public boolean canPlay()
	  		{
	  			//this is set to false, since it should only TRIGGER
	  			return false;
	  		}
	  	};// ability2
	  	//card.clearSpellAbility();
	  	card.addSpellAbility(ability2);
	  	ability2.setStackDescription(card.getName() + " - " + player + " deals 3 damage to each nonwhite creature.");
	
	  	
   }//*************** END ************ END **************************
    

  //*************** START *********** START **************************
  else if (cardName.equals("Treva, the Renewer"))
  {
    final String player = card.getController();

	final Ability ability2 = new Ability(card, "2 W")
	{
		public void resolve()
		{
			int lifeGain = 0;
			if (player.equals("Human"))
			{
				String choices[] = {"white", "blue" , "black" , "red" , "green"};
				Object o = AllZone.Display.getChoiceOptional("Select Color: ", choices);
				System.out.println("Color:" + o);
				lifeGain = CardFactoryUtil.getNumberOfPermanentsByColor((String)o);
				
			}
						
			PlayerLife life = AllZone.GameAction.getPlayerLife(player);
			life.addLife(lifeGain);
		}
		public boolean canPlay()
		{
			//this is set to false, since it should only TRIGGER
			return false;
		}
	};// ability2
	//card.clearSpellAbility();
	card.addSpellAbility(ability2);
	ability2.setStackDescription(card.getName() + " - " + player + " gains life equal to permanents of the chosen color.");

	
 }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    else if(cardName.equals("Karakas"))
    {
  	  final Ability_Tap ability = new Ability_Tap(card, "0")
  	  {

		private static final long serialVersionUID = -6589125907956046586L;

		public boolean canPlayAI()
  	      {
  	          CardList list = new CardList(AllZone.Human_Play.getCards());
  	          list = list.filter(new CardListFilter()
  	          {
				public boolean addCard(Card c) {
					return c.isCreature() && c.getKeyword().contains("Legendary");
				} 
  	          });
  	          
  	          setTargetCard(CardFactoryUtil.AI_getBestCreature(list, card));
  	          
  	          return list.size() > 0;
  	      }
  		  
  		  public void resolve()
  		  {
  			  Card c = getTargetCard();
  			  
  			  if (c!=null)
  			  {
  				  if ( CardFactoryUtil.canTarget(card, c) && c.isCreature() && c.getType().contains("Legendary") )
  					  AllZone.GameAction.moveTo(AllZone.getZone(Constant.Zone.Hand, card.getOwner()), c);
  			  }  
  		  }
  	  };
  	  
  	  Input runtime = new Input()
      {

		private static final long serialVersionUID = -7649200192384343204L;

		public void showMessage()
        {
            CardList choice = new CardList();
            choice.addAll(AllZone.Human_Play.getCards());
            choice.addAll(AllZone.Computer_Play.getCards());

            choice = choice.getType("Creature");
            choice = choice.filter(new CardListFilter()
            {
              public boolean addCard(Card c)
              {
                return (c.isCreature() && c.getType().contains("Legendary"));
              }
            });
            
            //System.out.println("size of choice: " + choice.size());
            stopSetNext(CardFactoryUtil.input_targetSpecific(ability, choice, "Select target Legendary creature:", true));
          }
        };
  	  
  	  ability.setDescription("tap: Return target legendary creature to its owner's hand.");
  	  //ability.setStackDescription(card.getName() + " - gives target creature +1/+2 until end of turn.");
  	  
  	  card.addSpellAbility(ability);
  	  ability.setBeforePayMana(runtime);
  	  
  	  //not sure what's going on here, maybe because it's a land it doesn't add the ability to the text?
  	  //anyway, this does the trick:
  	  //card.removeIntrinsicKeyword("tap: add G");
  	  card.setText(card.getSpellText() +  "\r\ntap: Return target legendary creature to its owner's hand.");
  	  //card.addIntrinsicKeyword("tap: add G");
  	  
    }//*************** END ************ END **************************

  //*************** START *********** START **************************
  else if(cardName.equals("Pendelhaven"))
  {
	  final Ability_Tap ability = new Ability_Tap(card, "0")
	  {
		private static final long serialVersionUID = 8154776336533992188L;

		public boolean canPlayAI()
	      {
	          return getAttacker() != null;
	      }
		  
		  public void chooseTargetAI()
		  {
			  setTargetCard(getAttacker());
		  }
		  public Card getAttacker()
		  {
			  //target creature that is going to attack
	          Combat c = ComputerUtil.getAttackers();
	          CardList att = new CardList();
	          att.addAll(c.getAttackers());
	          
	          for (int i=0; i<att.size(); i++)
	          {
	        	  Card crd = att.get(i);
	        	  if (crd.getNetAttack() == 1 && crd.getNetDefense() == 1)
	        		  return crd;
	          }
	          
	          return null;
		  }//getAttacker()
		  
		  public void resolve()
		  {
	  
			  final Card[] target = new Card[1];
	          final Command untilEOT = new Command()
	          {

				private static final long serialVersionUID = 6362813153010836856L;

				public void execute()
	            {
	              if(AllZone.GameAction.isCardInPlay(target[0]))
	              {
	                target[0].addTempAttackBoost(-1);
	                target[0].addTempDefenseBoost(-2);
	              }
	            }
	          
	          };
	          
	          target[0] = getTargetCard();
	          if(AllZone.GameAction.isCardInPlay(target[0]) && target[0].getNetDefense() == 1 && target[0].getNetAttack() == 1 && CardFactoryUtil.canTarget(card, target[0]))
	          {
	            target[0].addTempAttackBoost(1);
	            target[0].addTempDefenseBoost(2);
	
	            AllZone.EndOfTurn.addUntil(untilEOT);
	          }
		  }
	  };
	  
	  Input runtime = new Input()
      {
		private static final long serialVersionUID = 6126636768830864856L;

		public void showMessage()
        {
          CardList choice = new CardList();
          choice.addAll(AllZone.Human_Play.getCards());
          choice.addAll(AllZone.Computer_Play.getCards());

          choice = choice.getType("Creature");
          choice = choice.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (c.getNetAttack() == 1 && c.getNetDefense() == 1);
            }
          });
          
          //System.out.println("size of choice: " + choice.size());
          stopSetNext(CardFactoryUtil.input_targetSpecific(ability, choice, "Select target 1/1 Creature:", true));
        }
      };
	  
	  ability.setDescription("tap: Target 1/1 creature gets +1/+2 until end of turn.");
	  ability.setStackDescription(card.getName() + " - gives target creature +1/+2 until end of turn.");
	  
	  card.addSpellAbility(ability);
	  ability.setBeforePayMana(runtime);
	  
	  //not sure what's going on here, maybe because it's a land it doesn't add the ability to the text?
	  //anyway, this does the trick:
	  //card.removeIntrinsicKeyword("tap: add G");
	  card.setText(card.getSpellText() +  "\r\ntap: Target 1/1 creature gets +1/+2 until end of turn.");
	  //card.addIntrinsicKeyword("tap: add G");
	  
  }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
  else if(cardName.equals("Okina, Temple to the Grandfathers"))
  {
	  final Ability_Tap ability = new Ability_Tap(card, "G")
	  {
		private static final long serialVersionUID = 8154776336533992188L;

		public boolean canPlayAI()
	      {
	          return getAttacker() != null;
	      }
		  
		  public void chooseTargetAI()
		  {
			  setTargetCard(getAttacker());
		  }
		  public Card getAttacker()
		  {
			  //target creature that is going to attack
	          Combat c = ComputerUtil.getAttackers();
	          CardList att = new CardList();
	          att.addAll(c.getAttackers());
	          
	          for (int i=0; i<att.size(); i++)
	          {
	        	  Card crd = att.get(i);
	        	  if (crd.getType().contains("Legendary"))
	        		  return crd;
	          }
	          
	          return null;
		  }//getAttacker()
		  
		  public void resolve()
		  {
	  
			  final Card[] target = new Card[1];
	          final Command untilEOT = new Command()
	          {

				private static final long serialVersionUID = 6362813153010836856L;

				public void execute()
	            {
	              if(AllZone.GameAction.isCardInPlay(target[0]))
	              {
	                target[0].addTempAttackBoost(-1);
	                target[0].addTempDefenseBoost(-1);
	              }
	            }
	          
	          };
	          
	          target[0] = getTargetCard();
	          if(AllZone.GameAction.isCardInPlay(target[0]) && target[0].getType().contains("Legendary") && CardFactoryUtil.canTarget(card, target[0]))
	          {
	            target[0].addTempAttackBoost(1);
	            target[0].addTempDefenseBoost(1);
	
	            AllZone.EndOfTurn.addUntil(untilEOT);
	          }
		  }
	  };
	  
	  Input runtime = new Input()
      {
		private static final long serialVersionUID = 6126636768830864856L;

		public void showMessage()
        {
          CardList choice = new CardList();
          choice.addAll(AllZone.Human_Play.getCards());
          choice.addAll(AllZone.Computer_Play.getCards());

          choice = choice.getType("Creature");
          choice = choice.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (c.getType().contains("Legendary"));
            }
          });
          
          //System.out.println("size of choice: " + choice.size());
          stopSetNext(CardFactoryUtil.input_targetSpecific(ability, choice, "Select target legendary Creature:", true));
        }
      };
	  
	  ability.setDescription("G, tap: Target legendary creature gets +1/+1 until end of turn.");
	  ability.setStackDescription(card.getName() + " - gives target legendary creature +1/+1 until end of turn.");
	  
	  card.addSpellAbility(ability);
	  ability.setBeforePayMana(runtime);
	  
	  //not sure what's going on here, maybe because it's a land it doesn't add the ability to the text?
	  //anyway, this does the trick:
	  //card.removeIntrinsicKeyword("tap: add G");
	  card.setText(card.getSpellText() +  "\r\nG, tap: Target legendary creature gets +1/+1 until end of turn.");
	  //card.addIntrinsicKeyword("tap: add G");
	  
  }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
  else if(cardName.equals("Wirewood Lodge"))
  {
	  final Ability_Tap ability = new Ability_Tap(card, "G")
	  {
		  private static final long serialVersionUID = -4352872789672871590L;

		public boolean canPlayAI()
	      {
	          return false;
	      }
		  
		  public void resolve()
		  {
	  
			  final Card[] target = new Card[1];
	          
	          
	          target[0] = getTargetCard();
	          if(AllZone.GameAction.isCardInPlay(target[0]) && target[0].isTapped() && 
	        	(target[0].getType().contains("Elf") || target[0].getKeyword().contains("Changeling")) && CardFactoryUtil.canTarget(card, target[0]))
	          {
	        	  target[0].untap();
	          }
		  }
	  };
	  
	  Input runtime = new Input()
      {
        private static final long serialVersionUID = -6822924521729238991L;

		public void showMessage()
        {
          CardList choice = new CardList();
          choice.addAll(AllZone.Human_Play.getCards());
          choice.addAll(AllZone.Computer_Play.getCards());

          choice = choice.getType("Elf");
          choice = choice.filter(new CardListFilter()
          {
            public boolean addCard(Card c)
            {
              return (c.isTapped());
            }
          });
          
          //System.out.println("size of choice: " + choice.size());
          stopSetNext(CardFactoryUtil.input_targetSpecific(ability, choice, "Select target Elf", true));
        }
      };
	  
	  ability.setDescription("G, tap: Untap target Elf.");
	  ability.setStackDescription(card.getName() + " - untaps target elf.");
	  
	  card.addSpellAbility(ability);
	  ability.setBeforePayMana(runtime);
	  
	  //not sure what's going on here, maybe because it's a land it doesn't add the ability to the text?
	  //anyway, this does the trick:
	  //card.removeIntrinsicKeyword("tap: add 1");
	  card.setText(card.getSpellText() +  "\r\nG, tap: Untap target Elf.");
	  //card.addIntrinsicKeyword("tap: add 1");
	  
  }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
  else if(cardName.equals("Academy Ruins"))
  {
	  final Ability_Tap ability = new Ability_Tap(card, "1 U")
	  {
		private static final long serialVersionUID = -1322368528417127121L;

		public void resolve()
		{
			String player = card.getController();
            if(player.equals(Constant.Player.Human))
              humanResolve();
            else
              computerResolve();
		}
		
		public void humanResolve()
          {
            CardList cards = new CardList(AllZone.Human_Graveyard.getCards());

            CardList list = new CardList();
            
            for (int i=0;i < cards.size(); i++)
            {
          	  //System.out.println("type: " +cards.get(i).getType());
          	  if (cards.get(i).getType().contains("Artifact")){
          		  //System.out.println(cards.get(i).getName());
          		  Card c = cards.get(i);
          		  list.add(c);
          		  
          	  }
            }
            
            if (list.size() != 0) {          
  	          Object check = AllZone.Display.getChoiceOptional("Select Artifact", list.toArray());
  	          if(check != null)
  	          {
  	            //PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
  	            //library.add((Card)check, 0);
  	            AllZone.GameAction.moveToTopOfLibrary((Card)check);
  	          }
            }
          }
          public void computerResolve()
          {
            Card[] grave = AllZone.Computer_Graveyard.getCards();
            CardList list = new CardList(grave);
            CardList arts = new CardList();
            
            for (int i=0;i < list.size(); i++)
            {
          	  if (list.get(i).getType().contains("Artifact")){
          		  Card k = list.get(i);
          		  arts.add(k);
          	  }
            
            }
            
            //pick best artifact
            if (arts.size() != 0){
  	          Card c = CardFactoryUtil.AI_getBestArtifact(list);
  	          if(c == null)
  	            c = grave[0];
  	          System.out.println("computer picked - " +c);
  	          AllZone.Computer_Graveyard.remove(c);
  	          AllZone.Computer_Library.add(c, 0);
            }
          }//computerResolve
          
          public boolean canPlay(){
        	  String controller = card.getController();
        	  
        	  PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, controller);
        	  CardList list = new CardList(grave.getCards());
        	  CardList cards = new CardList();
        	  
        	  for (int i=0;i<list.size();i++)
        	  {
        		  if (list.get(i).getType().contains("Artifact") ){
        			  cards.add(list.get(i));
        		  }
        	  }
     
        	  if (cards.size() > 0 && AllZone.GameAction.isCardInPlay(card) && card.isUntapped())
        		  return true;
        	  else
        		  return false;
          }
		
	  };
	  
	  ability.setDescription("1 U, tap: Put target artifact card in your graveyard on top of your library.");
	  ability.setStackDescription(card.getName() + " - put artifact card in your graveyard on top of your library.");
	  
	  card.addSpellAbility(ability);
	  
	  //not sure what's going on here, maybe because it's a land it doesn't add the ability to the text?
	  //anyway, this does the trick:
	  //card.removeIntrinsicKeyword("tap: add 1");
	  card.setText(card.getSpellText() +  "\r\n1 U, tap: Put target artifact card in your graveyard on top of your library.");
	  //card.addExtrinsicKeyword("tap: add 1");
	  
  }//*************** END ************ END **************************
  
  //*************** START *********** START **************************
  else if(cardName.equals("Volrath's Stronghold"))
  {
	  final Ability_Tap ability = new Ability_Tap(card, "1 B")
	  {
		private static final long serialVersionUID = 2821525387844776907L;

		public void resolve()
		{
			String player = card.getController();
            if(player.equals(Constant.Player.Human))
              humanResolve();
            else
              computerResolve();
		}
		
		public void humanResolve()
          {
            CardList cards = new CardList(AllZone.Human_Graveyard.getCards());

            CardList list = new CardList();
            
            for (int i=0;i < cards.size(); i++)
            {
          	  //System.out.println("type: " +cards.get(i).getType());
          	  if (cards.get(i).getType().contains("Creature")){
          		  //System.out.println(cards.get(i).getName());
          		  Card c = cards.get(i);
          		  list.add(c);
          		  
          	  }
            }
            
            if (list.size() != 0) {          
  	          Object check = AllZone.Display.getChoiceOptional("Select Creature", list.toArray());
  	          if(check != null)
  	          {
  	            //PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
  	            //library.add((Card)check, 0);
  	            AllZone.GameAction.moveToTopOfLibrary((Card)check);
  	          }
            }
          }
          public void computerResolve()
          {
            Card[] grave = AllZone.Computer_Graveyard.getCards();
            CardList list = new CardList(grave);
            CardList creats = new CardList();
            
            for (int i=0;i < list.size(); i++)
            {
          	  if (list.get(i).getType().contains("Creature")){
          		  Card k = list.get(i);
          		  creats.add(k);
          	  }
            
            }
            
            //pick best artifact
            if (creats.size() != 0){
  	          Card c = CardFactoryUtil.AI_getBestCreature(list);
  	          if(c == null)
  	            c = grave[0];
  	          //System.out.println("computer picked - " +c);
  	          AllZone.Computer_Graveyard.remove(c);
  	          //AllZone.Computer_Library.add(c, 0);
  	          AllZone.GameAction.moveToTopOfLibrary(c);
            }
          }//computerResolve
          
          public boolean canPlay(){
        	  String controller = card.getController();
        	  
        	  PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, controller);
        	  CardList list = new CardList(grave.getCards());
        	  CardList cards = new CardList();
        	  
        	  for (int i=0;i<list.size();i++)
        	  {
        		  if (list.get(i).getType().contains("Creature") ){
        			  cards.add(list.get(i));
        		  }
        	  }
     
        	  if (cards.size() > 0 && AllZone.GameAction.isCardInPlay(card) && card.isUntapped())
        		  return true;
        	  else
        		  return false;
          }
		
	  };
	  
	  ability.setDescription("1 B, tap: Put target creature card in your graveyard on top of your library.");
	  ability.setStackDescription(card.getName() + " - put creature card in your graveyard on top of your library.");
	  
	  card.addSpellAbility(ability);
	  
	  //not sure what's going on here, maybe because it's a land it doesn't add the ability to the text?
	  //anyway, this does the trick:
	  //card.removeIntrinsicKeyword("tap: add 1");
	  card.setText(card.getSpellText() +  "\r\n1 U, tap: Put target creature card in your graveyard on top of your library.");
	  //card.addExtrinsicKeyword("tap: add 1");
	  
  }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
  else if(cardName.equals("Oboro, Palace in the Clouds"))
  {
	  final Ability ability = new Ability(card, "1")
	  {

		public boolean canPlayAI()
		{
			return false;
		}
		  
		public void resolve()
		{
			PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
			AllZone.GameAction.moveTo(hand, card);
		}
	  };
	  
	  ability.setDescription("1: Return Oboro, Palace in the Clouds to your hand.");
	  ability.setStackDescription("Return " + card.getName() + " to your hand.");
	  
	  card.addSpellAbility(ability);
	  
	  //not sure what's going on here, maybe because it's a land it doesn't add the ability to the text?
	  //anyway, this does the trick:
	  //card.removeIntrinsicKeyword("tap: add 1");
	  card.setText(card.getSpellText() +  "\r\n1: Return Oboro, Palace in the Clouds to your hand.");
	  //card.addExtrinsicKeyword("tap: add 1");
	  
  }//*************** END ************ END **************************
   
  //*************** START *********** START **************************
  else if(cardName.equals("Mikokoro, Center of the Sea"))
  {
	  final Ability_Tap ability = new Ability_Tap(card, "2")
	  {
		private static final long serialVersionUID = -199960897120235012L;

		public void resolve()
		  {
			  AllZone.GameAction.drawCard(Constant.Player.Computer);
			  AllZone.GameAction.drawCard(Constant.Player.Human);
		  }
	  };
	  
	  ability.setDescription("2, tap: Each player draws a card.");
	  ability.setStackDescription(card.getName() + " - Each player draws a card.");
	  
	  card.addSpellAbility(ability);
	  
	  //not sure what's going on here, maybe because it's a land it doesn't add the ability to the text?
	  //anyway, this does the trick:
	  //card.removeIntrinsicKeyword("tap: add 1");
	  card.setText(card.getSpellText() +  "\r\n2, tap: Each player draws a card.");
	  //card.addExtrinsicKeyword("tap: add 1");
	  
  }//*************** END ************ END **************************
    
  //*************** START *********** START **************************  
  else if(cardName.equals("Gargoyle Castle"))
  {
	  final Ability_Tap ability = new Ability_Tap(card, "5")
	  {

		private static final long serialVersionUID = 8524185208900629992L;

		public boolean canPlay()
		  {
			  if (AllZone.GameAction.isCardInPlay(card) && card.isUntapped())
				  return true;
			  else
				  return false;
		  }
		  
		  public void resolve()
		  {
			  String player = card.getController();
			  AllZone.GameAction.sacrifice(card);
			  
			  PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);

	          //make token
	          Card c = new Card();

	          c.setOwner(card.getController());
	          c.setController(card.getController());

	          c.setName("Gargoyle");
	          c.setImageName("C 3 4 Gargoyle");
	          c.setManaCost("1");
	          c.setToken(true);

	          c.addType("Artifact");
	          c.addType("Creature");
	          c.addType("Gargoyle");
	          c.setBaseAttack(3);
	          c.setBaseDefense(4);
	          c.addIntrinsicKeyword("Flying");

	          play.add(c);
		  }
	  };
	  
	  ability.setDescription("5, tap, sacrifice Gargoyle Castle: Put a 3/4 colorless Gargoyle artifact creature token with flying onto the battlefield.");
	  ability.setStackDescription(card.getName() + " - Put a 3/4 colorless Gargoyle artifact creature token with flying onto the battlefield.");
	  
	  card.addSpellAbility(ability);
	  
	  //not sure what's going on here, maybe because it's a land it doesn't add the ability to the text?
	  //anyway, this does the trick:
	  //card.removeIntrinsicKeyword("tap: add 1");
	  card.setText(card.getSpellText() +  "\r\n5, tap, sacrifice Gargoyle Castle: Put a 3/4 colorless Gargoyle artifact creature token with flying onto the battlefield.");
	  //card.addIntrinsicKeyword("tap: add 1");
	  
  }//*************** END ************ END **************************
  
  //*************** START *********** START **************************  
  else if(cardName.equals("Kher Keep"))
  {
	  final Ability_Tap ability = new Ability_Tap(card, "1 R")
	  {
		private static final long serialVersionUID = 4037838521451709399L;

		public boolean canPlay()
		  {
			  if (AllZone.GameAction.isCardInPlay(card) && card.isUntapped())
				  return true;
			  else
				  return false;
		  }
		  
		  public void resolve()
		  {
			  String player = card.getController();
			  
			  PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);

	          //make token
	          Card c = new Card();

	          c.setOwner(card.getController());
	          c.setController(card.getController());

	          c.setName("Kobolds of Kher Keep");
	          c.setManaCost("R");
	          c.setToken(true);

	          c.addType("Creature");
	          c.addType("Kobold");
	          c.setBaseAttack(0);
	          c.setBaseDefense(1);

	          play.add(c);
		  }
	  };
	  
	  ability.setDescription("1 R, tap: Put a 0/1 red Kobold creature token named Kobolds of Kher Keep into play.");
	  ability.setStackDescription(card.getName() + " - Put a 0/1 red Kobold creature token named Kobolds of Kher Keep into play.");
	  
	  card.addSpellAbility(ability);
	  
	  //not sure what's going on here, maybe because it's a land it doesn't add the ability to the text?
	  //anyway, this does the trick:
	  //card.removeIntrinsicKeyword("tap: add 1");
	  card.setText(card.getSpellText() +  "\r\n1 R, tap: Put a 0/1 red Kobold creature token named Kobolds of Kher Keep into play.");
	  //card.addIntrinsicKeyword("tap: add 1");
	  
  }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
  else if(cardName.equals("Vitu-Ghazi, the City-Tree"))
  {
	  final Ability_Tap ability = new Ability_Tap(card, "2 G W")
	  {
		private static final long serialVersionUID = 1781653158406511188L;

		public boolean canPlay()
		  {
			  if (AllZone.GameAction.isCardInPlay(card))
				  return true;
			  else
				  return false;
		  }
		  
		  public void resolve()
		  {
			  String player = card.getController();
			  
			  PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);

	          //make token
	          Card c = new Card();

	          c.setOwner(card.getController());
	          c.setController(card.getController());

	          c.setName("Saproling");
	          c.setImageName("G 1 1 Saproling");
	          c.setManaCost("G");
	          c.setToken(true);

	          c.addType("Creature");
	          c.addType("Saproling");
	          c.setBaseAttack(1);
	          c.setBaseDefense(1);

	          play.add(c);
		  }
	  };
	  
	  ability.setDescription("2 G W, tap: Put a 1/1 green Saproling creature token into play.");
	  ability.setStackDescription(card.getName() + " - Put a 1/1 green Saproling creature token named into play.");
	  
	  card.addSpellAbility(ability);
	  
	  //not sure what's going on here, maybe because it's a land it doesn't add the ability to the text?
	  //anyway, this does the trick:
	  //card.removeIntrinsicKeyword("tap: add 1");
	  card.setText(card.getSpellText() +  "\r\n 2 G W, tap: Put a 1/1 green Saproling creature token into play.");
	  //card.addIntrinsicKeyword("tap: add 1");
	  
  }//*************** END ************ END **************************
    
  //*************** START *********** START **************************  
  else if(cardName.equals("Hatching Plans"))
  {
	  
	  final Ability ability = new Ability(card, "0")
      {
        public void resolve()
        {
        	AllZone.GameAction.drawCard(card.getController());
        	AllZone.GameAction.drawCard(card.getController());
        	AllZone.GameAction.drawCard(card.getController());        	
        }
      };
      
	  Command draw3Cards = new Command()
      {
		private static final long serialVersionUID = -4919203791300685078L;

		public void execute()
         {
        	 ability.setStackDescription(card.getName()+ " - draw three cards.");
             AllZone.Stack.add(ability);
         }
       };
       
       card.addDestroyCommand(draw3Cards);

    
  }//*************** END ************ END **************************  
    
  //*************** START *********** START **************************  
  else if(cardName.equals("Anodet Lurker"))
  {
	  
	  final Ability ability = new Ability(card, "0")
      {
        public void resolve()
        {
        	PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
            life.addLife(3);
        }
      };
      
	  Command gain3Life = new Command()
      {
		private static final long serialVersionUID = 9156307402354672176L;

		public void execute()
         {
        	 ability.setStackDescription(card.getName()+ " - Gain 3 life.");
             AllZone.Stack.add(ability);
         }
       };
       
       card.addDestroyCommand(gain3Life);
  }//*************** END ************ END **************************  

    
    
    
  //*************** START *********** START **************************  
  else if(cardName.equals("Tarpan"))
  {
	  
	  final Ability ability = new Ability(card, "0")
      {
        public void resolve()
        {
        	PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
            life.addLife(1);
        }
      };
      
	  Command gain1Life = new Command()
      {
		private static final long serialVersionUID = 206350020224577500L;

		public void execute()
         {
        	 ability.setStackDescription(card.getName()+ " - Gain 1 life.");
             AllZone.Stack.add(ability);
         }
       };
       
       card.addDestroyCommand(gain1Life);
  }//*************** END ************ END **************************  
    
  //*************** START *********** START **************************  
  else if(cardName.equals("Onulet"))
  {
	  
	  final Ability ability = new Ability(card, "0")
      {
        public void resolve()
        {
        	PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
            life.addLife(2);
        }
      };
      
	  Command gain2Life = new Command()
      {
		private static final long serialVersionUID = 7840609060047275126L;

		public void execute()
         {
        	 ability.setStackDescription(card.getName()+ " - Gain 2 life.");
             AllZone.Stack.add(ability);
         }
       };
       
       card.addDestroyCommand(gain2Life);

    
  }//*************** END ************ END **************************  
    
  //*************** START *********** START **************************  
  else if(cardName.equals("Sprouting Thrinax"))
  {   
 	 
 	 final Ability ability = new Ability(card, "0")
      {
        public void resolve()
        {
     	   makeToken();
     	   makeToken();
     	   makeToken();
        }//resolve()
        
        void makeToken()
        {
          Card c = new Card();

          c.setName("Saproling");
          c.setImageName("G 1 1 Saproling");

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setManaCost("G");
          c.setToken(true);
         
          c.addType("Creature");
          c.addType("Saproling");
          c.setBaseAttack(1);
          c.setBaseDefense(1);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//makeToken()
      };//Ability
 	 
 	 Command make3Tokens = new Command()
      {
		private static final long serialVersionUID = 5246587197020320581L;

         public void execute()
         {
         	ability.setStackDescription(card.getName()+ " - put three 1/1 Saproling creature tokens into play.");
            AllZone.Stack.add(ability);
         }
      };
      
      card.addDestroyCommand(make3Tokens);
      
   }//*************** END ************ END **************************
    
    
    
  //*************** START *********** START **************************
  else if(cardName.equals("Solemn Simulacrum"))
  {   
 	 
 	 final Ability ability = new Ability(card, "0")
      {
        public void resolve()
        {
     	   PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
 	       	PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
 	       	
 	       	CardList basic = new CardList(lib.getCards());
 	       	basic = basic.getType("Basic");
 	       	
 	       	if (card.getController().equals(Constant.Player.Computer))
 	       	{
 	       		if (basic.size() > 0)
 	       		{
 	       			Card c = basic.get(0);
 	       			lib.remove(c);
 	       			play.add(c);
 	       			c.tap();
 	       			
 	       		}
 	       	}
 	       	else // human
 	       	{
 	       		if (basic.size() > 0) 
 	       		{
 	       			Object o = AllZone.Display.getChoiceOptional("Select Basic Land card to put into play tapped: ", basic.toArray());
 	       			if (o != null)
 	       			{	
 	       				Card c = (Card)o;
 	       				lib.remove(c);
 	       				play.add(c);
 	       				c.tap();
 	       			}
 	       		}
 	       	}
 	       	AllZone.GameAction.shuffle(card.getController());
        }//resolve()
      };//Ability
 	 
 	 Command fetchBasicLand = new Command()
      {
		private static final long serialVersionUID = -7912757481694029348L;

         public void execute()
         {
         	ability.setStackDescription(card.getName()+ " - search library for a basic land card and put it into play tapped.");
            AllZone.Stack.add(ability);
         }
      };
      
      final Ability ability2 = new Ability(card, "0")
      {
        public void resolve()
        {
     	   
 	       	AllZone.GameAction.drawCard(card.getController());
        }//resolve()
      };//Ability
      
      Command draw = new Command()
      {
		private static final long serialVersionUID = -549395102229088642L;

         public void execute()
         {
         	ability2.setStackDescription(card.getName()+ " - Draw a card.");
            AllZone.Stack.add(ability2);
         }
      };

      card.addDestroyCommand(draw);
      card.addComesIntoPlayCommand(fetchBasicLand);
      
   }//*************** END ************ END **************************
      
  //*************** START *********** START **************************
  else if(cardName.equals("Gods' Eye, Gate to the Reikai"))
  {   
 	 
 	 final Ability ability = new Ability(card, "0")
      {
        public void resolve()
        {
     	    PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
     	    
     	   Card c = new Card();
           
           c.setOwner(card.getController());
           c.setController(card.getController());

           c.setManaCost("1");
           c.setToken(true);
          
           c.setName("Spirit");
           c.setImageName("C 1 1 Spirit");
           
           c.addType("Creature");
           c.addType("Spirit");
           c.setBaseAttack(1);
           c.setBaseDefense(1);
           
           play.add(c);
 	      
        }//resolve()
      };//Ability
 	 
 	 Command makeToken = new Command()
      {
		private static final long serialVersionUID = 2339209292936869322L;

         public void execute()
         {
         	ability.setStackDescription(card.getName()+ " - put a 1/1 Spirit creature token into play");
            AllZone.Stack.add(ability);
         }
      };

      card.addDestroyCommand(makeToken);
   }//*************** END ************ END **************************
    
 //*************** START *********** START **************************
 else if(cardName.equals("Flagstones of Trokair"))
 {   
	 
	 final Ability ability = new Ability(card, "0")
     {
       public void resolve()
       {
    	    PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
	       	PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
	       	
	       	CardList plains = new CardList(lib.getCards());
	       	plains = plains.getType("Plains");
	       	
	       	if (card.getController().equals(Constant.Player.Computer))
	       	{
	       		if (plains.size() > 0)
	       		{
	       			Card c = plains.get(0);
	       			lib.remove(c);
	       			play.add(c);
	       			c.tap();
	       			
	       		}
	       	}
	       	else // human
	       	{
	       		if (plains.size() > 0) 
	       		{
	       			Object o = AllZone.Display.getChoiceOptional("Select plains card to put into play tapped: ", plains.toArray());
	       			if (o != null)
 	       			{	
 	       				Card c = (Card)o;
 	       				lib.remove(c);
 	       				play.add(c);
 	       				c.tap();
 	       			}
	       		}
	       	}
	       	AllZone.GameAction.shuffle(card.getController());
       }//resolve()
     };//Ability
	 
	 Command fetchPlains = new Command()
     {

        private static final long serialVersionUID = 5991465998493672076L;

		public void execute()
        {
        	ability.setStackDescription(card.getName()+ " - search library for a plains card and put it into play tapped.");
            AllZone.Stack.add(ability);
        }
     };

     card.addDestroyCommand(fetchPlains);
  }//*************** END ************ END **************************
 
    //*************** START *********** START **************************
    if (cardName.equals("Master Transmuter"))
    {
    	final Ability_Tap ability = new Ability_Tap(card, "U")
    	{

			private static final long serialVersionUID = -9076784333448226913L;

			public void resolve() {
				PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
				PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
				CardList artifacts = new CardList(hand.getCards());
				artifacts = artifacts.getType("Artifact");
				if (card.getController().equals(Constant.Player.Human))
				{
					Object o = AllZone.Display.getChoiceOptional("Select artifact to put onto the battlefield: ", artifacts.toArray());
					if(o!=null)
					{
						Card c = (Card)o;
						hand.remove(c);
						play.add(c);
					}
				}
				else
				{
					//CardList arts = new CardList(play.getCards());
					//arts = arts.getType("Artifact");
					
					Card c = getTargetCard();
					AllZone.GameAction.moveTo(hand, c);
					
					Card crd = CardFactoryUtil.AI_getMostExpensivePermanent(artifacts, card, false);
					hand.remove(crd);
					play.add(crd);
					
				}
			}
			
			public boolean canPlayAI()
			{
				PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
				PlayerZone play = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
				
				CardList handArts = new CardList(hand.getCards());
				handArts = handArts.getType("Artifact");
				
				CardList playArts = new CardList(play.getCards());
				playArts = playArts.getType("Artifact");
				
				if (handArts.size() > 0 && playArts.size() > 0){
					
					if  (CardUtil.getConvertedManaCost(CardFactoryUtil.AI_getCheapestPermanent(playArts, card, false).getManaCost()) < 
						   CardUtil.getConvertedManaCost(CardFactoryUtil.AI_getMostExpensivePermanent(handArts, card, false).getManaCost()))
					{
						setTargetCard(CardFactoryUtil.AI_getCheapestPermanent(playArts, card, false));
						return true;
					}
				
				}
				return false;
			}
    	};
    	
    	Input target = new Input()
        {
				
		private static final long serialVersionUID = 4246650335595231655L;
		public void showMessage()
          {
            AllZone.Display.showMessage("Select artifact to return to hand");
            ButtonUtil.enableOnlyCancel();
          }
          public void selectButtonCancel() {stop();}
          public void selectCard(Card c, PlayerZone zone)
          {
        	PlayerZone play = AllZone.getZone(Constant.Zone.Play,card.getController());
            if(c.isArtifact() && AllZone.GameAction.isCardInZone(c, play))
            {
              PlayerZone hand = AllZone.getZone(Constant.Zone.Hand,card.getController());
              
              AllZone.GameAction.moveTo(hand, c);
              AllZone.Stack.add(ability);
              stopSetNext(new ComputerAI_StackNotEmpty());
            }
          }//selectCard()
        };//Input
    	
        card.addSpellAbility(ability);
        ability.setDescription("U, tap, Return an artifact you control to its owner's hand: You may put an artifact card from your hand onto the battlefield.");
        ability.setStackDescription(card + "You may put an artifact card from your hand onto the battlefield");
        ability.setAfterPayMana(target);
    	
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    else if(cardName.equals("Hanna, Ship's Navigator"))
    {
    	final Ability_Tap ability = new Ability_Tap(card, "1 U W")
        {
          private static final long serialVersionUID = 7959233413572648987L;

		public void resolve()
          {
          	String player = card.getController();
              if(player.equals(Constant.Player.Human))
                humanResolve();
              else
                computerResolve();
          }//resolve()
          public void humanResolve()
          {
            CardList cards = new CardList(AllZone.Human_Graveyard.getCards());
            //legends = legends.getType().contains("Legendary");
            CardList list = new CardList();
            
            for (int i=0;i < cards.size(); i++)
            {
          	  //System.out.println("type: " +cards.get(i).getType());
          	  if (cards.get(i).getType().contains("Artifact") || cards.get(i).getType().contains("Enchantment")){
          		  //System.out.println(cards.get(i).getName());
          		  Card c = cards.get(i);
          		  list.add(c);
          		  
          	  }
            }
            
            if (list.size() != 0) {          
  	          Object check = AllZone.Display.getChoiceOptional("Select Artifact or Enchantment", list.toArray());
  	          if(check != null)
  	          {
  	            PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
  	            AllZone.GameAction.moveTo(hand, (Card)check);
  	          }
            }
          }
          public void computerResolve()
          {
            Card[] grave = AllZone.Computer_Graveyard.getCards();
            CardList list = new CardList(grave);
            CardList artenchants = new CardList();
            //list = list.getType("Creature");

            for (int i=0;i < list.size(); i++)
            {
          	  if (list.get(i).getType().contains("Artifact") || list.get(i).getType().contains("Enchantment")){
          		  Card k = list.get(i);
          		  artenchants.add(k);
          	  }
            
            }
            
            //pick best artifact / enchantment
            if (artenchants.size() != 0){
  	          Card c = CardFactoryUtil.AI_getBestArtifact(list);
  	          if(c == null)
  	        	c = CardFactoryUtil.AI_getBestEnchantment(list,card, true);
  	          if(c == null)
  	            c = grave[0];
  	          System.out.println("computer picked - " +c);
  	          AllZone.Computer_Graveyard.remove(c);
  	          AllZone.Computer_Hand.add(c);
            }
          }//computerResolve
          
          public boolean canPlay(){
        	  String controller = card.getController();
        	  
        	  PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, controller);
        	  CardList list = new CardList(grave.getCards());
        	  CardList cards = new CardList();
        	  
        	  for (int i=0;i<list.size();i++)
        	  {
        		  if (list.get(i).getType().contains("Artifact") || list.get(i).getType().contains("Enchantment")){
        			  cards.add(list.get(i));
        		  }
        	  }
        	  
        	  //System.out.println("cards.size(): " + cards.size());
        	  //hasSickness is a little hack, I'm not sure about the setBeforeMana input
        	  if (cards.size() > 0 && AllZone.GameAction.isCardInPlay(card) && !card.hasSickness() && card.isUntapped())
        		  return true;
        	  else 
        		  return false;
          }
          
          
        };//SpellAbility
        //card.addSpellAbility(ability);
        ability.setDescription("1 U W, tap: Return target artifact or enchantment card from your graveyard to your hand.");
        ability.setBeforePayMana(new Input_PayManaCost(ability));
        ability.setStackDescription("Hanna, Ship's Navigator - Returns an artifact or enchantment card from graveyard to hand.");
        card.addSpellAbility(ability);
  	  
        
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
  else if(cardName.equals("Sleight of Hand"))
  {
	  final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 5608200094037045828L;
		public boolean canPlay()
		{
			PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
			if (library.size() >= 1 && super.canPlay())
				return true;
			else
				return false;
			
		}
        public void resolve()
        {
        	
        	PlayerZone library = AllZone.getZone(Constant.Zone.Library,card.getController());
        	PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
        	CardList lib = new CardList(library.getCards());
        	
        	CardList topTwo = new CardList();
        	
        	if (lib.size() == 1) {
        		AllZone.GameAction.drawCard(card.getController());
        	}
        	else
        	{
        		if (card.getController().equals(Constant.Player.Human))
        		{
	        		topTwo.add(lib.get(0));
	        		topTwo.add(lib.get(1));
	        		
	        		Object o = AllZone.Display.getChoiceOptional("Select card to put in hand: ", topTwo.toArray());
	        		
	        		Card c1 = (Card)o;
	        		topTwo.remove(c1);
	        		library.remove(c1);
	        		hand.add(c1);
	        		
	        		Card c2 = topTwo.get(0);
	        		library.remove(c2);
	        		library.add(c2);
        		}
        		else //computer
        		{
        			Card c1 = lib.get(0);
        			library.remove(c1);
        			lib.remove(c1);
        			hand.add(c1); 
        			
        			Card c2 = lib.get(0);
        			library.remove(c2);
        			lib.remove(c2);
        			library.add(c2); //put on bottom
        			
        		}
        		        		        		
        	}
        	
        }
      };
      
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      
  }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
  else if(cardName.equals("Brainstorm"))
  {
	  final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -5722651962081633839L;

		public void resolve()
        {
            AllZone.GameAction.drawCard(card.getController());
            AllZone.GameAction.drawCard(card.getController());
            AllZone.GameAction.drawCard(card.getController());
            
            String player = card.getController();
            if(player.equals(Constant.Player.Human))
              humanResolve();
            else
              computerResolve();
        }
        
        public void humanResolve()
        {
        	PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Human);
        	PlayerZone lib = AllZone.getZone(Constant.Zone.Library, Constant.Player.Human);
        	
        	CardList putOnTop = new CardList(hand.getCards());
        	
        	Object o = AllZone.Display.getChoiceOptional("First card to put on top: ", putOnTop.toArray());
        	if(o != null)
            {
        		Card c1 = (Card)o;
        		putOnTop.remove(c1);
        		hand.remove(c1);
        		lib.add(c1,0);
            }
        	o = AllZone.Display.getChoiceOptional("Second card to put on top: ", putOnTop.toArray());
        	if(o != null)
            {
        		Card c2 = (Card)o;
        		putOnTop.remove(c2);
        		hand.remove(c2);
        		lib.add(c2,0);
            }
        	
        }
        
        public void computerResolve()
        {
        	PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
        	PlayerZone lib = AllZone.getZone(Constant.Zone.Library, Constant.Player.Computer);
        	
        	CardList putOnTop = new CardList(hand.getCards());
        	
        	Card c1 = putOnTop.get(0);
        	putOnTop.remove(c1);
        	hand.remove(c1);
        	lib.add(c1, 0);
        	
        	Card c2 = putOnTop.get(0);
        	putOnTop.remove(c2);
        	hand.remove(c2);
        	lib.add(c2, 0);
        	//TODO: somehow find the least desirable cards at the moment, and put those on top
        }
        
        public boolean canPlay()
        {
        	PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
        	
        	if (lib.size() >= 2)
        		return true;
        	else
        		return false;
        }
        
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
	  
    
  }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Banishing Knack"))
    {
       SpellAbility spell = new Spell(card)
       {
		private static final long serialVersionUID = 6518824567946786581L;
		public boolean canPlayAI(){return false;}
          public void resolve()
          {
             final Card creature = getTargetCard();
             final Ability_Tap tBanish = new Ability_Tap(creature)
             {
				private static final long serialVersionUID = -1008113001678623984L;

				public boolean canPlayAI() {return false;}

                public void resolve()
                {
                   setStackDescription(creature+" - Return"+getTargetCard()+"to its owner's hand");
                   final Card[] target = new Card[1];
                   target[0] = getTargetCard();
                   PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, target[0].getOwner());

                   if(AllZone.GameAction.isCardInPlay(target[0])  && CardFactoryUtil.canTarget(creature, target[0]) )
                   {
                      AllZone.GameAction.moveTo(hand ,target[0]);
                   }
                }//resolve()
             };//tBanish;
             tBanish.setDescription("T: Return target nonland permanent to its owner's hand.");
             creature.addSpellAbility(tBanish);
             CardList all = new CardList();
             all.addAll(AllZone.Human_Play.getCards());
             all.addAll(AllZone.Computer_Play.getCards());
             all = all.filter(new CardListFilter()
             {
                public boolean addCard(Card c) {
                   return (!c.isLand() && CardFactoryUtil.canTarget(creature, c));
                }
             });
             tBanish.setBeforePayMana(CardFactoryUtil.input_targetSpecific(tBanish, all, "Return target nonland permanent to its owner's hand.", true));
             AllZone.EndOfTurn.addUntil(new Command(){
				private static final long serialVersionUID = -7819140065166374666L;

				public void execute(){
                   creature.removeSpellAbility(tBanish);
                }
             });
          }
       };//SpellAbility
       spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
       card.clearSpellAbility();
       card.addSpellAbility(spell);
       spell.setDescription("Until end of turn, target creature gains \"T: Return target nonland permanent to its owner's hand.\"");
       spell.setStackDescription("Target creature gains \"T: Return target nonland permanent to its owner's hand.\"");
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Cromat")){
	   
    //LibBounce Ability
    final Ability a1 = new Ability(card, "G U")
    {
      public boolean canPlayAI() {return false;}

      public void resolve()
      {
        if(AllZone.GameAction.isCardInPlay(card) )
        {
          card.setBaseAttack(5);
          card.setBaseDefense(5);

          card.setAssignedDamage(0);
          card.setDamage(0);
          card.untap();
          AllZone.getZone(card).remove(card);

          //put card on top of library
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getOwner());
          library.add(card, 0);
        }
      }//resolve()
    };//SpellAbility

    Input runtime1 = new Input()
    {
      private static final long serialVersionUID = 1469011418219527227L;

      public void showMessage()
      {
        a1.setStackDescription("Put " +card +" on top of its owner's library");

        stopSetNext(new Input_PayManaCost(a1));
      }
    };
    a1.setDescription("G U: Put Cromat on top of its owner's library.");
    a1.setStackDescription("Put Cromat on top of its owner's library.");
    card.addSpellAbility(a1);
    a1.setBeforePayMana(runtime1);
    //Kill ability
   
    final Ability a2 = new Ability(card, "W B"){
       public boolean canPlay()
       {
          return (AllZone.GameAction.isCardInPlay(card) && (AllZone.Combat.isBlocked(card) || AllZone.Combat.getAllBlockers().contains(card)));
       }
        public boolean canPlayAI()
        {
          return false;
          //TODO
        }
       public void resolve()
       {
          AllZone.GameAction.destroy(getTargetCard());
       }//resolve()
    };
    Input runtime2 = new Input()
    {
      private static final long serialVersionUID = 1L;

      public void showMessage()
       {
          CardList targets = new CardList();
          if(AllZone.Combat.isBlocked(card) || AllZone.Combat.getAllBlockers().contains(card)){
             if (AllZone.Combat.isBlocked(card)){ targets = AllZone.Combat.getBlockers(card); }
             else {
                targets = new CardList();
                for (Card c : AllZone.Combat.getAttackers()){
                   if (AllZone.Combat.isBlocked(c))
                      if (AllZone.Combat.getBlockers(c).contains(card)) targets.add(c);
                }
             }
          }
          stopSetNext(CardFactoryUtil.input_targetSpecific(a2, targets, "Select target blocking or blocked by Cromat.", true));
       }
    };
    card.addSpellAbility(a2);
    a2.setBeforePayMana(runtime2);
    a2.setDescription("W B: Destroy target creature blocking or blocked by Cromat.");
  }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Mutavault"))
    {
      final Command eot1 = new Command()
      {
      private static final long serialVersionUID = 5106629534549783845L;

      public void execute()
        {
          Card c = card;

          c.setBaseAttack(0);
          c.setBaseDefense(0);
          c.removeIntrinsicKeyword("Changeling");
          c.removeType("Creature");
        }
      };

      final SpellAbility a1 = new Ability(card, "1")
      {
        public boolean canPlayAI()
        {
          return false;
        }
        public void resolve()
        {
          Card c = card;

          c.setBaseAttack(2);
          c.setBaseDefense(2);

          //to prevent like duplication like "Changeling Changeling Creature Creature"
          if(! c.getIntrinsicKeyword().contains("Changeling"))
          {
            c.addIntrinsicKeyword("Changeling");
            c.addType("Creature");
          }
          AllZone.EndOfTurn.addUntil(eot1);
        }
      };//SpellAbility

      card.clearSpellAbility();
      card.addSpellAbility(a1);
      a1.setDescription("1: Mutavault becomes a 2/2 creature with all creature types until end of turn. It's still a land.");
      a1.setStackDescription(card +" becomes a 2/2 creature with changeling until EOT");

      Command paid1 = new Command() {
      private static final long serialVersionUID = -601119544294387668L;
      public void execute() {AllZone.Stack.add(a1);}
     };

      a1.setBeforePayMana(new Input_PayManaCost_Ability(a1.getManaCost(), paid1));
      
      //not sure what's going on here, maybe because it's a land it doesn't add the ability to the text?
	  //anyway, this does the trick:
	  card.removeIntrinsicKeyword("tap: add 1");
	  card.setText(card.getText() +  "\r\n1: Mutavault becomes a 2/2 creature with all creature types until end of turn. It's still a land.");
	  card.addIntrinsicKeyword("tap: add 1");

    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Dragon Blood"))
    {
       Ability_Tap ability = new Ability_Tap(card, "3")
       {
		private static final long serialVersionUID = -8095802059752537764L;
		public void resolve()
          {
             if(getTargetCard() != null && getTargetCard().isCreature() 
            		 && CardFactoryUtil.canTarget(card, getTargetCard()) )
                getTargetCard().addCounter(Counters.P1P1,1);
          }
          public boolean canPlayAI()
          {
             CardList list = new CardList(AllZone.Computer_Play.getCards());
             setTargetCard(CardFactoryUtil.AI_getBestCreature(list));
             return (getTargetCard() != null);
          }
       };
       ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
       ability.setDescription("3, T: Put a +1/+1 counter on target creature.");
       ability.setStackDescription(card+": put a +1/+1 counter on target Creature.");
       card.addSpellAbility(ability);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Reminisce"))
    {
      final SpellAbility spell = new Spell(card)
      {
      private static final long serialVersionUID = 505983020365091226L;
      
      public void resolve()
        {
          String player = getTargetPlayer();
          // Move graveyard into library
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, player);
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, player);
          Card[] g = grave.getCards();
          for (int i = 0; i < g.length; i++)
          {
            grave.remove(g[i]);
            library.add(g[i],0);
          }
          // Shuffle library
          AllZone.GameAction.shuffle(player);;
        }

        public boolean canPlayAI()//97% of the time shuffling your grave into your library is a good thing
        {
           setTargetPlayer(Constant.Player.Computer);
           return true;
        }

      };//SpellAbility
      spell.setBeforePayMana(CardFactoryUtil.input_targetPlayer(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Energizer"))
    {
       Ability_Tap ability = new Ability_Tap(card, "2")
       {
		private static final long serialVersionUID = 6444406158364728638L;
		public void resolve()
          {
             card.addCounter(Counters.P1P1,1);
          }
          public boolean canPlayAI()
          {
             return(true);
          }
       };
       ability.setDescription("2, T: Put a +1/+1 counter on Energizer.");
       ability.setStackDescription("Put a +1/+1 counter on target Energizer.");
       card.addSpellAbility(ability);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("AEther Vial"))
    {
    	//final int[] converted = null;
    	final Ability_Tap ability = new Ability_Tap(card, "0")
    	{
			private static final long serialVersionUID = 1854859213307704018L;

			public boolean canPlay()
    		{
    			return card.getCounters(Counters.CHARGE) > 0;
    		}
    	
			public void resolve() {
				String player = card.getController();
				
				PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, player);
				PlayerZone play = AllZone.getZone(Constant.Zone.Play, player);
				
				//converted[0] = card.getCounters(Counters.CHARGE);
				//System.out.println("converted: " + converted[0]);
				
				CardList list = new CardList(hand.getCards());
				list = list.filter(new CardListFilter()
				{
					public boolean addCard(Card c) {
						return CardUtil.getConvertedManaCost(c.getManaCost()) == card.getCounters(Counters.CHARGE) && c.isCreature();					
					}
				});
				
				
				if (list.size()>0)
				{
					if (player.equals(Constant.Player.Human))
					{
						Object o = AllZone.Display.getChoiceOptional("Pick creature to put into play", list.toArray());
						if (o!=null)
						{
							Card c = (Card)o;
							hand.remove(c);
							play.add(c);
						}
					}
					else
					{
						Card c = list.get(0);
						if(AllZone.GameAction.isCardInZone(c, hand)) {
							hand.remove(c);
							play.add(c);
						}
					}
				}
			}
    	};
    	
    	ability.setDescription("Tap: You may put a creature card with converted mana cost equal to the number of charge counters on AEther Vial from your hand into play.");
    	ability.setStackDescription(card.getName() + " - put creature card with converted mana cost equal to the number of charge counters into play.");
    	
    	card.addSpellAbility(ability);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("AEther Spellbomb"))
    {
       
      final Ability ability = new Ability(card, "U")
      {
       public boolean canPlay()
         {
            return AllZone.GameAction.isCardInPlay(card)&&!AllZone.Stack.getSourceCards().contains(card);
       }
       public boolean canPlayAI()
        {
    	  CardList humanPlay = new CardList(AllZone.Human_Play.getCards()); 
    	  if (humanPlay.size() > 0)
    		  setTargetCard(CardFactoryUtil.AI_getBestCreature(humanPlay));
          return ((AllZone.Computer_Hand.size() > 2)&&(getTargetCard() != null)) ;
        }
       public void resolve()
       {
          final Card[] target = new Card[1];
          target[0] = getTargetCard();
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, target[0].getOwner());

          if(AllZone.GameAction.isCardInPlay(target[0])  && CardFactoryUtil.canTarget(card, target[0]) )
          {
        	  if (!target[0].isToken())  
        		  AllZone.GameAction.moveTo(hand ,target[0]);
        	  else
        		  AllZone.getZone(target[0]).remove(target[0]);
          }
          AllZone.GameAction.sacrifice(getSourceCard());
       }//resolve()
      };//SpellAbility
      ability.setDescription("U, Sacrifice AEther Spellbomb: Return target creature to its owner's hand.");
      card.addSpellAbility(ability);
      ability.setBeforePayMana(CardFactoryUtil.input_targetCreature(ability));
    }
  //*************** START *********** START **************************
    if(cardName.equals("Lifespark Spellbomb"))
    {
    final SpellAbility ability = new Ability_Activated(card, "G")
    {
      private static final long serialVersionUID = -5744842090293912606L;
      public boolean canPlay()
       {
          return AllZone.GameAction.isCardInPlay(card)&&!AllZone.Stack.getSourceCards().contains(card);
         }
      public boolean canPlayAI()
      {
       CardList land = new CardList(AllZone.Computer_Play.getCards());
       land = land.getType("Land");
       CardList basic = land.getType("Basic");
       if (basic.size() < 3) return false;
       Card[] basic_1 = basic.toArray();
       for(Card var : basic_1)
          if (var.isTapped()) basic.remove(var);
        basic.shuffle();
        if (basic.size() == 0)
           return false;
        if (basic.get(0) != null) {
           setTargetCard(basic.get(0));
           return true;
        }
        return false;
      }//canPlayAI() 

     public void resolve()
        {
          //in case ability is played twice
          final int[] oldAttack = new int[1];
          final int[] oldDefense = new int[1];

          final Card card[] = new Card[1];
          card[0] = getTargetCard();

          oldAttack[0]  = card[0].getBaseAttack();
          oldDefense[0] = card[0].getBaseDefense();

          card[0].setBaseAttack(3);
          card[0].setBaseDefense(3);
          card[0].addType("Creature");

          //EOT
          final Command untilEOT = new Command()
          {
            private static final long serialVersionUID = 7236360479349324099L;

         public void execute()
            {
              card[0].setBaseAttack(oldAttack[0]);
              card[0].setBaseDefense(oldDefense[0]);

              card[0].removeType("Creature");
            }
          };

          AllZone.EndOfTurn.addUntil(untilEOT);
          AllZone.GameAction.sacrifice(getSourceCard());
        }//resolve()
      };//SpellAbility
      card.addSpellAbility(ability);
      ability.setDescription("G, Sacrifice Lifespark Spellbomb: Target land becomes a 3/3 Creature until end of turn. It is still a land.");
      ability.setBeforePayMana(CardFactoryUtil.input_targetType(ability, "Land"));
      
    }//*************** END ************ END **************************
   
  //*************** START *********** START **************************
    if(cardName.equals("Pyrite Spellbomb"))
    {

    final SpellAbility ability = new Ability_Activated(card, "R")
    {   
      private static final long serialVersionUID = 1L;

     public boolean canPlay()
      {
          return AllZone.GameAction.isCardInPlay(card)&&!AllZone.Stack.getSourceCards().contains(card);
      }
      public boolean canPlayAI()
      {
         Random r = new Random();
         if (r.nextFloat() <= Math.pow(.6667, card.getAbilityUsed()))
            return true;
         else
            return false;
      }
     
      public void chooseTargetAI()
      {
        CardList list = CardFactoryUtil.AI_getHumanCreature(2, card, true);
        list.shuffle();

        if(list.isEmpty() || AllZone.Human_Life.getLife() < 5 + 2)
          setTargetPlayer(Constant.Player.Human);
        else
          setTargetCard(list.get(0));
      }//chooseTargetAI
      public void resolve()
      {
        if(getTargetCard() != null)
        {
          if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()) )
            getTargetCard().addDamage(2);
        }
        else
          AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(2);
        AllZone.GameAction.sacrifice(getSourceCard());
      }//resolve()
     };//Ability_Activated
     
      ability.setBeforePayMana(CardFactoryUtil.input_targetCreaturePlayer(ability, true));
      ability.setDescription("R, Sacrifice Pyrite Spellbomb: Pyrite Spellbomb deals 2 damage to target creature or player.");
      card.addSpellAbility(ability);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Sunbeam Spellbomb"))
    {
      final Ability ability = new Ability(card, "W")
      {
       public boolean canPlay()
         {
            return AllZone.GameAction.isCardInPlay(card)&&!AllZone.Stack.getSourceCards().contains(card);
       }
       public boolean canPlayAI()
        {
          return (AllZone.GameAction.getPlayerLife(Constant.Player.Computer).getLife() < 7);
        }
        public void resolve()
        {
          AllZone.GameAction.getPlayerLife(card.getController()).addLife(5);
          AllZone.GameAction.sacrifice(getSourceCard());
        }//resolve()
      };//SpellAbility
      ability.setStackDescription("You gain 5 life");
      ability.setDescription("W, Sacrifice Sunbeam Spellbomb: You gain 5 life.");
      card.addSpellAbility(ability);
    } //*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Necrogen Spellbomb"))
    {
      final Ability ability = new Ability(card, "B")
      {
       public boolean canPlay()
         {
            return AllZone.GameAction.isCardInPlay(card)&&!AllZone.Stack.getSourceCards().contains(card);
       }
       public boolean canPlayAI()
        {
          setTargetPlayer(Constant.Player.Human);
          return (MyRandom.random.nextBoolean()&&AllZone.Human_Hand.size()>0);
        }
        public void resolve()
        {
          String s = getTargetPlayer();
          setStackDescription("Necrogen Spellbomb - " +s +" discards a card");
          if(Constant.Player.Computer.equals(getTargetPlayer()))
            AllZone.GameAction.discardRandom(getTargetPlayer());
          else
            AllZone.InputControl.setInput(CardFactoryUtil.input_discard());
          AllZone.GameAction.sacrifice(getSourceCard());
        }//resolve()
      };//SpellAbility
      ability.setDescription("B, Sacrifice Necrogen Spellbomb: Target player discards a card");
      ability.setBeforePayMana(CardFactoryUtil.input_targetPlayer(ability));
      card.addSpellAbility(ability);
    } //*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Sensei's Divining Top"))
    {
      //ability2: Draw card, and put divining top on top of library
      final SpellAbility ability2 = new Ability_Tap(card, "0")
      {
		private static final long serialVersionUID = -2523015092351744208L;

		public void resolve()
        {
          String player = card.getController();
          String owner = card.getOwner();
          
          PlayerZone play =  AllZone.getZone(Constant.Zone.Play, player);
          PlayerZone lib =  AllZone.getZone(Constant.Zone.Library, owner);
              
          AllZone.GameAction.drawCard(player);
          play.remove(card);
          lib.add(card,0); //move divining top to top of library
          card.untap();
      
        }

        public boolean canPlayAI()
        {
          return false;
        }

        public boolean canPlay()
        {
        	if (AllZone.getZone(card).is(Constant.Zone.Play))
          	  return true;
            else 
          	  return false;
        }//canPlay()
      };//SpellAbility ability2

      ability2.setBeforePayMana(new Input()
      {
		private static final long serialVersionUID = -4773496833654414458L;
		@SuppressWarnings("unused") // check
		int check = -1;
         public void showMessage()
         {
             AllZone.Stack.push(ability2);
             stop();
         }//showMessage()
      });

      

      //ability (rearrange top 3 cards) :
      final SpellAbility ability1 = new Ability(card, "1")
      {
        public void resolve()
        {
        	String player = card.getController();
        	PlayerZone lib =  AllZone.getZone(Constant.Zone.Library, player);
        	
        	if (lib.size() < 3)
        		return;
        	
        	CardList topThree = new CardList();
        	
        	//show top 3 cards:
        	topThree.add(lib.get(0));
        	topThree.add(lib.get(1));
        	topThree.add(lib.get(2));
        	
        	for (int i=1;i<=3;i++){
        		String Title = "Put on top: ";
        		if (i==2)
        			Title = "Put second from top: ";
        		if (i==3)
        			Title = "Put third from top: ";
        		Object o = AllZone.Display.getChoiceOptional(Title, topThree.toArray());
        		if(o == null)
        			break;
        		Card c_1 = (Card)o;
        		topThree.remove(c_1);
        		lib.remove(c_1);
        		lib.add(c_1,i-1);
        	}
        	
        }
        public boolean canPlayAI()
        {
           return false;
         
        }
        public boolean canPlay()
        {
          if (AllZone.getZone(card).is(Constant.Zone.Play))
        	  return true;
          else 
        	  return false;
        }//canPlay()
      };//SpellAbility ability1


      ability1.setDescription("1: Look at the top three cards of your library, then put them back in any order.");
      ability1.setStackDescription("Sensei's Divining Top - rearrange top 3 cards");
      card.addSpellAbility(ability1);
      ability1.setBeforePayMana(new Input_PayManaCost(ability1));

      ability2.setDescription("tap: Draw a card, then put Sensei's Divining Top on top of its owner's library.");
      ability2.setStackDescription("Sensei's Divining Top - draw a card, then put back on owner's library");
      ability2.setBeforePayMana(new Input_NoCost_TapAbility((Ability_Tap) ability2));
      card.addSpellAbility(ability2);

    }
    //*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Sphinx of Jwar Isle"))
    {
    	final SpellAbility ability1 = new Ability(card, "0")
        {
          public void resolve()
          {
		    	String player = card.getController();
		    	PlayerZone lib =  AllZone.getZone(Constant.Zone.Library, player);
		    	
		    	if (lib.size() < 1)
		    		return;
		    	
		    	CardList cl = new CardList();
		    	cl.add(lib.get(0));
		    	
		    	AllZone.Display.getChoiceOptional("Top card", cl.toArray());
          }
          public boolean canPlayAI()
          {
        	  return false;
          }
        };
        
        ability1.setStackDescription(card.getName() + " - look at top card of library.");
        ability1.setDescription("You may look at the top card of your library.");
        card.addSpellAbility(ability1);
    }
  //*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Imperial Recruiter"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          
          if(AllZone.GameAction.isCardInZone(getTargetCard(), lib))
          {
        	Card c = getTargetCard();
        	AllZone.GameAction.shuffle(card.getController());
        	lib.remove(c);
        	hand.add(c, 0);  	

          }
        }//resolve()
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = -8887306085997352723L;

		public void execute()
        {
          PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
          CardList cards = new CardList(lib.getCards());
          CardList powerTwoCreatures = new CardList();
          
          for (int i=0;i<cards.size();i++)
          {
        	  if(cards.get(i).getType().contains("Creature") && (cards.get(i).getNetAttack() <= 2))
        	  {
        		  powerTwoCreatures.add(cards.get(i));
        	  }
          }

          String controller = card.getController();

          if(powerTwoCreatures.size() == 0)
            return;

          if(controller.equals(Constant.Player.Human))
          {
            Object o = AllZone.Display.getChoiceOptional("Select target card", powerTwoCreatures.toArray());
            if(o != null)
            {
              ability.setTargetCard((Card)o);
              AllZone.Stack.add(ability);
            }
          }
          else //computer
          {
        	powerTwoCreatures.shuffle();
            ability.setTargetCard(powerTwoCreatures.get(0));
            AllZone.Stack.add(ability);
          }

        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    else if(cardName.equals("Maggot Carrier"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = card;
          PlayerLife life = AllZone.GameAction.getPlayerLife(c.getController());
          PlayerLife oppLife = AllZone.GameAction.getPlayerLife(AllZone.GameAction.getOpponent(c.getController()));
          life.subtractLife(1);
          oppLife.subtractLife(1);
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 685222802927427442L;

		public void execute()
        {
          ability.setStackDescription("Maggot Carrier - everyone loses 1 life.");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    else if(cardName.equals("Rathi Fiend"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = card;
          PlayerLife life = AllZone.GameAction.getPlayerLife(c.getController());
          PlayerLife oppLife = AllZone.GameAction.getPlayerLife(AllZone.GameAction.getOpponent(c.getController()));
          life.subtractLife(3);
          oppLife.subtractLife(3);
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 3362571791271852381L;

		public void execute()
        {
          ability.setStackDescription("Rathi Fiend - everyone loses 3 life.");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Dream Stalker"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = getTargetCard();
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, c.getOwner());

          if(AllZone.GameAction.isCardInPlay(c))
          {
            AllZone.getZone(c).remove(c);

            if(! c.isToken())
            {
              Card newCard = AllZone.CardFactory.getCard(c.getName(), c.getOwner());
              hand.add(newCard);
            }
          }
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 2045940121508110423L;

		public void execute()
        {
        	PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
        	CardList choice = new CardList(play.getCards());
        	AllZone.InputControl.setInput(CardFactoryUtil.input_targetSpecific(ability, choice, "Select a permanent you control.", false));
            ButtonUtil.disableAll();
          
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();
      card.addSpellAbility(new Spell_Permanent(card)
      {
        private static final long serialVersionUID = 4802059067438200061L;

		public boolean canPlayAI()
        {
          return false;
        }
      });
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Horned Kavu") || cardName.equals("Shivan Wurm"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = getTargetCard();
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, c.getOwner());

          if(AllZone.GameAction.isCardInPlay(c))
          {
            AllZone.getZone(c).remove(c);

            if(! c.isToken())
            {
              Card newCard = AllZone.CardFactory.getCard(c.getName(), c.getOwner());
              hand.add(newCard);
            }
          }
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 7530032969328799083L;

		public void execute()
        {
        	PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
        	
        	CardList creatures = new CardList(play.getCards());
        	creatures = creatures.getType("Creature");
        	
        	CardList redGreen = new CardList();
        	
        	
        	for(int i=0;i <creatures.size(); i++)
        	{
        		//if(!CardUtil.getColors(nonBlackCards.get(i)).contains(Constant.Color.Black))
        		if (CardUtil.getColors(creatures.get(i)).contains(Constant.Color.Red))
        		{
        			redGreen.add(creatures.get(i));
        		}
        		else if (CardUtil.getColors(creatures.get(i)).contains(Constant.Color.Green))
        		{
        			redGreen.add(creatures.get(i));
        		}
        	}
        	
        	//Object o = AllZone.Display.getChoiceOptional("Select a creature card to bounce", blackBlue.toArray());
        	
        	
        	AllZone.InputControl.setInput(CardFactoryUtil.input_targetSpecific(ability, redGreen, "Select a red or green creature you control.", false));
            ButtonUtil.disableAll();
          
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();

      card.addSpellAbility(new Spell_Permanent(card)
      {
        private static final long serialVersionUID = -517667816379595978L;

		public boolean canPlayAI()
        {
          return false;
        }
      });
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Fleetfoot Panther") || cardName.equals("Steel Leaf Paladin"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = getTargetCard();
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, c.getOwner());

          if(AllZone.GameAction.isCardInPlay(c))
          {
            AllZone.getZone(c).remove(c);

            if(! c.isToken())
            {
              Card newCard = AllZone.CardFactory.getCard(c.getName(), c.getOwner());
              hand.add(newCard);
            }
          }
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 6575359591031318957L;

		public void execute()
        {
        	PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
        	
        	CardList creatures = new CardList(play.getCards());
        	creatures = creatures.getType("Creature");
        	
        	CardList greenWhite = new CardList();
        	
        	
        	for(int i=0;i <creatures.size(); i++)
        	{
        		//if(!CardUtil.getColors(nonBlackCards.get(i)).contains(Constant.Color.Black))
        		if (CardUtil.getColors(creatures.get(i)).contains(Constant.Color.Green))
        		{
        			greenWhite.add(creatures.get(i));
        		}
        		else if (CardUtil.getColors(creatures.get(i)).contains(Constant.Color.White))
        		{
        			greenWhite.add(creatures.get(i));
        		}
        	}
        	
        	//Object o = AllZone.Display.getChoiceOptional("Select a creature card to bounce", blackBlue.toArray());
        	
        	
        	AllZone.InputControl.setInput(CardFactoryUtil.input_targetSpecific(ability, greenWhite, "Select a green or white creature you control.",false));
            ButtonUtil.disableAll();
          
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();

      card.addSpellAbility(new Spell_Permanent(card)
      {
        private static final long serialVersionUID = -1408300578781963711L;

		public boolean canPlayAI()
        {
          return false;
        }
      });
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Stonecloaker"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          
          Card c = getTargetCard();
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, c.getOwner());

          if(AllZone.GameAction.isCardInPlay(c))
          {
            AllZone.getZone(c).remove(c);

            if(! c.isToken())
            {
              Card newCard = AllZone.CardFactory.getCard(c.getName(), c.getOwner());
              hand.add(newCard);
            }
          }
        }
      };
      Command intoPlay = new Command()
      {
        private static final long serialVersionUID = -4018162972761688814L;

		public void execute()
        {
        	PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, AllZone.GameAction.getOpponent(card.getController()));
            CardList gravecards = new CardList(grave.getCards());
                  
            //System.out.println("size of grave: " + gravecards.size());
            
            if (gravecards.size() > 0)
            {
              if (card.getController().equals("Human"))
              {
	          	  Object o = AllZone.Display.getChoiceOptional("Select a card in opponent's graveyard to remove", gravecards.toArray());
	          	  if (o!=null)
	          	  {
	          		  Card removedCard = (Card)o;        		  
	          		  AllZone.GameAction.removeFromGame(removedCard);
	          	  }
              }
              else
              {
            	  AllZone.GameAction.removeFromGame(gravecards.get(0));
              }
            }
            
        	PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
        	
        	CardList creatures = new CardList(play.getCards());
        	creatures = creatures.getType("Creature");
        	
        	//Object o = AllZone.Display.getChoiceOptional("Select a creature card to bounce", blackBlue.toArray());
        	
        	
        	AllZone.InputControl.setInput(CardFactoryUtil.input_targetSpecific(ability, creatures, "Select a creature you control.", false));
            ButtonUtil.disableAll();
          
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();

      card.addSpellAbility(new Spell_Permanent(card)
      {
        private static final long serialVersionUID = 3089921616375272120L;

		public boolean canPlayAI()
        {
          return false;
        }
      });
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Cavern Harpy"))
    {
      final SpellAbility a1 = new Ability(card,"0")
      {
    	  public void resolve()
          {
    		  PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
    		  life.subtractLife(1);
    		  PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getOwner());
    		  
    		  if (card.isToken())
    			  AllZone.getZone(card).remove(card);
    		  else
    			  AllZone.GameAction.moveTo(hand, card);
    		  
    		  
          }
    	  public boolean canPlayAI()
    	  {
    		  return false;
    	  }
      };
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = getTargetCard();
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, c.getOwner());

          if(AllZone.GameAction.isCardInPlay(c))
          {
            AllZone.getZone(c).remove(c);

            if(! c.isToken())
            {
              Card newCard = AllZone.CardFactory.getCard(c.getName(), c.getOwner());
              hand.add(newCard);
            }
          }
        }
      };
      Command intoPlay = new Command()
      {
        private static final long serialVersionUID = -7855081477395863590L;

		public void execute()
        {
        	PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
        	
        	CardList creatures = new CardList(play.getCards());
        	creatures = creatures.getType("Creature");
        	
        	CardList blackBlue = new CardList();
        	
        	
        	for(int i=0;i <creatures.size(); i++)
        	{
        		//if(!CardUtil.getColors(nonBlackCards.get(i)).contains(Constant.Color.Black))
        		if (CardUtil.getColors(creatures.get(i)).contains(Constant.Color.Black))
        		{
        			blackBlue.add(creatures.get(i));
        		}
        		else if (CardUtil.getColors(creatures.get(i)).contains(Constant.Color.Blue))
        		{
        			blackBlue.add(creatures.get(i));
        		}
        	}
        	
        	//Object o = AllZone.Display.getChoiceOptional("Select a creature card to bounce", blackBlue.toArray());
        	
        	
        	AllZone.InputControl.setInput(CardFactoryUtil.input_targetSpecific(ability, blackBlue, "Select blue or black creature you control.", false));
            ButtonUtil.disableAll();
          
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();
     
      card.addSpellAbility(new Spell_Permanent(card)
      {
        private static final long serialVersionUID = -6750896183003809261L;

		public boolean canPlayAI()
        {
          return false;
        }
      });
      
      card.addSpellAbility(a1);
      a1.setStackDescription(card.getController() + " pays 1 life and returns Cavern Harpy back to owner's hand.");
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Vampiric Tutor") || cardName.equals("Cruel Tutor") || cardName.equals("Imperial Seal"))
    {
      SpellAbility spell = new Spell(card)
      {
        private static final long serialVersionUID = 8922434714488681861L;
		public boolean canPlayAI()
        {
        	PlayerLife compLife = AllZone.GameAction.getPlayerLife("Computer");
        	int life = compLife.getLife();
        	if (4 < AllZone.Phase.getTurn() && AllZone.Computer_Library.size() > 0 && life >= 4)
        		return true;
        	else 
        		return false;
        }

        public void resolve()
        {
          String player = card.getController();
          if(player.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void computerResolve()
        {
        	//TODO: somehow select a good non-creature card for AI
          CardList creature = new CardList(AllZone.Computer_Library.getCards());
          creature = creature.getType("Creature");
          if(creature.size() != 0)
          {
        	Card c = CardFactoryUtil.AI_getBestCreature(creature);
 
         	if(c == null)
            {
         		creature.shuffle();
                c = creature.get(0);
            }
            
            AllZone.GameAction.shuffle(card.getController());

            //move to top of library
            AllZone.Computer_Library.remove(c);
            AllZone.Computer_Library.add(c, 0);
            
            //lose 2 life
            String player = Constant.Player.Computer;
            PlayerLife life = AllZone.GameAction.getPlayerLife(player);
            life.subtractLife(2);
          }
        }//computerResolve()
        public void humanResolve()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());

          CardList list = new CardList(library.getCards());

          if(list.size() != 0)
          {
            Object o = AllZone.Display.getChoiceOptional("Select a card", list.toArray());

            AllZone.GameAction.shuffle(card.getController());
            if(o != null)
            {
              //put card on top of library
              library.remove(o);
              library.add((Card)o, 0);
            }
            //lose 2 life
            String player = Constant.Player.Human;
            PlayerLife life = AllZone.GameAction.getPlayerLife(player);
            life.subtractLife(2);
          }//if
         
          
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Nemata, Grove Guardian"))
    {
      final SpellAbility a1 = new Ability(card, "2 G")
      {
    	public boolean canPlayAI()
    	{
    		return MyRandom.random.nextBoolean();
    	}
    	public boolean canPlay()
    	{
    		SpellAbility sa;
            //this is a hack, check the stack to see if this card has an ability on the stack
            //if so, we can't use the ability
            for (int i=0; i<AllZone.Stack.size(); i++)
            {
            	sa = AllZone.Stack.peek(i);
            	if (sa.getSourceCard().equals(card))
            			return false;
            }
            return AllZone.GameAction.isCardInPlay(card);
    		
    	}
        public void resolve()
        {
          makeToken();
        }
        void makeToken()
        {
          Card c = new Card();

          
          c.setName("Saproling");
          c.setImageName("G 1 1 Saproling");

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setManaCost("G");
          c.setToken(true);
         
          c.addType("Creature");
          c.addType("Saproling");
          c.setBaseAttack(1);
          c.setBaseDefense(1);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//makeToken()
      };//SpellAbility
      
      final SpellAbility a2 = new Ability(card, "0")
      {
        final Command eot1 = new Command()
        {
		  private static final long serialVersionUID = -389286901477839863L;

		  public void execute()
          {
        	CardList saps = new CardList();
        	saps.addAll(AllZone.Human_Play.getCards());
        	saps.addAll(AllZone.Computer_Play.getCards());

            saps = saps.getType("Saproling");
        	
        	for (int i=0; i < saps.size(); i++)
            {
        		Card sap = saps.get(i);
        		     		
                sap.addTempAttackBoost(-1);
                sap.addTempDefenseBoost(-1);
            }
        	
          }
        };
        public void resolve()
        {
          //get all saprolings:
          
          CardList saps = new CardList();
          saps.addAll(AllZone.Human_Play.getCards());
          saps.addAll(AllZone.Computer_Play.getCards());

          saps = saps.getType("Saproling");
        	
          Card c = getTargetCard();

          if(AllZone.GameAction.isCardInPlay(c))
          {
            //AllZone.getZone(c).remove(c);
        	AllZone.GameAction.sacrifice(c);
        	  
            for (int i=0; i < saps.size(); i++)
            {
            	Card sap = saps.get(i);
            	
            	sap.addTempAttackBoost(1);
                sap.addTempDefenseBoost(1);          	
            }
            
          }
          else
        	  return;
          
          AllZone.EndOfTurn.addUntil(eot1);
        }
        public boolean canPlayAI()
        {
          return false;
        }
      };//SpellAbility
      
      Input runtime = new Input()
      {
		private static final long serialVersionUID = -8827919636559042903L;

		public void showMessage()
        {
          CardList saps = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
          saps = saps.getType("Saproling");
          
          stopSetNext(CardFactoryUtil.input_targetSpecific(a2, saps, "Select a Saproling to sacrifice.",false));
        }
      };
      a1.setDescription("2G: Put a 1/1 green Saproling creature token into play.");
      a1.setStackDescription("Put a 1/1 Saproling into play.");
      card.addSpellAbility(a1);
      a1.setBeforePayMana(new Input_PayManaCost(a1));
      
      card.addSpellAbility(a2);
      a2.setDescription("Sacrifice a Saproling: Saproling creatures get +1/+1 until end of turn");
      a2.setStackDescription("Saprolings get +1/+1 until end of turn.");

      a2.setBeforePayMana(runtime);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Fallen Angel"))
    {
      
      final SpellAbility a2 = new Ability(card, "0")
      {
        final Command eot1 = new Command()
        {
          private static final long serialVersionUID = 8955432114774252848L;

		public void execute()
          {
                card.addTempAttackBoost(-2);
                card.addTempDefenseBoost(-1);	
          }
        };
        public void resolve()
        {
       	
          Card c = getTargetCard();

          if(AllZone.GameAction.isCardInPlay(c))
          {
            //AllZone.getZone(c).remove(c);
        	AllZone.GameAction.sacrifice(c);
            
        	if(AllZone.GameAction.isCardInPlay(card)) 
        	{
        		card.addTempAttackBoost(2);
        		card.addTempDefenseBoost(1);
        	}
          }
          AllZone.EndOfTurn.addUntil(eot1);
        }
        public boolean canPlayAI()
        {
          return false;
        }
        public boolean canPlay()
        {
        	SpellAbility sa;
            //this is a hack, check the stack to see if this card has an ability on the stack
            //if so, we can't use the ability: this is to prevent using a limited ability too many times
            for (int i=0; i<AllZone.Stack.size(); i++)
            {
            	sa = AllZone.Stack.peek(i);
            	if (sa.getSourceCard().equals(card))
            			return false;
            }
            if (super.canPlay())
            	return true;
            return false;
        }
      };//SpellAbility
      
      Input runtime = new Input()
      {
        private static final long serialVersionUID = -5917074526767992913L;

		public void showMessage()
        {
          CardList creats = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
          creats = creats.getType("Creature");
          
          stopSetNext(CardFactoryUtil.input_targetSpecific(a2, creats, "Select a creature to sacrifice.",false));
        }
      };

      card.addSpellAbility(a2);
      a2.setDescription("Sacrifice a creature: Fallen Angel gets +2/+1 until end of turn.");
      a2.setStackDescription("Fallen Angel gets +2/+1 until end of turn.");

      a2.setBeforePayMana(runtime);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Nantuko Husk") || cardName.equals("Phyrexian Ghoul"))
    {
      
      final SpellAbility a2 = new Ability(card, "0")
      {
        final Command eot1 = new Command()
        {
          private static final long serialVersionUID = 4450272080079173250L;

		public void execute()
          {
                card.addTempAttackBoost(-2);
                card.addTempDefenseBoost(-2);	
          }
        };
        public void resolve()
        {
       	
          Card c = getTargetCard();

          if(AllZone.GameAction.isCardInPlay(c))
          {
            //AllZone.getZone(c).remove(c);
        	AllZone.GameAction.sacrifice(c);
            
        	if(AllZone.GameAction.isCardInPlay(card)) 
        	{
        		card.addTempAttackBoost(2);
        		card.addTempDefenseBoost(2);
        	}
          }
          AllZone.EndOfTurn.addUntil(eot1);
        }
        public boolean canPlayAI()
        {
          return false;
        }
        public boolean canPlay()
        {
        	SpellAbility sa;
            //this is a hack, check the stack to see if this card has an ability on the stack
            //if so, we can't use the ability: this is to prevent using a limited ability too many times
            for (int i=0; i<AllZone.Stack.size(); i++)
            {
            	sa = AllZone.Stack.peek(i);
            	if (sa.getSourceCard().equals(card))
            			return false;
            }
            if (super.canPlay())
            	return true;
            return false;
        }
      };//SpellAbility
      
      Input runtime = new Input()
      {
        private static final long serialVersionUID = 8445133749305465286L;

		public void showMessage()
        {
          CardList creats = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
          creats = creats.getType("Creature");
          
          stopSetNext(CardFactoryUtil.input_targetSpecific(a2, creats, "Select a creature to sacrifice.",false));
        }
      };

      card.addSpellAbility(a2);
      a2.setDescription("Sacrifice a creature: " +card.getName() +" gets +2/+2 until end of turn.");
      a2.setStackDescription(card.getName() + " gets +2/+2 until end of turn.");

      a2.setBeforePayMana(runtime);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    else if (cardName.equals("Cateran Overlord"))
    {
    
    	final SpellAbility a2 = new Ability(card, "0")
        {
          final Command eot1 = new Command()
          {
			private static final long serialVersionUID = -494422681034894502L;

			public void execute()
            {
            	card.setShield(0);
            }
          };
          public void resolve()
          {
        	
            Card c = getTargetCard();
            @SuppressWarnings("unused") // hand
			PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, c.getOwner());

            if(AllZone.GameAction.isCardInPlay(c))
            {
              //AllZone.getZone(c).remove(c);
            	AllZone.GameAction.sacrifice(c);
          	  
            	card.addShield();
             
              
            }
            AllZone.EndOfTurn.addUntil(eot1);
          }
          public boolean canPlayAI()
          {
        	  return false;
          }
               
        };//SpellAbility
        
        Input runtime = new Input()
        {
		  private static final long serialVersionUID = -8675314608938902218L;

		  public void showMessage()
          {
            CardList creats = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
            creats = creats.getType("Creature");
            
            stopSetNext(CardFactoryUtil.input_targetSpecific(a2, creats, "Select a creature to sacrifice.",false));
          }
        };
    	
    	card.addSpellAbility(a2);
        a2.setDescription("Sacrifice a creature: Regenerate Cateran Overlord");
        a2.setStackDescription("Regenerate Cateran Overlord");

        a2.setBeforePayMana(runtime);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Counterbalance"))
    {
      String player = card.getController();
      final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
        	PlayerZone lib =  AllZone.getZone(Constant.Zone.Library, card.getController());
        	
        	Card topCard = lib.get(0);     	
        	
        	SpellAbility sa = AllZone.Stack.peek();
        	
        	
            int convertedManaTopCard = CardUtil.getConvertedManaCost(topCard.getManaCost());
            int convertedManaSpell = CardUtil.getConvertedManaCost(sa.getSourceCard().getManaCost());
            
            CardList showTop = new CardList();
            showTop.add(topCard);
            AllZone.Display.getChoiceOptional("Revealed top card: ", showTop.toArray());
            
            if (convertedManaTopCard == convertedManaSpell)
            {
            	
            	AllZone.Stack.pop();
            	AllZone.GameAction.moveToGraveyard(sa.getSourceCard());
            }
        }
        public boolean canPlayAI()
        {
           return false;
         
        }
        public boolean canPlay()
        {
        	String player = card.getController();
        	PlayerZone lib =  AllZone.getZone(Constant.Zone.Library, player);
        	
        	if(AllZone.Stack.size() == 0 || lib.size() == 0)
                return false;

            //see if spell is on stack and that opponent played it
            String opponent = AllZone.GameAction.getOpponent(card.getController());
            SpellAbility sa = AllZone.Stack.peek();
             
            if (AllZone.getZone(card).is(Constant.Zone.Play) && sa.isSpell() && opponent.equals(sa.getSourceCard().getController())
            	&& CardFactoryUtil.isCounterable(sa.getSourceCard()))
              return true;
            else 
              return false;
        }//canPlay()
      };//SpellAbility ability
      
      ability.setStackDescription("Counterbalance - "+player +" reveals top card and counters spell if it has the same converted manacost");
      ability.setBeforePayMana(new Input_PayManaCost(ability));
      card.addSpellAbility(ability);
      

    }
    //*************** END ************ END **************************
    
    //*************** START *********** START **************************
    else if(cardName.equals("Aluren"))
    {
      final Ability ability1 = new Ability(card, "0")
      {
        public void resolve()
        {
        	
        	//String player = card.getController();
        	PlayerZone hand =  AllZone.getZone(Constant.Zone.Hand, Constant.Player.Human);
        	PlayerZone play =  AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
        	
        	if (hand.size() == 0)
        		return;
        	
        	CardList creatures = new CardList();
        	
        	for (int i=0;i < hand.size(); i++)
        	{
        		if (hand.get(i).getType().contains("Creature") && CardUtil.getConvertedManaCost(hand.get(i).getManaCost()) <= 3)
        			creatures.add(hand.get(i));
        	}
        	
        	if(creatures.size() == 0)
                return;

            
            Object o = AllZone.Display.getChoiceOptional("Select target creature to play", creatures.toArray());
            if(o != null)
            {
            	Card c = (Card)o;
            	hand.remove(c);
            	play.add(c);
            	c.setSickness(true);
            }
           
        	
        	
        }
        public boolean canPlayAI()
        {
           return false;
         
        }
        public boolean canPlay()
        {
          if (AllZone.getZone(card).is(Constant.Zone.Play))
        	  return true;
          else 
        	  return false;
        }//canPlay()
      };//SpellAbility ability1


      ability1.setDescription("Any player may play creature cards with converted mana cost 3 or less without paying their mana cost any time he or she could play an instant.");
      ability1.setStackDescription("Aluren - Play creature with converted manacost 3 or less for free.");
      card.addSpellAbility(ability1);
      ability1.setBeforePayMana(new Input_PayManaCost(ability1));      

    }
    //*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Viridian Shaman") || cardName.equals("Uktabi Orangutan") || cardName.equals("Vithian Renegades"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
         public void resolve()
        {
          Card c = getTargetCard();
          @SuppressWarnings("unused") // graveyard
		  PlayerZone graveyard = AllZone.getZone(Constant.Zone.Graveyard, c.getOwner());

          if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
        	if(c.isToken())
        		AllZone.getZone(c).remove(c);

        	else 
              AllZone.GameAction.destroy(c);
          }
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 7530032969328799083L;

		public void execute()
        {
        	CardList all = new CardList();
        	all.addAll(AllZone.Human_Play.getCards());
        	all.addAll(AllZone.Computer_Play.getCards());
        	all = all.getType("Artifact");
        	
        	
        	if (all.size() != 0) {
        		
        		if(card.getController().equals(Constant.Player.Human)) {
        			AllZone.InputControl.setInput(CardFactoryUtil.input_targetSpecific(ability, all, "Select target artifact.", true));
        			ButtonUtil.disableAll();
        		}
        		else if (card.getController().equals(Constant.Player.Computer)) {
        			Card human = CardFactoryUtil.AI_getBestArtifact(all);
        			ability.setTargetCard(human);
        			AllZone.Stack.add(ability);
        		}
        	}
          
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();

      card.addSpellAbility(new Spell_Permanent(card)
      {
		private static final long serialVersionUID = -517667816379595978L;

		public boolean canPlayAI()
        {
        	CardList artifacts = new CardList();
        	artifacts.addAll(AllZone.Human_Play.getCards());
        	artifacts = artifacts.getType("Artifact");
        	
        	if (artifacts.size() > 0)
        		return true;
        	else 
        		return false;    	
        }
      });
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Aven Cloudchaser") || cardName.equals("Cloudchaser Eagle") || cardName.equals("Monk Realist"))
    {
      final SpellAbility ability = new Ability(card, "0")
      {
         public void resolve()
        {
          Card c = getTargetCard();

          if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, getTargetCard()) )
          {
        	if(c.isToken())
        		AllZone.getZone(c).remove(c);

        	else 
              AllZone.GameAction.destroy(c);
          }
        }
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 8586704292133752803L;

		public void execute()
        {
        	CardList all = new CardList();
        	all.addAll(AllZone.Human_Play.getCards());
        	all.addAll(AllZone.Computer_Play.getCards());
        	all = all.getType("Enchantment");
        	
        	
        	if (all.size() != 0) {
        		
        		if(card.getController().equals(Constant.Player.Human)) {
        			AllZone.InputControl.setInput(CardFactoryUtil.input_targetSpecific(ability, all, "Select target enchantment.", true));
        			ButtonUtil.disableAll();
        		}
        		else if (card.getController().equals(Constant.Player.Computer)) {
        			Card human = CardFactoryUtil.AI_getBestEnchantment(all, card, true);
        			ability.setTargetCard(human);
        			AllZone.Stack.add(ability);
        		}
        	}
          
        }//execute()
      };//Command
      card.addComesIntoPlayCommand(intoPlay);

      card.clearSpellAbility();

      card.addSpellAbility(new Spell_Permanent(card)
      {
        private static final long serialVersionUID = -8467111038318551304L;

		public boolean canPlayAI()
        {
        	CardList ench = new CardList();
        	ench.addAll(AllZone.Human_Play.getCards());
        	ench = ench.getType("Enchantment");
        	
        	if (ench.size() > 0)
        		return true;
        	else 
        		return false;    	
        }
      });
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Intuition"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 8282597086298330698L;
		
		public void resolve()
        {
          String player = card.getController();
          if(player.equals(Constant.Player.Human))
            humanResolve();
          else
            computerResolve();
        }
        public void humanResolve()
        {
          CardList libraryList = new CardList(AllZone.Human_Library.getCards());
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          CardList selectedCards = new CardList();
        	
          Object o = AllZone.Display.getChoiceOptional("Select first card", libraryList.toArray());
          if(o != null)
          {
        	Card c1 = (Card)o;
        	libraryList.remove(c1);
        	selectedCards.add(c1);
          }
          else {
        	  return;
          }
          o = AllZone.Display.getChoiceOptional("Select second card", libraryList.toArray());
          if(o != null)
          {
        	Card c2 = (Card)o;
        	libraryList.remove(c2);
        	selectedCards.add(c2);
          }
          else {
        	  return;
          }
          o = AllZone.Display.getChoiceOptional("Select third card", libraryList.toArray());
          if(o != null)
          {
        	Card c3 = (Card)o;
        	libraryList.remove(c3);
        	selectedCards.add(c3);
          }
          else {
        	  return;
          }
          
          Card choice = selectedCards.get(MyRandom.random.nextInt(2)); //comp randomly selects one of the three cards
                    
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
          PlayerZone grave = AllZone.getZone(Constant.Zone.Graveyard, card.getController());
          library.remove(choice);
          hand.add(choice);
          
          selectedCards.remove(choice);
          Card toGrave1 = selectedCards.get(0);
          Card toGrave2 = selectedCards.get(1);
          library.remove(toGrave1);
          library.remove(toGrave2);
          selectedCards.remove(toGrave2);
          selectedCards.remove(toGrave2);
          
          grave.add(toGrave1);
          grave.add(toGrave2);
          
          AllZone.GameAction.shuffle(Constant.Player.Human);
        }
        public void computerResolve()
        {
          Card[] library = AllZone.Computer_Library.getCards();
          CardList list = new CardList(library);
          CardList selectedCards = new CardList();

          //pick best creature
          Card c = CardFactoryUtil.AI_getBestCreature(list);
          if(c == null) {
            c = library[0];
          }
          list.remove(c);
          selectedCards.add(c);
          
          c = CardFactoryUtil.AI_getBestCreature(list);
          if(c == null) {
            c = library[0];
          }
          list.remove(c);
          selectedCards.add(c);
          
          c = CardFactoryUtil.AI_getBestCreature(list);
          if(c == null) {
            c = library[0];
          }
          list.remove(c);
          selectedCards.add(c);
          
          Object o = AllZone.Display.getChoiceOptional("Select card to give to computer", selectedCards.toArray());
          
          Card choice = (Card)o;
          
          selectedCards.remove(choice);
          AllZone.Computer_Library.remove(choice);
          AllZone.Computer_Hand.add(choice);
          
          AllZone.Computer_Library.remove(selectedCards.get(0));
          AllZone.Computer_Library.remove(selectedCards.get(1));   
          
          AllZone.Computer_Graveyard.add(selectedCards.get(0));
          AllZone.Computer_Graveyard.add(selectedCards.get(1));
          
        }
        public boolean canPlay()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          return library.getCards().length >= 3;
        }
        public boolean canPlayAI()
        {
          CardList creature = new CardList();
          creature.addAll(AllZone.Computer_Library.getCards());
          creature = creature.getType("Creature");
          return creature.size() != 0;
        }
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    else if(cardName.equals("Rakka Mar"))
    {
      final SpellAbility a1 = new Ability_Tap(card, "R")
      {
		private static final long serialVersionUID = -3868544882464692305L;
		
		public boolean canPlayAI()
    	{
    		return true;
    				
    	}
        public void resolve()
        {
          makeToken();
        }
        void makeToken()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Elemental");
          c.setImageName("R 3 1 Elemental");
          c.setManaCost("R");
          c.setToken(true);
          
          c.addType("Creature");
          c.addType("Elemental");
          c.setBaseAttack(3);
          c.setBaseDefense(1);
          c.addIntrinsicKeyword("Haste");

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//makeToken()
      };//SpellAbility
      card.addSpellAbility(a1);
      a1.setDescription("R, T: Put a 3/1 red Elemental creature token with haste into play.");
      a1.setStackDescription("Put a 3/1 red Elemental creature token with haste into play.");

      a1.setBeforePayMana(new Input_PayManaCost(a1));
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Tolsimir Wolfblood"))
    {
      final SpellAbility a1 = new Ability_Tap(card)
      {
		private static final long serialVersionUID = -1900858280382389010L;
		
		public boolean canPlayAI()
    	{
    		String controller = card.getController();
    		
    		PlayerZone play = AllZone.getZone(Constant.Zone.Play, controller);
    		CardList voja = new CardList(play.getCards());
    		voja = voja.getName("Voja");
    		
    		if (voja.size() == 0)
    			return true;
    		else
    			return false;
    				
    	}
        public void resolve()
        {
          makeToken();
        }
        void makeToken()
        {
          Card c = new Card();

          c.setName("Voja");

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setManaCost("W G");
          c.setToken(true);
          
          c.addType("Legendary");
          c.addType("Creature");
          c.addType("Wolf");
          c.setBaseAttack(2);
          c.setBaseDefense(2);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//makeToken()
      };//SpellAbility
      card.addSpellAbility(a1);
      a1.setDescription("T: Put a legendary 2/2 green and white Wolf creature token named Voja into play.");
      a1.setStackDescription("Put a 2/2 white green Legendary Wolf creature token named Voja into play.");

      a1.setBeforePayMana(new Input_PayManaCost(a1));
    }//*************** END ************ END **************************
   
  //*************** START *********** START **************************
    else if(cardName.equals("Invincible Hymn"))
    {	
    	final String player = card.getController();

    	final SpellAbility spell = new Spell(card)
        {
		  private static final long serialVersionUID = -827136493013927725L;
		  
		  public void resolve()
          {
        	  PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
        	  CardList libCards = new CardList(library.getCards());
          	  int lifeGain = libCards.size();	    	   	
          	  
          	  System.out.println("lifeGain: " + lifeGain);
          	
        	  PlayerLife life = AllZone.GameAction.getPlayerLife(player);
        	  life.setLife(lifeGain);
        	  
        	  System.out.println("life.getLife(): " + life.getLife());
          }
          public boolean canPlayAI()
          {
        	  PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
        	  CardList libCards = new CardList(library.getCards());
          	  int lifeGain = libCards.size();	    	   	
          	  
        	  PlayerLife compLife = AllZone.GameAction.getPlayerLife(Constant.Player.Computer);
        	  if (lifeGain > compLife.getLife())
        		  return true;
        	  else
        		  return false;
          }
        };//spell
        card.clearSpellAbility();
        card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    if (cardName.equals("Ranger of Eos"))
    {
  	  final SpellAbility ability = new Ability(card, "0")
        {
          public void resolve()
          {
        	  PlayerZone lib = AllZone.getZone(Constant.Zone.Library, card.getController());
              PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
                     
        	  
              CardList cards = new CardList(lib.getCards());
              CardList oneCostCreatures = new CardList();
              
              for (int i=0;i<cards.size();i++)
              {
            	  if(cards.get(i).getType().contains("Creature") && (CardUtil.getConvertedManaCost(cards.get(i).getManaCost()) <= 1))
            	  {
            		  oneCostCreatures.add(cards.get(i));
            	  }
              }

              String controller = card.getController();

              if(oneCostCreatures.size() == 0)
                return;

              if(controller.equals(Constant.Player.Human))
              {
                Object o = AllZone.Display.getChoiceOptional("Select First Creature", oneCostCreatures.toArray());
                if(o != null)
                {
                  //ability.setTargetCard((Card)o);
                  //AllZone.Stack.add(ability);
                  Card c1 = (Card)o;
                  lib.remove(c1);
                  hand.add(c1);
                  oneCostCreatures.remove(c1);
                  
                  if(oneCostCreatures.size() == 0)
                      return;
                  
                  o = AllZone.Display.getChoiceOptional("Select Second Creature", oneCostCreatures.toArray());
                  
                  if(o != null)
                  {
                	  Card c2 = (Card)o;
                      lib.remove(c2);
                      hand.add(c2);
                      
                      oneCostCreatures.remove(c2);
                  }
                }
                AllZone.GameAction.shuffle(controller);
              }
              else //computer
              {
  	          	oneCostCreatures.shuffle();
  	          	if (oneCostCreatures.size() >= 1)
  	          	{
  	          		Card c1 = oneCostCreatures.getCard(0);
  	          		lib.remove(c1);
  	          		hand.add(c1);
  	          		oneCostCreatures.remove(c1);
  	          		
  	          		if (oneCostCreatures.size() >= 1)
  	          		{
  	          			Card c2 = oneCostCreatures.getCard(0);
  	              		lib.remove(c2);
  	              		hand.add(c2);
  	              		oneCostCreatures.remove(c2);
  	          		
  	          		}
  	          		
  	          		
  	          	}
                //ability.setTargetCard(powerTwoCreatures.get(0));
                //AllZone.Stack.add(ability);
  	          	AllZone.GameAction.shuffle(controller);
              }
            
                   
            //...
          	
          }//resolve()
        };
        Command intoPlay = new Command()
        {
		  private static final long serialVersionUID = -5697680711324878027L;

		  public void execute()
          {
        	  ability.setStackDescription("Ranger of Eos - Grab 2 creatures");
        	  AllZone.Stack.add(ability);
          }//execute()
        };//Command
        //ability.setStackDescription("Ranger of Eos - Grab 2 creatures");
        //AllZone.Stack.add(ability);
        card.addComesIntoPlayCommand(intoPlay);
  	  
  	  
             
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    else if(cardName.equals("Scarblade Elite"))
    {
    	final Ability_Tap ability = new Ability_Tap(card)
        {
		  private static final long serialVersionUID = 3505019464802566898L;
		
		  public boolean canPlay()
          {
        	  String controller = card.getController();
        	  PlayerZone graveyard = AllZone.getZone(Constant.Zone.Graveyard ,controller);
        	  
        	  CardList sins = new CardList(graveyard.getCards());
        	  sins = sins.getType("Assassin");
        	  
        	  if (sins.size() > 0 && AllZone.GameAction.isCardInPlay(card) && CardFactoryUtil.canTarget(card, getTargetCard()) )
        		  return true;
        	  else 
        		  return false;
        	  
          }
          public boolean canPlayAI()
          {
            CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
            human = human.filter(new CardListFilter()
            {
              public boolean addCard(Card c) {return AllZone.GameAction.isCardInPlay(c);}
            });

            CardListUtil.sortAttack(human);
            CardListUtil.sortFlying(human);

            //if(0 < human.size())
            //  setTargetCard(human.get(0));
            
            PlayerZone graveyard = AllZone.getZone(Constant.Zone.Graveyard, Constant.Player.Computer);
            
            CardList grave = new CardList(graveyard.getCards());
            grave = grave.getType("Assassin");
            
            if (human.size() > 0 && grave.size() > 0)
            	setTargetCard(human.get(0));
            
            return 0 < human.size() && 0 < grave.size();
          }

          public void resolve()
          {
        	String controller = card.getController();
        	PlayerZone graveyard = AllZone.getZone(Constant.Zone.Graveyard ,controller);
        	  
        	CardList sins = new CardList(graveyard.getCards());
        	sins = sins.getType("Assassin");
        	
        	if (card.getController().equals(Constant.Player.Human))
        	{
	        	Object o = AllZone.Display.getChoiceOptional("Pick an Assassin to remove", sins.toArray());
	        	
		        if(o != null)
		        {
		          Card crd = (Card)o;	
		          graveyard.remove(crd);
			      
		        	  
		          Card c = getTargetCard();
		
		          if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, c) )
		          {
		            AllZone.GameAction.destroy(c);
		          }
		        } //if o!= null
	       	}//player.equals("human")
        	else
        	{
        		Card crd = sins.get(0);
        		graveyard.remove(crd);
        		
        		Card c = getTargetCard();
        		if(AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, c) )
		        {
		            AllZone.GameAction.destroy(c);
		        }
        	}
          }//resolve()
        };//SpellAbility

        Input target = new Input()
        {
		  private static final long serialVersionUID = -4853162388286494888L;
		
		  public void showMessage()
          {
            AllZone.Display.showMessage("Select target creature to destroy");
            ButtonUtil.enableOnlyCancel();
          }
          public void selectButtonCancel() {stop();}
          public void selectCard(Card c, PlayerZone zone)
          {
        	if(!CardFactoryUtil.canTarget(ability, card)){
            	  AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
            }
            if(c.isCreature() && zone.is(Constant.Zone.Play))
            {
              //tap ability
              card.tap();

              ability.setTargetCard(c);
              AllZone.Stack.add(ability);
              stop();
            }
          }//selectCard()
        };//Input

        card.addSpellAbility(ability);
        ability.setDescription("tap: Remove an Assassin card in your graveyard from the game: Destroy target creature.");
        ability.setBeforePayMana(target);
    	
    
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
  else if(cardName.equals("Broodmate Dragon"))
  {
	  final SpellAbility ability = new Ability(card, "0")
      {
        public void resolve()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Dragon");
          c.setImageName("R 4 4 Dragon");
          c.setManaCost("R");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Dragon");
          
          c.addIntrinsicKeyword("Flying");

          c.setBaseAttack(4);
          c.setBaseDefense(4);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);

        }//resolve()
      };
      Command intoPlay = new Command()
      {
		private static final long serialVersionUID = 2848700532090223394L;

		public void execute()
        {
          ability.setStackDescription("Broodmate Dragon - put a 4/4 red Dragon creature token into play.");
          AllZone.Stack.add(ability);
        }
      };
      card.addComesIntoPlayCommand(intoPlay);
    
  }//*************** END ************ END **************************
	
    //*************** START *********** START **************************
    else if(cardName.equals("Gift of Estates"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -4997834790204261916L;

		public boolean canPlay()
        {
          String oppPlayer = AllZone.GameAction.getOpponent(card.getController());

          PlayerZone selfZone = AllZone.getZone(Constant.Zone.Play, card.getController());
          PlayerZone oppZone = AllZone.getZone(Constant.Zone.Play, oppPlayer);

          CardList self = new CardList(selfZone.getCards());
          CardList opp = new CardList(oppZone.getCards());

          self = self.getType("Land");
          opp = opp.getType("Land");

          return (self.size() < opp.size()) && super.canPlay();
        }//canPlay()

        public void resolve()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());

          CardList plains = new CardList(library.getCards());
          plains = plains.getType("Plains");

          for(int i = 0; i < 3 && i < plains.size(); i++)
            AllZone.GameAction.moveTo(hand, plains.get(i));
        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    else if(cardName.equals("Tithe"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 1504792204526793942L;

		public boolean oppMoreLand()
        {
          String oppPlayer = AllZone.GameAction.getOpponent(card.getController());

          PlayerZone selfZone = AllZone.getZone(Constant.Zone.Play, card.getController());
          PlayerZone oppZone = AllZone.getZone(Constant.Zone.Play, oppPlayer);

          CardList self = new CardList(selfZone.getCards());
          CardList opp = new CardList(oppZone.getCards());

          self = self.getType("Land");
          opp = opp.getType("Land");

          return (self.size() < opp.size()) && super.canPlay();
        }//oppoMoreLand()

        public void resolve()
        {
          PlayerZone library = AllZone.getZone(Constant.Zone.Library, card.getController());
          PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());

          CardList plains = new CardList(library.getCards());
          plains = plains.getType("Plains");

          if(0 < plains.size())
            AllZone.GameAction.moveTo(hand, plains.get(0));

          if(oppMoreLand() && 1 < plains.size())
            AllZone.GameAction.moveTo(hand, plains.get(1));

        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
   
  //*************** START *********** START **************************
    if(cardName.equals("Survival of the Fittest"))
    {
      SpellAbility ability = new Ability(card, "G")
      {
        public void resolve()
        {
        	String player = card.getController();
            if(player.equals(Constant.Player.Human))
              humanResolve();
            else
              computerResolve();
        }//resolve()
        public void humanResolve()
        {
          CardList handCreatures = new CardList(AllZone.Human_Hand.getCards());
          handCreatures = handCreatures.getType("Creature");
          
          if (handCreatures.size() == 0)
        	  return;
          
          Object discard = AllZone.Display.getChoiceOptional("Select Creature to discard", handCreatures.toArray());
          if (discard != null){
          
        	  CardList creatures = new CardList(AllZone.Human_Library.getCards());
        	  creatures = creatures.getType("Creature");
        	  
         	if (creatures.size() != 0) {          
         		Object check = AllZone.Display.getChoiceOptional("Select Creature", creatures.toArray());
         		if(check != null)
         		{
         			PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
         			AllZone.GameAction.moveTo(hand, (Card)check);
         		}
         		AllZone.GameAction.shuffle(Constant.Player.Human);
         	}
          AllZone.GameAction.discard((Card)discard);
          }
        }
        public void computerResolve()
        {
          //TODO
        }
        
        
      };//SpellAbility
      
      //card.clearSpellAbility();
      ability.setDescription("G: Discard a creature card: Search your library for a creature card, reveal that card, and put it into your hand. Then shuffle your library.");
      //ability.setBeforePayMana(new Input_NoCost_TapAbility((Ability) ability));
      //ability.setBeforePayMana(new Input_PayManaCost(ability));
      ability.setStackDescription("Survival of the Fittest - search for a creature card and put into hand");
      card.addSpellAbility(ability);
    }//*************** END ************ END **************************

    
  //*************** START *********** START **************************
    if(cardName.equals("Gerrard's Command"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 3128602006949603902L;
		
		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public void chooseTargetAI()
        {
          setTargetCard(getAttacker());
        }
        public Card getAttacker()
        {
        	//target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();
          Card[] att = c.getAttackers();
          if(att.length != 0)
            return att[0];
          else
            return null;
        }//getAttacker()
        public void resolve()
        {
          final Card[] target = new Card[1];
          final Command untilEOT = new Command()
          {
			private static final long serialVersionUID = -650846106294962607L;

			public void execute()
            {
              if(AllZone.GameAction.isCardInPlay(target[0]))
              {
                target[0].addTempAttackBoost(-3);
                target[0].addTempDefenseBoost(-3);
              }
            }
          };

          target[0] = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(target[0]) && CardFactoryUtil.canTarget(card, target[0]))
          {
            target[0].addTempAttackBoost(3);
            target[0].addTempDefenseBoost(3);
            target[0].untap();
                        
            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



//*************** START *********** START **************************
    if(cardName.equals("Brute Force"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 4733538427752827505L;

		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public void chooseTargetAI()
        {
          setTargetCard(getAttacker());
        }
        public Card getAttacker()
        {
        	//target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();
          //Card[] att = c.getAttackers();
          
          CardList list = new CardList();
          list.addAll(c.getAttackers());
          list = list.filter(new CardListFilter()
          {

			public boolean addCard(Card c) {
				return CardFactoryUtil.canTarget(card, c);
			}
        	  
          });
          
          if(list.size() != 0)
            return list.get(0);
          else
            return null;
        }//getAttacker()
        public void resolve()
        {
          final Card[] target = new Card[1];
          final Command untilEOT = new Command()
          {
			private static final long serialVersionUID = 8299648917436556370L;

			public void execute()
            {
              if(AllZone.GameAction.isCardInPlay(target[0]))
              {
                target[0].addTempAttackBoost(-3);
                target[0].addTempDefenseBoost(-3);
              }
            }
          };

          target[0] = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(target[0]) && CardFactoryUtil.canTarget(card, target[0]) )
          {
            target[0].addTempAttackBoost(3);
            target[0].addTempDefenseBoost(3);

            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************



    //*************** START *********** START **************************
    if(cardName.equals("Nameless Inversion"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 5479536291205544905L;

		public boolean canPlayAI()
        {
          CardList list = CardFactoryUtil.AI_getHumanCreature(3, card, true);
          CardListUtil.sortFlying(list);

          for(int i = 0; i < list.size(); i++)
            if(2 <= list.get(i).getNetAttack())
            {
              setTargetCard(list.get(i));
              return true;
            }
          return false;
        }//canPlayAI()

        public void resolve()
        {
          final Card[] target = new Card[1];
          final Command untilEOT = new Command()
          {
			private static final long serialVersionUID = -1954104042512587145L;

			public void execute()
            {
              if(AllZone.GameAction.isCardInPlay(target[0]))
              {
                target[0].addTempAttackBoost(-3);
                target[0].addTempDefenseBoost(3);
              }
            }
          };

          target[0] = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(target[0]) && CardFactoryUtil.canTarget(card, target[0]))
          {
            target[0].addTempAttackBoost(3);
            target[0].addTempDefenseBoost(-3);

            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Tromp the Domains"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 1523193367625798058L;
		
		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public Card getAttacker()
        {
          //target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();
          Card[] att = c.getAttackers();
          if(att.length != 0)
            return att[0];
          else
            return null;
        }//getAttacker()

        int countLandTypes()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList land = new CardList(play.getCards());

          String basic[] = {"Forest", "Plains", "Mountain", "Island", "Swamp"};
          int count = 0;

          for(int i = 0; i < basic.length; i++)
          {
            CardList c = land.getType(basic[i]);
            if(! c.isEmpty())
              count++;
          }

          return count;
        }//countLandTypes()
        public void resolve()
        {

          final int boost = countLandTypes();
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList list = new CardList(play.getCards());
          @SuppressWarnings("unused") // c
		  Card c;

          for(int i = 0; i < list.size(); i++)
          {
            final Card[] target = new Card[1];
            target[0] = list.get(i);

            final Command untilEOT = new Command()
            {
			  private static final long serialVersionUID = -4207130279969069542L;

			  public void execute()
              {
                if(AllZone.GameAction.isCardInPlay(target[0]))
                {
                  target[0].addTempAttackBoost(-boost);
                  target[0].addTempDefenseBoost(-boost);

                  target[0].removeExtrinsicKeyword("Trample");
                }
              }
            };//Command

            if(AllZone.GameAction.isCardInPlay(target[0]))
            {
              target[0].addTempAttackBoost(boost);
              target[0].addTempDefenseBoost(boost);

              target[0].addExtrinsicKeyword("Trample");

              AllZone.EndOfTurn.addUntil(untilEOT);
            }//if
          }//for
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Titanic Ultimatum"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 4920407567000133514L;

		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public Card getAttacker()
        {
          //target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();
          Card[] att = c.getAttackers();
          if(att.length != 0)
            return att[0];
          else
            return null;
        }//getAttacker()

        public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          CardList list = new CardList(play.getCards());
          @SuppressWarnings("unused") // c
		  Card c;

          for(int i = 0; i < list.size(); i++)
          {
            final Card[] target = new Card[1];
            target[0] = list.get(i);

            final Command untilEOT = new Command()
            {
			  private static final long serialVersionUID = -3807842003906681893L;

			  public void execute()
              {
                if(AllZone.GameAction.isCardInPlay(target[0]))
                {
                  target[0].addTempAttackBoost(-5);
                  target[0].addTempDefenseBoost(-5);

                  target[0].removeExtrinsicKeyword("Trample");
                  target[0].removeExtrinsicKeyword("First Strike");
                  target[0].removeExtrinsicKeyword("Lifelink");
                }
              }
            };//Command

            if(AllZone.GameAction.isCardInPlay(target[0]))
            {
              target[0].addTempAttackBoost(5);
              target[0].addTempDefenseBoost(5);

              target[0].addExtrinsicKeyword("Trample");
              target[0].addExtrinsicKeyword("First Strike");
              target[0].addExtrinsicKeyword("Lifelink");

              AllZone.EndOfTurn.addUntil(untilEOT);
            }//if
          }//for
        }//resolve()
      };
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Primal Boost"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 2449600319884238808L;
		
		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public void chooseTargetAI()
        {
          setTargetCard(getAttacker());
        }
        public Card getAttacker()
        {
          //target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();

          CardList list = new CardList(c.getAttackers());
          CardListUtil.sortFlying(list);

          Card[] att = list.toArray();
          if(att.length != 0)
            return att[0];
          else
            return null;
        }//getAttacker()
        public void resolve()
        {
          final Card[] target = new Card[1];
          final Command untilEOT = new Command()
          {
			private static final long serialVersionUID = 3753684523153747308L;

			public void execute()
            {
              if(AllZone.GameAction.isCardInPlay(target[0]))
              {
                target[0].addTempAttackBoost(-4);
                target[0].addTempDefenseBoost(-4);
              }
            }
          };

          target[0] = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(target[0]) && CardFactoryUtil.canTarget(card, target[0]))
          {
            target[0].addTempAttackBoost(4);
            target[0].addTempDefenseBoost(4);

            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };
      spell.setDescription("Target creature gets +4/+4 until end of turn.");
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      card.addSpellAbility(CardFactoryUtil.ability_cycle(card, "2 G"));
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Wildsize"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -4558777579924787035L;

		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public void chooseTargetAI()
        {
          setTargetCard(getAttacker());
        }
        public Card getAttacker()
        {
          //target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();

          CardList list = new CardList(c.getAttackers());
          CardListUtil.sortFlying(list);

          Card[] att = list.toArray();
          if(att.length != 0)
            return att[0];
          else
            return null;
        }//getAttacker()

        public void resolve()
        {
          final Card[] target = new Card[1];
          final Command untilEOT = new Command()
          {
			private static final long serialVersionUID = -8390763209393328399L;

			public void execute()
            {
              if(AllZone.GameAction.isCardInPlay(target[0]))
              {
                target[0].addTempAttackBoost(-2);
                target[0].addTempDefenseBoost(-2);

                target[0].removeExtrinsicKeyword("Trample");
              }
            }
          };

          target[0] = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(target[0]) && CardFactoryUtil.canTarget(card, target[0]))
          {
            target[0].addTempAttackBoost(2);
            target[0].addTempDefenseBoost(2);
            target[0].addExtrinsicKeyword("Trample");

            AllZone.EndOfTurn.addUntil(untilEOT);
            AllZone.GameAction.drawCard(card.getController());
          }
        }//resolve()
      };
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************






  //*************** START *********** START **************************
    if(cardName.equals("Feral Lightning"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -1841642966580694848L;
		
		public boolean canPlayAI()
        {
          return AllZone.Phase.getPhase().equals(Constant.Phase.Main1);
        }


        public void resolve()
        {
          final Card[] token = new Card[3];
          final Command atEOT = new Command()
          {
			private static final long serialVersionUID = -1928884889370422828L;

			public void execute()
            {
              //destroy tokens at end of turn
              for(int i = 0; i < token.length; i++)
                if(AllZone.GameAction.isCardInPlay(token[i]))
                  AllZone.GameAction.destroy(token[i]);
            }
          };
          AllZone.EndOfTurn.addAt(atEOT);

          for(int i = 0; i < token.length; i++)
            token[i] = makeToken();
        }//resolve()
        Card makeToken()
        {
          Card c = new Card();

          c.setOwner(card.getController());
          c.setController(card.getController());

          c.setName("Elemental");
          c.setImageName("R 3 1 Elemental");
          c.setManaCost("R");
          c.setToken(true);

          c.addType("Creature");
          c.addType("Elemental");
          c.setBaseAttack(3);
          c.setBaseDefense(1);
          c.addIntrinsicKeyword("Haste");
          c.setSacrificeAtEOT(true);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);

          return c;
        }//makeToken()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************






    //*************** START *********** START **************************
    if(cardName.equals("Inspirit"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -601100008975177639L;
		
		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public void chooseTargetAI()
        {
          setTargetCard(getAttacker());
        }
        public Card getAttacker()
        {
          //target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();
          Card[] att = c.getAttackers();
          if(att.length != 0)
            return att[0];
          else
            return null;
        }//getAttacker()
        public void resolve()
        {
          final Card[] target = new Card[1];
          final Command untilEOT = new Command()
          {
			private static final long serialVersionUID = -3197321199337917886L;

			public void execute()
            {
              if(AllZone.GameAction.isCardInPlay(target[0]))
              {
                target[0].addTempAttackBoost(-2);
                target[0].addTempDefenseBoost(-4);
              }
            }
          };

          target[0] = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(target[0]) && CardFactoryUtil.canTarget(card, target[0]))
          {
            target[0].addTempAttackBoost(2);
            target[0].addTempDefenseBoost(4);

            target[0].untap();

            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************




    //*************** START *********** START **************************
    if(cardName.equals("Might of Oaks"))
    {
      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -33985340162641452L;
		
		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public void chooseTargetAI()
        {
          setTargetCard(getAttacker());
        }
        public Card getAttacker()
        {
          //target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();
          Card[] att = c.getAttackers();
          if(att.length != 0)
            return att[0];
          else
            return null;
        }//getAttacker()
        public void resolve()
        {
          final Card[] target = new Card[1];
          final Command untilEOT = new Command()
          {
			private static final long serialVersionUID = -5138969487216215323L;

			public void execute()
            {
              if(AllZone.GameAction.isCardInPlay(target[0]))
              {
                target[0].addTempAttackBoost(-7);
                target[0].addTempDefenseBoost(-7);
              }
            }
          };

          target[0] = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(target[0]) && CardFactoryUtil.canTarget(card, getTargetCard()))
          {
            target[0].addTempAttackBoost(7);
            target[0].addTempDefenseBoost(7);

            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
      };
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************

  //*************** START *********** START **************************
    if(cardName.equals("Guided Strike"))
    {
      final Card[] target = new Card[1];
      final Command untilEOT = new Command()
      {
		private static final long serialVersionUID = 6381010042083054770L;

		public void execute()
        {
          if(AllZone.GameAction.isCardInPlay(target[0]) && CardFactoryUtil.canTarget(card, target[0]))
          {
            target[0].addTempAttackBoost(-1);
            target[0].removeExtrinsicKeyword("First Strike");
          }
        }
      };

      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 6373328936243472966L;
		
		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public void chooseTargetAI()
        {
          setTargetCard(getAttacker());
        }
        public Card getAttacker()
        {
          //target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();
          Card[] att = c.getAttackers();
          if(att.length != 0)
            return att[0];
          else
            return null;
        }//getAttacker()
        public void resolve()
        {
          target[0] = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(target[0]))
          {
            target[0].addTempAttackBoost(1);
            target[0].addExtrinsicKeyword("First Strike");

            AllZone.EndOfTurn.addUntil(untilEOT);
            AllZone.GameAction.drawCard(card.getController());
          }
        }//resolve()
      };
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    

    //*************** START *********** START **************************
    if(cardName.equals("Aggressive Urge"))
    {
      final Card[] target = new Card[1];
      final Command untilEOT = new Command()
      {
		private static final long serialVersionUID = 5519847437187468154L;

		public void execute()
        {
          if(AllZone.GameAction.isCardInPlay(target[0]))
          {
            target[0].addTempAttackBoost(-1);
            target[0].addTempDefenseBoost(-1);
          }
        }
      };

      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -1043326570050661433L;
		
		public boolean canPlayAI()
        {
          return getAttacker() != null;
        }
        public void chooseTargetAI()
        {
          setTargetCard(getAttacker());
        }
        public Card getAttacker()
        {
          //target creature that is going to attack
          Combat c = ComputerUtil.getAttackers();
          Card[] att = c.getAttackers();
          if(att.length != 0)
            return att[0];
          else
            return null;
        }//getAttacker()
        public void resolve()
        {
          target[0] = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(target[0]) && CardFactoryUtil.canTarget(card, target[0]))
          {
            target[0].addTempAttackBoost(1);
            target[0].addTempDefenseBoost(1);

            AllZone.EndOfTurn.addUntil(untilEOT);
            AllZone.GameAction.drawCard(card.getController());
          }
        }//resolve()
      };
      spell.setBeforePayMana(CardFactoryUtil.input_targetCreature(spell));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Vindicate"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -2302610807061478203L;

		public boolean canPlayAI()
    	{
    	  CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
    	  return 4 < AllZone.Phase.getTurn() && 0 < human.size();
    	}
    	public void chooseTargetAI()
    	{
    	  CardList human = CardFactoryUtil.AI_getHumanCreature(card, true);
    	  setTargetCard(CardFactoryUtil.AI_getBestCreature(human));
    	}

    	public void resolve()
    	{
    	  if(AllZone.GameAction.isCardInPlay(getTargetCard())  && CardFactoryUtil.canTarget(card, getTargetCard()))
    	  {
    		if(getTargetCard().isToken())
    		  AllZone.getZone(getTargetCard()).remove(getTargetCard());
    		else
    		{
    		  AllZone.GameAction.destroy(getTargetCard());
    		}
    	  }//if
    	}//resolve()
      };//SpellAbility
      Input target = new Input()
      {
		private static final long serialVersionUID = -7826307781920832218L;
		
		public void showMessage()
    	{
    	  AllZone.Display.showMessage("Select target permanent for " +spell.getSourceCard());
    	  ButtonUtil.enableOnlyCancel();
    	}
    	public void selectButtonCancel() {stop();}
    	public void selectCard(Card card, PlayerZone zone)
    	{
    	  if(zone.is(Constant.Zone.Play))
    	  {
    		spell.setTargetCard(card);
    		stopSetNext(new Input_PayManaCost(spell));
    	  }
    	}
      };//Input

      spell.setBeforePayMana(target);
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Shatter"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -8518902112426882210L;
		
		public boolean canPlayAI()
        {
          return (getArtifact().size() != 0) && (AllZone.Phase.getTurn() > 4);
        }
        public void chooseTargetAI()
        {
         if(getArtifact().size() != 0){
            Card bestArtifact = CardFactoryUtil.AI_getBestArtifact(getArtifact());
            setTargetCard(bestArtifact);
         }
        }//getEnchantment()
        CardList getArtifact()
        {
           CardList list = CardFactoryUtil.AI_getHumanArtifact(card, true);
           return list;
        }//getArtifact()
        public void resolve()
        {
          AllZone.GameAction.destroy(getTargetCard());
        }//resolve()
      };

      Input runtime = new Input()
      {
		private static final long serialVersionUID = 7950082427462078698L;

		public void showMessage()
        {
         //Display all artifacts in play
         //Allow human player to select which one to destroy
          CardList allCards = new CardList();
          allCards.addAll(AllZone.Human_Play.getCards());
          allCards.addAll(AllZone.Computer_Play.getCards());

          //get artifacts
          CardList allArtifacts = allCards.getType("Artifact");
          stopSetNext(CardFactoryUtil.input_targetSpecific(spell, allArtifacts, "Select target Artifact to destroy.",true));
      
        }
      };

      card.clearSpellAbility();
      spell.setBeforePayMana(runtime);
      card.addSpellAbility(spell);
      }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    else if(cardName.equals("Disenchant") || cardName.equals("Naturalize"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 6231507037766815249L;
		
		public boolean canPlayAI()
        {
          return (getEnchantment().size() != 0 || getArtifact().size() != 0) && (AllZone.Phase.getTurn() > 4);
        }
        public void chooseTargetAI()
        {
          if(getEnchantment().size() != 0)
          {
            Card bestEnchantment = CardFactoryUtil.AI_getBestEnchantment(getEnchantment(), card, true);
            if(getArtifact().size() != 0){
              Card bestArtifact = CardFactoryUtil.AI_getBestArtifact(getArtifact());
              if(CardUtil.getConvertedManaCost(bestArtifact.getManaCost()) > CardUtil.getConvertedManaCost(bestEnchantment.getManaCost())){
                setTargetCard(bestArtifact);
              }
              else{
                setTargetCard(bestEnchantment);
              }
            }
            else{
              setTargetCard(bestEnchantment);
            }
          }
          else if(getArtifact().size() != 0){
            Card bestArtifact = CardFactoryUtil.AI_getBestArtifact(getArtifact());
            setTargetCard(bestArtifact);
          }

        }
        CardList getEnchantment()
        {
          CardList list = CardFactoryUtil.AI_getHumanEnchantment(card, true);
          list = list.filter(new CardListFilter()
          {
			public boolean addCard(Card c) {
				return !c.getKeyword().contains("Indestructible");
			}  
          });
          return list;
        }//getEnchantment()
        CardList getArtifact()
        {
          CardList list = CardFactoryUtil.AI_getHumanArtifact(card, true);
          list = list.filter(new CardListFilter()
          {
			public boolean addCard(Card c) {
				return !c.getKeyword().contains("Indestructible");
			}  
          });
          return list;
        }//getArtifact()
        public void resolve()
        {
          //AllZone.GameAction.destroyNoRegeneration(getTargetCard());
          AllZone.GameAction.destroy(getTargetCard());
        
        }//resolve()
      };

      Input runtime = new Input()
      {
    	private static final long serialVersionUID = -1212213052029735882L;

		public void showMessage()
        {
          //Display all artifacts and enchantments in play
          //Allow human player to select which one to destroy
          CardList allCards = new CardList();
          allCards.addAll(AllZone.Human_Play.getCards());
          allCards.addAll(AllZone.Computer_Play.getCards());

          //get enchantments and get artifacts
          CardList allEnchantments = allCards.getType("Enchantment");
          CardList allArtifacts = allCards.getType("Artifact");

          //put enchantments and artifacts in same cardList to display
          CardList allEnchantmentsAndArtifacts = allEnchantments;
          allEnchantmentsAndArtifacts.addAll(allArtifacts.toArray());


          stopSetNext(CardFactoryUtil.input_targetSpecific(spell, allEnchantmentsAndArtifacts, "Select target Enchantment or Artifact to destroy.", true));
        }
      };

      card.clearSpellAbility();
      spell.setBeforePayMana(runtime);
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Demystify"))
    {
      final SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = -4045818747862804365L;
		
		public boolean canPlayAI()
        {
          return (getEnchantment().size() != 0) && (AllZone.Phase.getTurn() > 4);
        }
        public void chooseTargetAI()
        {
          Card best = CardFactoryUtil.AI_getBestEnchantment(getEnchantment(), card,  true);
          setTargetCard(best);
        }
        CardList getEnchantment()
        {
          CardList list = CardFactoryUtil.AI_getHumanEnchantment(card, true);
          return list;
        }//getCreature()
        public void resolve()
        {
          AllZone.GameAction.destroyNoRegeneration(getTargetCard());
        }//resolve()
      };

      Input runtime = new Input()
      {
		private static final long serialVersionUID = 746063168471322007L;

		public void showMessage()
        {
          CardList choice = new CardList();
          choice.addAll(AllZone.Human_Play.getCards());
          choice.addAll(AllZone.Computer_Play.getCards());

          choice = choice.getType("Enchantment");

          stopSetNext(CardFactoryUtil.input_targetSpecific(spell, choice, "Select target Enchantment to destroy.",true));
        }
      };

      card.clearSpellAbility();
      spell.setBeforePayMana(runtime);
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************





    //*************** START *********** START **************************
    if(cardName.equals("Animate Land"))
    {
      final Card[] target = new Card[1];
      final Command untilEOT = new Command()
      {
		private static final long serialVersionUID = -3359299797188942353L;

		public void execute()
        {
          if(AllZone.GameAction.isCardInPlay(target[0]))
          {
            target[0].removeType("Creature");
          }
        }
      };

      SpellAbility spell = new Spell(card)
      {
		private static final long serialVersionUID = 4890851927124377327L;
		
		public void resolve()
        {
          target[0] = getTargetCard();
          if(AllZone.GameAction.isCardInPlay(target[0])  && CardFactoryUtil.canTarget(card, target[0]))
          {
            target[0].addType("Creature");
            target[0].setBaseAttack(3);
            target[0].setBaseDefense(3);

            AllZone.EndOfTurn.addUntil(untilEOT);
          }
        }//resolve()
        public boolean canPlayAI()
        {
          return false;
/* all this doesnt work, computer will not attack with the animated land

//does the computer have any land in play?
CardList land = new CardList(AllZone.Computer_Play.getCards());
land = land.getType("Land");
land = land.filter(new CardListFilter()
{
  public boolean addCard(Card c)
  {
          //checks for summoning sickness, and is not tapped
    return CombatUtil.canAttack(c);
  }
});
return land.size() > 1 && CardFactoryUtil.AI_isMainPhase();
*/
        }
      };//SpellAbility
//      spell.setChooseTargetAI(CardFactoryUtil.AI_targetType("Land", AllZone.Computer_Play));

      spell.setBeforePayMana(CardFactoryUtil.input_targetType(spell, "Land"));
      card.clearSpellAbility();
      card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Aven Riftwatcher"))
    {
       Command gain2Life = new Command()
         {
			private static final long serialVersionUID = 5588978023269625349L;
			
			public boolean firstTime = true;
            public void execute()
            {
              PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
              life.addLife(2);

              //testAndSet - only needed when comes into play.
              if(firstTime){
            	  card.setCounter(Counters.AGE, 3); //vanishing
              }
              firstTime = false;
            }
          };

      card.addLeavesPlayCommand(gain2Life);
      card.addComesIntoPlayCommand(gain2Life);

    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if(cardName.equals("Calciderm"))
    {
      Command ageCounters = new Command()
      {
    	    private static final long serialVersionUID = 431920157968451817L;
			public boolean firstTime = true;
            public void execute()
            {

              //testAndSet - only needed when comes into play.
              if(firstTime){
            	  card.setCounter(Counters.AGE, 4); 
              }
              firstTime = false;
            }
      };
      card.addComesIntoPlayCommand(ageCounters);

    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Blastoderm"))
    {
      Command fadeCounters = new Command()
      {
    	    private static final long serialVersionUID = -580691660706977218L;
			public boolean firstTime = true;
            public void execute()
            {

              //testAndSet - only needed when comes into play.
              if(firstTime){
            	  card.setCounter(Counters.FADE, 3); 
              }
              firstTime = false;
            }
      };

      card.addComesIntoPlayCommand(fadeCounters);

    }//*************** END ************ END **************************

    
  
    //*************** START *********** START **************************
    if(cardName.equals("Godsire"))
    {
    	 final SpellAbility a1 = new Ability_Tap(card)
         {
		   private static final long serialVersionUID = -1160527561099142816L;
		   
		   public void resolve()
           {
             makeToken();
           }
           void makeToken()
           {
             Card c = new Card();

             c.setName("Beast");
             c.setImageName("RGW 8 8 Beast");

             c.setOwner(card.getController());
             c.setController(card.getController());

             c.setManaCost("R G W");
             c.setToken(true);             
             
             c.addType("Creature");
             c.addType("Beast");
             c.setBaseAttack(8);
             c.setBaseDefense(8);

             PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
             play.add(c);
           }//makeToken()
           
           public boolean canPlayAI()
           {
        	   return AllZone.Phase.getPhase().equals("Main2");
           }
           
         };//SpellAbility
         card.addSpellAbility(a1);
         a1.setDescription("T: Put an 8/8 Beast creature token into play that's red, green, and white.");
         a1.setStackDescription("Put an 8/8 Beast creature token into play that's red, green, and white.");

         //a1.setBeforePayMana(new Input_PayManaCost(a1));
    }//*************** END ************ END **************************
    
    if (cardName.equals("Ior Ruin Expedition"))
    {
	    final SpellAbility ability = new Ability(card, "0")
	    {
	      public boolean canPlay()
	      {
	              return card.getCounters(Counters.QUEST) >= 3 && AllZone.GameAction.isCardInPlay(card)&&!AllZone.Stack.getSourceCards().contains(card);//in play and not already activated(Sac cost problems)
	      }
	      public boolean canPlayAI() {return (AllZone.Computer_Hand.size() < 6)&&(AllZone.Computer_Library.size()>0);}
	
	      public void resolve()
	      {
	        AllZone.GameAction.drawCard(card.getController());
	        AllZone.GameAction.drawCard(card.getController());
	        AllZone.GameAction.sacrifice(getSourceCard());
	      }
	    };
	    ability.setDescription("Remove three quest counters from Ior Ruin Expedition and sacrifice it: Draw two cards.");
	    ability.setStackDescription(card.getName() +" - Draw two cards.");
	    
	    card.addSpellAbility(ability);
    }
    
    //*************** START *********** START **************************
    if(cardName.equals("Wydwen, the Biting Gale"))
    {
    	final SpellAbility a1 = new Ability(card,"U B")
        {
    	  public boolean canPlayAI()
    	  {
    		  return false;
    	  }
      	  public void resolve()
            {
      		  PlayerLife life = AllZone.GameAction.getPlayerLife(card.getController());
      		  life.subtractLife(1);
      		  PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getOwner());
      		  /*
      		  AllZone.getZone(card).remove(card);
      		  hand.add(card);
      		  */
      		  if (card.isToken())
    			  AllZone.getZone(card).remove(card);
    		  else
    			  AllZone.GameAction.moveTo(hand, card);
      		  

            }
        };//a1
        
        //card.clearSpellAbility();
        card.addSpellAbility(a1);
        a1.setStackDescription(card.getController() + " pays 1 life and returns Wydwen back to owner's hand.");
        a1.setDescription("U B, Pay 1 life: Return Wydwen, the Biting Gale to its owner's hand.");

    
   }//*************** END ************ END **************************
    

    //*************** START *********** START **************************
    if(cardName.equals("Earthcraft"))
    {
    	final SpellAbility a1 = new Ability(card,"0")
        {
			private static final long serialVersionUID = 6787319311700905218L;
	
			public boolean canPlayAI()
			  {
				  return false;
			  }
			  
	    	  public boolean canPlay()
	    	  {
	    		  String controller = card.getController();
	    		  PlayerZone play = AllZone.getZone(Constant.Zone.Play, controller);
		  
	    		  CardList creats = new CardList();
	    		  
	    		  creats.addAll(play.getCards());
	    		  creats = creats.getType("Creature");
	    		  creats = creats.filter(new CardListFilter()
	    		  {
					public boolean addCard(Card c) {
						return c.isUntapped();
					} 
	    		  });
	    		  
	    		  if (creats.size() > 0 && AllZone.GameAction.isCardInPlay(card))
	    			  return true;
	    		  else
	    			  return false;
	    	  }
	    	  public void resolve()
	    	  {
	
	    		if (getTargetCard()== null)
	    			return;
	    		  
	            String player = card.getController();
	            if(player.equals(Constant.Player.Human))
	              humanResolve();
	            //else
	            //  computerResolve();
	          }
	      	  public void humanResolve()
	          {
	      		  String controller = card.getController();
	      		  PlayerZone play = AllZone.getZone(Constant.Zone.Play, controller);
	      		  CardList creats = new CardList();
	  		  
	      		  creats.addAll(play.getCards());
	      		  creats = creats.getType("Creature");
	      		  creats = creats.filter(new CardListFilter()
	      		  {
					public boolean addCard(Card c) {
						return c.isUntapped() && !c.equals(card);
					}
	      		  });    		  
	      		  
	      		  if (creats.size() == 1) {
	      			  creats.get(0).tap();
	      			  if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
		      		      getTargetCard().untap();
	      			  
	      		  }
	      		  else if (creats.size() > 1) {
		      		  Object o = AllZone.Display.getChoice("Select creature to tap", creats.toArray());
		      		  
		      		  if (o!= null)
		      		  {
		      			  Card c1 = (Card)o;
		      			  c1.tap();
		      			  if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
			      		      getTargetCard().untap();
		      		  }
	      		  }
	      		  
	      		  
	
	          }//humanResolve

        };//a1
        
        //card.clearSpellAbility();
        card.addSpellAbility(a1);
        a1.setDescription("Tap an untapped creature you control: untap target basic land.");
        
        Input runtime = new Input()
        {
			private static final long serialVersionUID = -2287693175821059029L;

			public void showMessage()
	          {
	            CardList all = new CardList();
	            all.addAll(AllZone.Human_Play.getCards());
	            all.addAll(AllZone.Computer_Play.getCards());
	            all = all.filter(new CardListFilter()
	            {
		  			public boolean addCard(Card c) {
		  				return (c.isBasicLand()) && CardFactoryUtil.canTarget(card, c) && c.isTapped();
		  			}
	            });
	            
	            stopSetNext(CardFactoryUtil.input_targetSpecific(a1, all, "Select target basic land", true));
	          }
        };
        a1.setBeforePayMana(runtime);
    	
    }//*************** END ************ END **************************
    
    
    //*************** START *********** START **************************
    if(cardName.equals("Tradewind Rider"))
    {
    	final SpellAbility a1 = new Ability_Tap(card,"0")
        {
			private static final long serialVersionUID = 3438865371487994984L;

			public void chooseTargetAI()
            {
              if(getCreature().size() != 0)
              {
                Card bestCreature = CardFactoryUtil.AI_getBestCreature(getCreature());
                if(getEnchantment().size() != 0){
                  Card bestEnchantment = CardFactoryUtil.AI_getBestEnchantment(getEnchantment(), card, true);
                  if(CardUtil.getConvertedManaCost(bestCreature.getManaCost()) > CardUtil.getConvertedManaCost(bestEnchantment.getManaCost())){
                    setTargetCard(bestCreature);
                  }
                  else{
                    setTargetCard(bestEnchantment);
                  }
                }
                else{
                  setTargetCard(bestCreature);
                }
              }
              else if(getArtifact().size() != 0){
                Card bestArtifact = CardFactoryUtil.AI_getBestArtifact(getArtifact());
                setTargetCard(bestArtifact);
              }

            }//ChooseTargetAI()
            CardList getCreature()
            {
              CardList list = CardFactoryUtil.AI_getHumanCreature(card, true);
              return list;
            }//getEnchantment()
            CardList getArtifact()
            {
              CardList list = CardFactoryUtil.AI_getHumanArtifact(card, true);
              return list;
            }//getArtifact()
            CardList getEnchantment()
            {
            	CardList list = CardFactoryUtil.AI_getHumanEnchantment(card, true);
            	return list;
            }
           
    		
    		
          public boolean canPlayAI()
          {
        	  PlayerZone play = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
        	  CardList cards = new CardList();
        	  
        	  cards.addAll(play.getCards());
        	  cards = cards.filter(new CardListFilter(){

				public boolean addCard(Card c) {
					return (c.isArtifact() || c.isEnchantment() || c.isCreature() ) && CardFactoryUtil.canTarget(card, c);
				}
        		  
        	  });
        	  
        	  return cards.size() > 0;
        	  
          }
    	  public boolean canPlay()
    	  {
    		  String controller = card.getController();
    		  PlayerZone play = AllZone.getZone(Constant.Zone.Play, controller);
	  
    		  CardList creats = new CardList();
    		  
    		  creats.addAll(play.getCards());
    		  creats = creats.getType("Creature");
    		  creats = creats.filter(new CardListFilter()
    		  {
				public boolean addCard(Card c) {
					return c.isUntapped() && !c.equals(card);
				} 
    		  });
    		  
    		  if (creats.size() > 1 && AllZone.GameAction.isCardInPlay(card) && card.isUntapped() && !card.hasSickness())
    			  return true;
    		  else
    			  return false;
    	  }
    	  public void resolve()
    	  {

    		if (getTargetCard()== null)
    			return;
    		  
            String player = card.getController();
            if(player.equals(Constant.Player.Human))
              humanResolve();
            else
              computerResolve();
          }
      	  public void humanResolve()
          {
      		  String controller = card.getController();
      		  PlayerZone play = AllZone.getZone(Constant.Zone.Play, controller);
      		  CardList creats = new CardList();
  		  
      		  creats.addAll(play.getCards());
      		  creats = creats.getType("Creature");
      		  creats = creats.filter(new CardListFilter()
      		  {
				public boolean addCard(Card c) {
					return c.isUntapped() && !c.equals(card);
				}
      		  });    		  
      		  
      		  CardList tappedCreats = new CardList();
      		  
      		  Object o = AllZone.Display.getChoice("Pick first creature to tap", creats.toArray());
      		  
      		  if (o!= null)
      		  {
      			  Card c1 = (Card)o;
      			  creats.remove(c1);     
      			  tappedCreats.add(c1);
      		  }
      		  else
      			  return;
      		  
      		  o = AllZone.Display.getChoice("Pick second creature to tap", creats.toArray());
      		  if (o!= null)
        	  {
      			  Card c2 = (Card)o;
      			  creats.remove(c2); 
      			  tappedCreats.add(c2);
        	  }	  
      		  else 
      			  return;
    		     		  
    		  for(int i = 0; i<tappedCreats.size(); i++)
    		  {
    			  Card tapCreat = tappedCreats.get(i);
    			  tapCreat.tap();
    		  }
    		  
    		  //AllZone.GameAction.destroy(getTargetCard());   
    		  PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, getTargetCard().getOwner());
    		  AllZone.GameAction.moveTo(hand, getTargetCard());
          }//humanResolve
      	  
      	  public void computerResolve()
      	  {
    		  String controller = card.getController();
    		  PlayerZone play = AllZone.getZone(Constant.Zone.Play, controller);
    		  CardList creats = new CardList();
		  
    		  creats.addAll(play.getCards());
    		  creats = creats.getType("Creature");
    		  
    		      		  
    		  for (int i=0; i < 3; i++)
    		  {
    			  Card c = creats.get(i);
    			  c.tap();
    		  }
    		  
    		  PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, getTargetCard().getOwner());
    		  AllZone.GameAction.moveTo(hand, getTargetCard()); 

      	  }//computerResolve

        };//a1
        
        //card.clearSpellAbility();
        card.addSpellAbility(a1);
        a1.setDescription("tap, Tap two untapped creatures you control: Return target permanent to its owner's hand.");
        
        Input runtime = new Input()
        {


        private static final long serialVersionUID = 5673846456179861542L;

		public void showMessage()
          {
            CardList all = new CardList();
            all.addAll(AllZone.Human_Play.getCards());
            all.addAll(AllZone.Computer_Play.getCards());
            all = all.filter(new CardListFilter()
            {
	  			public boolean addCard(Card c) {
	  				return (c.isPermanent()) && CardFactoryUtil.canTarget(card, c);
	  			}
            });
            
            stopSetNext(CardFactoryUtil.input_targetSpecific(a1, all, "Return target permanent", true));
          }
        };
        a1.setBeforePayMana(runtime);
    	
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    if(cardName.equals("Nullmage Shepherd"))
    {
    	final SpellAbility a1 = new Ability(card,"0")
        {
    		public void chooseTargetAI()
            {
              if(getEnchantment().size() != 0)
              {
                Card bestEnchantment = CardFactoryUtil.AI_getBestEnchantment(getEnchantment(), card, true);
                if(getArtifact().size() != 0){
                  Card bestArtifact = CardFactoryUtil.AI_getBestArtifact(getArtifact());
                  if(CardUtil.getConvertedManaCost(bestArtifact.getManaCost()) > CardUtil.getConvertedManaCost(bestEnchantment.getManaCost())){
                    setTargetCard(bestArtifact);
                  }
                  else{
                    setTargetCard(bestEnchantment);
                  }
                }
                else{
                  setTargetCard(bestEnchantment);
                }
              }
              else if(getArtifact().size() != 0){
                Card bestArtifact = CardFactoryUtil.AI_getBestArtifact(getArtifact());
                setTargetCard(bestArtifact);
              }

            }
            CardList getEnchantment()
            {
              CardList list = CardFactoryUtil.AI_getHumanEnchantment(card, true);
              return list;
            }//getEnchantment()
            CardList getArtifact()
            {
              CardList list = CardFactoryUtil.AI_getHumanArtifact(card, true);
              return list;
            }//getArtifact()
    		
    		
          public boolean canPlayAI()
          {
        	  PlayerZone play = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
        	  CardList cards = new CardList();
        	  
        	  cards.addAll(play.getCards());
        	  cards = cards.filter(new CardListFilter(){

				public boolean addCard(Card c) {
					return (c.isArtifact() || c.isEnchantment() ) && CardFactoryUtil.canTarget(card, c);
				}
        		  
        	  });
        	  
        	  return cards.size() > 0;
        	  
          }
    	  public boolean canPlay()
    	  {
    		  String controller = card.getController();
    		  PlayerZone play = AllZone.getZone(Constant.Zone.Play, controller);
	  
    		  CardList creats = new CardList();
    		  
    		  creats.addAll(play.getCards());
    		  creats = creats.getType("Creature");
    		  creats = creats.filter(new CardListFilter()
    		  {
				public boolean addCard(Card c) {
					return c.isUntapped();
				} 
    		  });
    		  
    		  if (creats.size() > 3 && AllZone.GameAction.isCardInPlay(card))
    			  return true;
    		  else
    			  return false;
    	  }
    	  public void resolve()
    	  {

    		if (getTargetCard()== null)
    			return;
    		  
            String player = card.getController();
            if(player.equals(Constant.Player.Human))
              humanResolve();
            else
              computerResolve();
          }
      	  public void humanResolve()
          {
      		  String controller = card.getController();
      		  PlayerZone play = AllZone.getZone(Constant.Zone.Play, controller);
      		  CardList creats = new CardList();
  		  
      		  creats.addAll(play.getCards());
      		  creats = creats.getType("Creature");
      		  creats = creats.filter(new CardListFilter()
      		  {
				public boolean addCard(Card c) {
					return c.isUntapped();
				}
      		  });    		  
      		  
      		  CardList tappedCreats = new CardList();
      		  
      		  Object o = AllZone.Display.getChoice("Pick first creature to tap", creats.toArray());
      		  
      		  if (o!= null)
      		  {
      			  Card c1 = (Card)o;
      			  creats.remove(c1);     
      			  tappedCreats.add(c1);
      		  }
      		  else
      			  return;
      		  
      		  o = AllZone.Display.getChoice("Pick second creature to tap", creats.toArray());
      		  if (o!= null)
        	  {
      			  Card c2 = (Card)o;
      			  creats.remove(c2); 
      			  tappedCreats.add(c2);
        	  }	  
      		  else 
      			  return;
      		  
      		  o = AllZone.Display.getChoice("Pick third creature to tap", creats.toArray());
      		  if (o!= null)
        	  {
      			  Card c3 = (Card) o;
        		  creats.remove(c3); 
        		  tappedCreats.add(c3);
        	  }
      		  else 
      			  return;
      		  
      		  o = AllZone.Display.getChoice("Pick fourth creature to tap", creats.toArray());
    		  if (o!= null)
    		  {
    			  Card c4 = (Card) o;
    			  creats.remove(c4); 
    			  tappedCreats.add(c4);
    		  }
    		  else 
    			  return;
    		 
    		  
    		  for(int i = 0; i<tappedCreats.size(); i++)
    		  {
    			  Card tapCreat = tappedCreats.get(i);
    			  tapCreat.tap();
    		  }
    		  
    		  AllZone.GameAction.destroy(getTargetCard());    		  
          }//humanResolve
      	  
      	  public void computerResolve()
      	  {
    		  String controller = card.getController();
    		  PlayerZone play = AllZone.getZone(Constant.Zone.Play, controller);
    		  CardList creats = new CardList();
		  
    		  creats.addAll(play.getCards());
    		  creats = creats.getType("Creature");
    		  
    		      		  
    		  for (int i=0; i < 4; i++)
    		  {
    			  Card c = creats.get(i);
    			  c.tap();
    		  }
    		  
    		  AllZone.GameAction.destroy(getTargetCard());    		  

      	  }//computerResolve

        };//a1
        
        //card.clearSpellAbility();
        card.addSpellAbility(a1);
        a1.setDescription("Tap four untapped creatures you control: Destroy target artifact or enchantment.");
        
        Input runtime = new Input()
        {

		private static final long serialVersionUID = -7702308833923538927L;

		public void showMessage()
          {
            CardList all = new CardList();
            all.addAll(AllZone.Human_Play.getCards());
            all.addAll(AllZone.Computer_Play.getCards());
            all = all.filter(new CardListFilter()
            {
	  			public boolean addCard(Card c) {
	  				return (c.isEnchantment() || c.isArtifact()) && CardFactoryUtil.canTarget(card, c);
	  			}
            });
            
            stopSetNext(CardFactoryUtil.input_targetSpecific(a1, all, "Destroy target artifact or enchantment.", true));
          }
        };
        a1.setBeforePayMana(runtime);
    	
    }//*************** END ************ END **************************
    
    
    //*************** START *********** START **************************
    if(cardName.equals("Gilt-Leaf Archdruid"))
    {
    	final SpellAbility a1 = new Ability(card,"0")
        {
    	  public boolean canPlay()
    	  {
    		  String controller = card.getController();
    		  PlayerZone play = AllZone.getZone(Constant.Zone.Play, controller);
	  
    		  CardList druids = new CardList();
    		  
    		  druids.addAll(play.getCards());
    		  druids = druids.getType("Druid");
    		  
    		  //System.out.println("Druids size: " + druids.size());
    		  
    		  int druidsUntapped = 0;
    		  for (int i=0; i<druids.size();i++)
    		  {
    			  Card c = druids.get(0);
    			  if (!c.isTapped())
    				  druidsUntapped++;
    		  }
    		  
    		  if (druids.size() > 6 && druidsUntapped > 6 && AllZone.GameAction.isCardInPlay(card))
    			  return true;
    		  else
    			  return false;
    	  }
    	  public void resolve()
    	  {

            String player = card.getController();
            if(player.equals(Constant.Player.Human))
              humanResolve();
            else
              computerResolve();
          }
      	  public void humanResolve()
          {
      		  String controller = card.getController();
      		  PlayerZone play = AllZone.getZone(Constant.Zone.Play, controller);
      		  CardList druids = new CardList();
  		  
      		  druids.addAll(play.getCards());
      		  druids = druids.getType("Druid");
      		  
      		  CardList tappedDruids = new CardList();
      		  
      		  Object o = AllZone.Display.getChoice("Pick first druid to tap", druids.toArray());
      		  
      		  if (o!= null)
      		  {
      			  Card c1 = (Card)o;
      			  druids.remove(c1);     
      			  tappedDruids.add(c1);
      		  }
      		  else
      			  return;
      		  
      		  o = AllZone.Display.getChoice("Pick second druid to tap", druids.toArray());
      		  if (o!= null)
        	  {
      			  Card c2 = (Card)o;
      			  druids.remove(c2); 
      			  tappedDruids.add(c2);
        	  }	  
      		  else 
      			  return;
      		  
      		  o = AllZone.Display.getChoice("Pick third druid to tap", druids.toArray());
      		  if (o!= null)
        	  {
      			  Card c3 = (Card) o;
        		  druids.remove(c3); 
        		  tappedDruids.add(c3);
        	  }
      		  else 
      			  return;
      		  
      		  o = AllZone.Display.getChoice("Pick fourth druid to tap", druids.toArray());
    		  if (o!= null)
    		  {
    			  Card c4 = (Card) o;
    			  druids.remove(c4); 
    			  tappedDruids.add(c4);
    		  }
    		  else 
    			  return;
    		  o = AllZone.Display.getChoice("Pick fifth druid to tap", druids.toArray());
    		  if (o!= null)
    		  {
    			  Card c5 = (Card) o;
    			  druids.remove(c5);
    			  tappedDruids.add(c5);
    		  }
    		  else 
    			  return;
    		  
    		  o = AllZone.Display.getChoice("Pick sixth druid to tap", druids.toArray());
    		  if (o!= null)
    		  {
    			  Card c6 = (Card) o;
    			  druids.remove(c6);
    			  tappedDruids.add(c6);
    		  }
    		  else 
    			  return;
    		  
    		  o = AllZone.Display.getChoice("Pick seventh druid to tap", druids.toArray());
    		  if (o!=null)
    		  {
    			  Card c7 = (Card) o;
    			  druids.remove(c7); 
    			  tappedDruids.add(c7);
    		  }
    		  else 
    			  return;
    		  
    		  for(int i = 0; i<tappedDruids.size(); i++)
    		  {
    			  Card tapDruid = tappedDruids.get(i);
    			  tapDruid.tap();
    		  }
    		  
    		  String opponent = AllZone.GameAction.getOpponent(controller);
    		  PlayerZone opponentPlay = AllZone.getZone(Constant.Zone.Play, opponent);
    		  
    		  CardList lands = new CardList();
    		  lands.addAll(opponentPlay.getCards());
    		  lands = lands.getType("Land");
    		  
    		  //System.out.println("Land size: " +lands.size());
    		  
    		  for (int i = 0; i < lands.size(); i++)
    		  {
    			  Card land = lands.get(i);
    			  
    			  
    	          if(AllZone.GameAction.isCardInPlay(land))
    	          {
    	        	land.setController(controller);
    	        	
    	        	//set summoning sickness
    	      		if(land.getKeyword().contains("Haste")){
    	      		  land.setSickness(false);
    	      		}
    	      		else{
    	      		  land.setSickness(true);
    	      		}
    	        	  
    	            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
    	            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);

    	            PlayerZone from = AllZone.getZone(land);
    	            from.remove(land);

    	            PlayerZone to = AllZone.getZone(Constant.Zone.Play, card.getController());
    	            to.add(land);

    	            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
    	            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
    	          }//if
    			  
    			  
    		  }
      		  
          }//humanResolve
      	  
      	  public void computerResolve()
      	  {
    		  String controller = card.getController();
    		  PlayerZone play = AllZone.getZone(Constant.Zone.Play, controller);
    		  CardList druids = new CardList();
		  
    		  druids.addAll(play.getCards());
    		  druids = druids.getType("Druid");
    		  
    		      		  
    		  for (int i=0; i < 7; i++)
    		  {
    			  Card c = druids.get(i);
    			  c.tap();
    			  
    		  }
    		  
    		  String opponent = AllZone.GameAction.getOpponent(controller);
    		  PlayerZone opponentPlay = AllZone.getZone(Constant.Zone.Play, opponent);
    		  
    		  CardList lands = new CardList();
    		  lands.addAll(opponentPlay.getCards());
    		  lands = lands.getType("Land");
    		  
    		  for (int i = 0; i < lands.size(); i++)
    		  {
    			  Card land = lands.get(i);
    			  if(AllZone.GameAction.isCardInPlay(land))
    	          {
    	        	land.setController(controller);
    	        	
    	        	//set summoning sickness
    	      		if(land.getKeyword().contains("Haste")){
    	      		  land.setSickness(false);
    	      		}
    	      		else{
    	      		  land.setSickness(true);
    	      		}
    	        	  
    	            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(false);
    	            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(false);

    	            PlayerZone from = AllZone.getZone(land);
    	            from.remove(land);

    	            PlayerZone to = AllZone.getZone(Constant.Zone.Play, card.getController());
    	            to.add(land);

    	            ((PlayerZone_ComesIntoPlay)AllZone.Human_Play).setTriggers(true);
    	            ((PlayerZone_ComesIntoPlay)AllZone.Computer_Play).setTriggers(true);
    	          }//if
    		  }

      	  }//computerResolve

        };//a1
        
        card.clearSpellAbility();
        card.addSpellAbility(a1);
        a1.setStackDescription(card.getController() + " taps seven untapped Druids and gains control of all opponent's land.");
        a1.setDescription("Tap seven untapped Druids you control: Gain control of all lands target player controls.");
        card.addSpellAbility(new Spell_Permanent(card)
        {
		  private static final long serialVersionUID = -4621346281051305833L;

		  public boolean canPlayAI()
          {
            return true;
          }
        });
    	
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Mox Diamond"))
    {
    	final Input discard = new Input()
    	{
    			private static final long serialVersionUID = -1319202902385425204L;
				public void showMessage()
    			{
				    AllZone.Display.showMessage("Discard from your hand a land card");
				    ButtonUtil.enableOnlyCancel();
				}
				public void selectCard(Card c, PlayerZone zone)
				{
				    if(zone.is(Constant.Zone.Hand))
				    {
				    	AllZone.GameAction.discard(c);
				    	if(!c.isLand())
				    		AllZone.GameAction.sacrifice(card);
				    	stop();
				    }
				}
	    };//Input

	    final SpellAbility ability = new Ability(card, "0")
	    {
	    	public void resolve()
	    	{
	    		if(card.getController().equals(Constant.Player.Human))
	    		{
	    			if(AllZone.Human_Hand.getCards().length == 0)
	    				AllZone.GameAction.sacrifice(card);
	    			else
	    				AllZone.InputControl.setInput(discard);
	    		}
	    		else
	    		{
	    			CardList list = new CardList(AllZone.Computer_Hand.getCards());
	    			list = list.filter(new CardListFilter()
	    			{
	    				public boolean addCard(Card c)
	    				{
	    					return (c.isLand());
	    				}
	    			});
	    			AllZone.GameAction.discard(list.get(0));
	    		}//else
	    	}//resolve()
	    };//SpellAbility
	    Command intoPlay = new Command()
	    {
			private static final long serialVersionUID = -7679939432259603542L;

			public void execute()
	    	{
	    		ability.setStackDescription("If Mox Diamond would come into play, you may discard a land card instead. If you do, put Mox Diamond into play. If you don't, put it into its owner's graveyard.");
	    		AllZone.Stack.add(ability);
	    	}
	    };
	    SpellAbility spell = new Spell_Permanent(card)
	    {
			private static final long serialVersionUID = -1818766848857998431L;

			//could never get the AI to work correctly
		    //it always played the same card 2 or 3 times
	    	public boolean canPlayAI() {return false;}
	
	    	public boolean canPlay()
	    	{
	    		PlayerZone hand = AllZone.getZone(Constant.Zone.Hand, card.getController());
	    		CardList list = new CardList(hand.getCards());
	    		list.remove(card);
	    		list = list.filter(new CardListFilter()
	    		{
	    			public boolean addCard(Card c)
	    			{
	    				return (c.isLand());
	    			}
	    		});
	    		return list.size() != 0;
	    	}//canPlay()
	    };
	    card.addComesIntoPlayCommand(intoPlay);
	    card.clearSpellKeepManaAbility();
	    card.addSpellAbility(spell);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Standstill"))
    {
    	card.clearSpellAbility();
	    card.addSpellAbility(new Spell_Permanent(card)
	    {
		  private static final long serialVersionUID = 6912683989507840172L;

		  public boolean canPlayAI()
	      {
	    	  PlayerZone compPlay = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
	    	  PlayerZone humPlay = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
	    	  
	    	  CardList compCreats = new CardList(compPlay.getCards());
	    	  compCreats = compCreats.getType("Creature");
	    	  
	    	  CardList humCreats = new CardList(humPlay.getCards());
	    	  humCreats = humCreats.getType("Creature");
	    	  	    	  
	    	  //only play standstill if comp controls more creatures than human
	    	  //this needs some additional rules, maybe add all power + toughness and compare
	    	  if(compCreats.size() > humCreats.size())
	    		return true;
	    	  else 
	    		return false;
	      }
	    });
 	}//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Chameleon Colossus"))
    {
    	final int attack[] = new int[1];
        final int defense[] = new int[1];
        
        
        final Command untilEOT = new Command()
        {
		
		private static final long serialVersionUID = 861635058350850025L;

		public void execute()
          {
            if(AllZone.GameAction.isCardInPlay(card))
            {
              card.setTempAttackBoost(0);
              card.setTempDefenseBoost(0);
            }
          }
        };

        SpellAbility ability = new Ability_Activated(card, "2 G G")
        {	

			private static final long serialVersionUID = -4910313985049099384L;
			public boolean canPlayAI()
			{
              return CardFactoryUtil.AI_doesCreatureAttack(card);
			}
          public boolean canPlay()
          {
          	if (CardFactoryUtil.canUseAbility(card) && AllZone.GameAction.isCardInPlay(card) && 
          		!card.isFaceDown())
          		return true;
          	else 
          		return false;
          }
          public void resolve()
          {
            if(AllZone.GameAction.isCardInPlay(card))
            {
              attack[0] = card.getNetAttack();
              defense[0] = attack[0];
              
              card.addTempAttackBoost(attack[0]);
              card.addTempDefenseBoost(defense[0]);

              AllZone.EndOfTurn.addUntil(untilEOT);
            }
          }
        };
        

        ability.setDescription("2 G G : Chameleon Colossus gets +X/+X until end of turn, where X is its power." );
        ability.setStackDescription("Chameleon Colossus gets +X/+X until end of turn, where X is its power.");

        card.addSpellAbility(ability);
    
	}//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Figure of Destiny"))
    {
    	 Ability ability1 = new Ability(card, "RW")
 		{
 			public void resolve()
 			{
 				boolean artifact = false;
 				card.setBaseAttack(2);
 				card.setBaseDefense(2);
 				
 				card.removeIntrinsicKeyword("Flying");
 				card.removeIntrinsicKeyword("First Strike");
 				
 				if (card.isArtifact())
 					artifact = true;
 				
 				card.setType(new ArrayList<String>());
 				if (artifact)
 					card.addType("Artifact");
 				card.addType("Creature"); 
 				card.addType("Kithkin");
 				card.addType("Spirit");
 			}
 			
 			public boolean canPlayAI()
 			{
 				return !card.getType().contains("Spirit");
 			}
 			
 		};// ability1
 		
 		ability1.setDescription("RW: Figure of Destiny becomes a 2/2 Kithkin Spirit.");
 		ability1.setStackDescription("Figure of Destiny becomes a 2/2 Kithkin Spirit.");
 		card.addSpellAbility(ability1);
 		
 		
 		 Ability ability2 = new Ability(card, "RW RW RW")
  		{
  			public void resolve()
  			{
  				boolean artifact = false;
  				card.setBaseAttack(4);
  				card.setBaseDefense(4);
  				
  				card.removeIntrinsicKeyword("Flying");
  				card.removeIntrinsicKeyword("First Strike");
  				
  				if (card.isArtifact())
  					artifact = true;
  				
  				card.setType(new ArrayList<String>());
  				if (artifact)
  					card.addType("Artifact");
  				card.addType("Creature"); 
  				card.addType("Kithkin");
  				card.addType("Spirit");
  				card.addType("Warrior");
  			}
  			
  			public boolean canPlay()
  			{
  				return card.getType().contains("Spirit");
  			}
  			
  			public boolean canPlayAI()
  			{
  				return !card.getType().contains("Warrior");
  			}
  			
  		};// ability2
 		
  		ability2.setDescription("RW RW RW: If Figure of Destiny is a Spirit, it becomes a 4/4 Kithkin Spirit Warrior.");
 		ability2.setStackDescription("Figure of Destiny becomes a 4/4 Kithkin Spirit Warrior.");
 		card.addSpellAbility(ability2);
 		
 		
 		 Ability ability3 = new Ability(card, "RW RW RW RW RW RW")
   		{
   			public void resolve()
   			{
   				boolean artifact = false;
   				card.setBaseAttack(8);
   				card.setBaseDefense(8);
   				
   				card.addIntrinsicKeyword("Flying");
   				card.addIntrinsicKeyword("First Strike");
   				
   				if (card.isArtifact())
   					artifact = true;
   				
   				card.setType(new ArrayList<String>());
   				if (artifact)
   					card.addType("Artifact");
   				card.addType("Creature"); 
   				card.addType("Kithkin");
   				card.addType("Spirit");
   				card.addType("Warrior");
   				card.addType("Avatar");
   			}
   			public boolean canPlay()
   			{
   				return card.getType().contains("Warrior");
   			}
   			public boolean canPlayAI()
   			{
   				return !card.getType().contains("Avatar");
   			}
   		};// ability3
   		
   		ability3.setDescription("RW RW RW RW RW RW: If Figure of Destiny is a Warrior, it becomes an 8/8 Kithkin Spirit Warrior Avatar with flying and first strike. ");
   		ability3.setStackDescription("Figure of Destiny becomes an 8/8 Kithkin Spirit Warrior Avatar with flying and first strike.");
 		card.addSpellAbility(ability3);
    	
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if (cardName.equals("Jenara, Asura of War"))
    {
    
	    Ability ability2 = new Ability(card, "1 W")
		{
			public void resolve()
			{
				card.addCounter(Counters.P1P1, 1);
			}
		};// ability2
		
		ability2.setStackDescription(card.getName() + " - gets a +1/+1 counter.");
		card.addSpellAbility(ability2);
    }//*************** END ************ END **************************
   
    //*************** START *********** START **************************
    if (cardName.equals("Legacy Weapon"))
    {
    	final Ability ability = new Ability(card, "W U B R G")
    	{
    		public void resolve()
    		{
    			Card c = getTargetCard();
    			
    			if (AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, c))
    			{
    				AllZone.GameAction.removeFromGame(c);
    			}
    		}
    		
    		public void chooseTargetAI()
    		{
    			PlayerZone hplay = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
    			CardList human = new CardList(hplay.getCards());
    			human = human.filter(new CardListFilter()
    			{
    				public boolean addCard(Card c)
    				{
    					return CardFactoryUtil.canTarget(card, c);
    				}
    			});
    	    	
    			if (human.size() != 0)
    			{
    				setTargetCard(CardFactoryUtil.AI_getMostExpensivePermanent(human, card, true));
    			}
    		}
    		
    		public boolean canPlayAI()
    		{
    			PlayerZone hplay = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
    			CardList human = new CardList(hplay.getCards());
    			human = human.filter(new CardListFilter()
    			{
    				public boolean addCard(Card c)
    				{
    					return CardFactoryUtil.canTarget(card, c);
    				}
    			});
    			return human.size() > 0; 
    		}
    		
    	};//ability
    	
    	Input target = new Input()
    	{
			private static final long serialVersionUID = -7279903055386088569L;
			public void showMessage()
	      	{
	      	  AllZone.Display.showMessage("Select target permanent for " +ability.getSourceCard());
	      	  ButtonUtil.enableOnlyCancel();
	      	}
	      	public void selectButtonCancel() {stop();}
	      	public void selectCard(Card crd, PlayerZone zone)
	      	{
	      	  if(zone.is(Constant.Zone.Play) && CardFactoryUtil.canTarget(card, crd))
	      	  {
	      		ability.setTargetCard(crd);
	      		stopSetNext(new Input_PayManaCost(ability));
	      	  }
	      	}
        };//Input
    	
    	ability.setBeforePayMana(target);
    	card.addSpellAbility(ability);
    
  	}//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if (cardName.equals("Voltaic Key"))
    {
    	final Ability_Tap ability = new Ability_Tap(card, "1")
    	{
			private static final long serialVersionUID = 6097818373831898299L;
			public void resolve()
    		{
    			Card c = getTargetCard();
    			if (AllZone.GameAction.isCardInPlay(c) && CardFactoryUtil.canTarget(card, c) && c.isTapped())
    				c.untap();
    		}
    		public boolean canPlayAI()
    		{
    			return false;
    		}
    	};//ability
    	
    	Input target = new Input()
    	{
			private static final long serialVersionUID = -7279903055386088569L;
			public void showMessage()
	      	{
	      	  AllZone.Display.showMessage("Select target tapped artifact for " +ability.getSourceCard());
	      	  ButtonUtil.enableOnlyCancel();
	      	}
	      	public void selectButtonCancel() {stop();}
	      	public void selectCard(Card crd, PlayerZone zone)
	      	{
	      	  if(zone.is(Constant.Zone.Play) && CardFactoryUtil.canTarget(card, crd) && crd.isArtifact() && crd.isTapped())
	      	  {
	      		ability.setTargetCard(crd);
	      		stopSetNext(new Input_PayManaCost(ability));
	      	  }
	      	}
        };//Input
    	
    	ability.setBeforePayMana(target);
    	card.addSpellAbility(ability);
    
  	}//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Seething Song"))
    {
       final SpellAbility spell = new Spell(card)
       {
          private static final long serialVersionUID = 113811381138L;
          
          public void resolve()
          {
             CardList list = new CardList(AllZone.getZone(Constant.Zone.Play, Constant.Player.Human).getCards());
             list = list.getName("Mana Pool");
             Card mp = list.getCard(0);
             mp.addExtrinsicKeyword("ManaPool:R");
             mp.addExtrinsicKeyword("ManaPool:R");
             mp.addExtrinsicKeyword("ManaPool:R");
             mp.addExtrinsicKeyword("ManaPool:R");
             mp.addExtrinsicKeyword("ManaPool:R");
          }
          public boolean canPlayAI()
          {
             return false;
          }
       };
       
        spell.setStackDescription("Adds R R R R R to your mana pool");
       card.clearSpellAbility();
        card.addSpellAbility(spell);

        return card;
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Dark Ritual"))
    {
       final SpellAbility spell = new Spell(card)
       {

		private static final long serialVersionUID = -8579887529151755266L;
		public void resolve()
          {
             CardList list = new CardList(AllZone.getZone(Constant.Zone.Play, Constant.Player.Human).getCards());
             list = list.getName("Mana Pool");
             Card mp = list.getCard(0);
             mp.addExtrinsicKeyword("ManaPool:B");
             mp.addExtrinsicKeyword("ManaPool:B");
             mp.addExtrinsicKeyword("ManaPool:B");
          }
          public boolean canPlayAI()
          {
             return false;
          }
       };
       
       spell.setStackDescription(cardName + " adds B B B to your mana pool");
       card.clearSpellAbility();
       card.addSpellAbility(spell);

       return card;
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Black Lotus"))
    {
       final SpellAbility ability = new Ability_Tap(card)
       {
         private static final long serialVersionUID = 8394047173115959008L;

         public boolean canPlayAI(){return false;}
          
          public void resolve()
          {
             if (card.getController().equals(Constant.Player.Human))
             {
                    CardList list = new CardList(AllZone.getZone(Constant.Zone.Play, Constant.Player.Human).getCards());
                    list = list.getName("Mana Pool");
                    Card mp = list.getCard(0);

                    String color = new String();
                                        
                    Object o = AllZone.Display.getChoice("Choose mana color",Constant.Color.Colors);
                    color = (String)o;
                    
                    if (color.equals("white"))
                    	color = "W";
                    else if (color.equals("blue"))
                    	color = "U";
                    else if (color.equals("black"))
                    	color = "B";
                    else if (color.equals("red"))
                    	color = "R";
                    else if (color.equals("green"))
                    	color = "G";
                    else
                    	color = "1";
                    		
                    
                    //System.out.println("ManaPool:"+color+":");
                    for (int i = 0; i < 3; i++)
                    	mp.addExtrinsicKeyword("ManaPool:"+ color);
                   
                    AllZone.GameAction.sacrifice(card);
             }
          }
       };
       ability.setDescription("tap, Sacrifice Black Lotus: Add three mana of any one color to your mana pool.");
       ability.setStackDescription("Adds 3 mana of any one color to your mana pool");
       card.addSpellAbility(ability);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if (cardName.equals("Composite Golem"))
    {
       final Ability ability = new Ability(card, "0")
       {

    	 public boolean canPlay()
    	 {
    	   SpellAbility sa;
      	   for (int i=0; i<AllZone.Stack.size(); i++)
      	   {
      	    	     sa = AllZone.Stack.peek(i);
      	    	     if (sa.getSourceCard().equals(card))
      	    	          return false;
      	   }
      	   return AllZone.GameAction.isCardInPlay(card);
    	 }
         public boolean canPlayAI(){return false;}
          
          public void resolve()
          {
             if (card.getController().equals(Constant.Player.Human))
             {
                    CardList list = new CardList(AllZone.getZone(Constant.Zone.Play, Constant.Player.Human).getCards());
                    list = list.getName("Mana Pool");
                    Card mp = list.getCard(0);

                   	mp.addExtrinsicKeyword("ManaPool:W");
                	mp.addExtrinsicKeyword("ManaPool:U");
                	mp.addExtrinsicKeyword("ManaPool:B");
                	mp.addExtrinsicKeyword("ManaPool:R");
                	mp.addExtrinsicKeyword("ManaPool:G");
                   
                    AllZone.GameAction.sacrifice(card);
             }
          }
       };
       ability.setDescription("Sacrifice Composite Golem: Add W U B R G to your mana pool.");
       ability.setStackDescription("Add WUBRG your mana pool");
       card.addSpellAbility(ability);
    }//*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Gaea's Cradle"))
    {
       final SpellAbility ability = new Ability_Tap(card)
       {
    	   
		private static final long serialVersionUID = -1631970749273122485L;
		public void resolve()
          {
             CardList list = new CardList(AllZone.getZone(Constant.Zone.Play, Constant.Player.Human).getCards());
             list = list.getName("Mana Pool");
             Card mp = list.getCard(0);
             
             CardList creats = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
             creats = creats.getType("Creature");
             
             for(int i=0;i<creats.size();i++)
             {
            	 mp.addExtrinsicKeyword("ManaPool:G");
             }
          }
          public boolean canPlayAI()
          {
             return false;
          }
       };
       
       ability.setDescription("tap: Add G to your mana pool for each creature you control.");
       ability.setStackDescription(cardName + " adds G to your mana pool for each creature you control.");
       //card.clearSpellAbility();
       card.setText(card.getText() +  ability.toString());
       card.addSpellAbility(ability);

       return card;
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if (cardName.equals("Tolarian Academy"))
    {
       final SpellAbility ability = new Ability_Tap(card)
       {

		private static final long serialVersionUID = -9155272432379335551L;
		public void resolve()
          {
             CardList list = new CardList(AllZone.getZone(Constant.Zone.Play, Constant.Player.Human).getCards());
             list = list.getName("Mana Pool");
             Card mp = list.getCard(0);
             
             CardList arts = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
             arts = arts.getType("Artifact");
             
             for(int i=0;i<arts.size();i++)
             {
            	 mp.addExtrinsicKeyword("ManaPool:U");
             }
          }
          public boolean canPlayAI()
          {
             return false;
          }
       };
       
       ability.setDescription("tap: Add U to your mana pool for each artifact you control.");
       ability.setStackDescription(cardName + " adds U to your mana pool for each artifact you control.");
       //card.clearSpellAbility();
       card.setText(card.getText() +  ability.toString());
       card.addSpellAbility(ability);

       return card;
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if (cardName.equals("Serra's Sanctum"))
    {
       final SpellAbility ability = new Ability_Tap(card)
       {

		private static final long serialVersionUID = 6337899963974773375L;
		public void resolve()
          {
             CardList list = new CardList(AllZone.getZone(Constant.Zone.Play, Constant.Player.Human).getCards());
             list = list.getName("Mana Pool");
             Card mp = list.getCard(0);
             
             CardList ench = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
             ench = ench.getType("Enchantment");
             
             for(int i=0;i<ench.size();i++)
             {
            	 mp.addExtrinsicKeyword("ManaPool:W");
             }
          }
          public boolean canPlayAI()
          {
             return false;
          }
       };
       
       ability.setDescription("tap: Add W to your mana pool for each enchantment you control.");
       ability.setStackDescription(cardName + " adds W to your mana pool for each enchantment you control.");
       //card.clearSpellAbility();
       card.setText(card.getText() +  ability.toString());
       card.addSpellAbility(ability);

       return card;
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if (cardName.equals("Elvish Archdruid"))
    {
       final SpellAbility ability = new Ability_Tap(card)
       {
    	
		private static final long serialVersionUID = -7073759752440531772L;
		public void resolve()
          {
             CardList list = new CardList(AllZone.getZone(Constant.Zone.Play, Constant.Player.Human).getCards());
             list = list.getName("Mana Pool");
             Card mp = list.getCard(0);
             
             PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
             
             CardList creats = new CardList();
             creats.addAll(play.getCards());
             
             creats = creats.filter(new CardListFilter()
             {
            	public boolean addCard(Card c) 
            	{
            		return c.getType().contains("Elf") || c.getKeyword().contains("Changeling");
            	}
             });
             
             for(int i=0;i<creats.size();i++)
             {
            	 mp.addExtrinsicKeyword("ManaPool:G");
             }
          }
          public boolean canPlayAI()
          {
             return false;
          }
       };
       
       ability.setDescription("tap: add G to your mana pool for each Elf you control.");
       ability.setStackDescription(cardName + " adds G to your mana pool for each Elf you control.");
       //card.clearSpellAbility();
       card.addSpellAbility(ability);

       return card;
    }//*************** END ************ END **************************
    
    
    //*************** START *********** START **************************
    if (cardName.equals("Priest of Titania"))
    {
       final SpellAbility ability = new Ability_Tap(card)
       {
    	
		private static final long serialVersionUID = -9155272432379335551L;
		public void resolve()
          {
             CardList list = new CardList(AllZone.getZone(Constant.Zone.Play, Constant.Player.Human).getCards());
             list = list.getName("Mana Pool");
             Card mp = list.getCard(0);
             
             PlayerZone hum = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
             PlayerZone comp = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
             
             CardList creats = new CardList();
             creats.addAll(hum.getCards());
             creats.addAll(comp.getCards());
             
             creats = creats.filter(new CardListFilter()
             {
            	public boolean addCard(Card c) 
            	{
            		return c.getType().contains("Elf") || c.getKeyword().contains("Changeling");
            	}
             });
             
             for(int i=0;i<creats.size();i++)
             {
            	 mp.addExtrinsicKeyword("ManaPool:G");
             }
          }
          public boolean canPlayAI()
          {
             return false;
          }
       };
       
       ability.setDescription("tap: add G to your mana pool for each Elf in play.");
       ability.setStackDescription(cardName + " adds G to your mana pool for each Elf in play.");
       //card.clearSpellAbility();
       card.addSpellAbility(ability);

       return card;
    }//*************** END ************ END **************************
    
    
    //**************************Equipment*****************************
    
  //*************** START *********** START **************************
    if (cardName.equals("Lightning Greaves"))
    {
    	final Ability equip = new Ability(card, "0")
    	{
    		public void resolve()
    		{
    			if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
    			{
	    			if (card.isEquipping())
	    			{
	    				Card crd = card.getEquipping().get(0);
	    				if (crd.equals(getTargetCard()) )
	    					return;
	    				
	    				card.unEquipCard(crd);
	    			}	
	    			card.equipCard(getTargetCard());
    			}
    		}
    		
    		public boolean canPlay()
    		{
    			return AllZone.getZone(card).is(Constant.Zone.Play) &&            
                	   AllZone.Phase.getActivePlayer().equals(card.getController()) &&
                	   (AllZone.Phase.getPhase().equals("Main1") || AllZone.Phase.getPhase().equals("Main2") );
    		}
    		
    		public boolean canPlayAI()
            {
              return getCreature().size() != 0 && !card.isEquipping();
            }
    		
    		public void chooseTargetAI()
            {
              Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
              setTargetCard(target);
            }
            CardList getCreature()
            {
              CardList list = new CardList(AllZone.Computer_Play.getCards());
              list = list.filter(new CardListFilter()
              {
                public boolean addCard(Card c)
                {
                  return c.isCreature() && (!CardFactoryUtil.AI_doesCreatureAttack(c)) && CardFactoryUtil.canTarget(card, c) && 
                         (! c.getKeyword().contains("Haste")) && (! c.getKeyword().contains("Defender"));
                }
              });
              // list.remove(card);      // if mana-only cost, allow self-target
              return list;
            }//getCreature()
    		
    	};//equip ability
    	

    	Command onEquip = new Command()
	    {    
			private static final long serialVersionUID = 277714373478367657L;

			public void execute()
	        {
				if (card.isEquipping())
    			{
    				Card crd = card.getEquipping().get(0);
    				crd.addExtrinsicKeyword("Haste");
    				crd.addExtrinsicKeyword("Shroud");
    			}  
	        }//execute()
	    };//Command
	    

    	Command onUnEquip = new Command()
	    {    

			private static final long serialVersionUID = -3427116314295067303L;

			public void execute()
	        {
				if (card.isEquipping())
    			{
    				Card crd = card.getEquipping().get(0);
    				crd.removeExtrinsicKeyword("Haste");
    				crd.removeExtrinsicKeyword("Shroud");
    					
    			}
	          
	        }//execute()
	    };//Command
	    
    	
    	Input runtime = new Input()
        {

			private static final long serialVersionUID = 3195056500461797420L;

			public void showMessage()
	          {
	            //get all creatures you control
	            CardList list = new CardList();
	            list.addAll(AllZone.Human_Play.getCards());
	            list = list.getType("Creature");
	            
	            stopSetNext(CardFactoryUtil.input_targetSpecific(equip, list, "Select target creature to equip", true));
	          }
        };//Input
	    
    	equip.setBeforePayMana(runtime);
    	
    	equip.setDescription("Equip: 2");
    	card.addSpellAbility(equip);
    	
    	card.addEquipCommand(onEquip);
    	card.addUnEquipCommand(onUnEquip);

    } //*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if (cardName.equals("Loxodon Warhammer"))
    {
    	final Ability equip = new Ability(card, "3")
    	{
    		public void resolve()
    		{
    			if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
    			{
	    			if (card.isEquipping())
	    			{
	    				Card crd = card.getEquipping().get(0);
	    				if (crd.equals(getTargetCard()) )
	    					return;
	    				
	    				card.unEquipCard(crd);
	    			}	
	    			card.equipCard(getTargetCard());
    			}
    		}
    		
    		public boolean canPlay()
    		{
    			return AllZone.getZone(card).is(Constant.Zone.Play) &&            
                	   AllZone.Phase.getActivePlayer().equals(card.getController()) &&
                	   (AllZone.Phase.getPhase().equals("Main1") || AllZone.Phase.getPhase().equals("Main2") );
    		}
    		
    		public boolean canPlayAI()
            {
              return getCreature().size() != 0 && !card.isEquipping();
            }
			
    		
    		public void chooseTargetAI()
            {
              Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
              setTargetCard(target);
            }
            CardList getCreature()
            {
              CardList list = new CardList(AllZone.Computer_Play.getCards());
              list = list.filter(new CardListFilter()
              {
                public boolean addCard(Card c)
                {
                  return c.isCreature() && (!CardFactoryUtil.AI_doesCreatureAttack(c)) && CardFactoryUtil.canTarget(card, c) && 
                         (! c.getKeyword().contains("Defender"));
                }
              });
              // list.remove(card);      // if mana-only cost, allow self-target
              return list;
            }//getCreature()
    		
    	};//equip ability
    	

    	Command onEquip = new Command()
	    {    

			private static final long serialVersionUID = 8130682765214560887L;

			public void execute()
	        {
				if (card.isEquipping())
    			{
    				Card crd = card.getEquipping().get(0);
    				crd.addExtrinsicKeyword("Trample");
    				crd.addExtrinsicKeyword("Lifelink");
    				crd.addSemiPermanentAttackBoost(3);
    			}  
	        }//execute()
	    };//Command
	    

    	Command onUnEquip = new Command()
	    {    

			private static final long serialVersionUID = 5783423127748320501L;

			public void execute()
	        {
				if (card.isEquipping())
    			{
    				Card crd = card.getEquipping().get(0);
    				crd.removeExtrinsicKeyword("Trample");
    				crd.removeExtrinsicKeyword("Lifelink");
    				crd.addSemiPermanentAttackBoost(-3);
    					
    			}
	          
	        }//execute()
	    };//Command
	    
    	
    	Input runtime = new Input()
    	{
			private static final long serialVersionUID = -6785656229070523470L;

			public void showMessage()
	          {
	            //get all creatures you control
	            CardList list = new CardList();
	            list.addAll(AllZone.Human_Play.getCards());
	            list = list.getType("Creature");
	            
	            stopSetNext(CardFactoryUtil.input_targetSpecific(equip, list, "Select target creature to equip", true));
	          }
        };//Input
	    
    	equip.setBeforePayMana(runtime);
    	
    	equip.setDescription("Equip: 3");
    	card.addSpellAbility(equip);
    	
    	card.addEquipCommand(onEquip);
    	card.addUnEquipCommand(onUnEquip);

    } //*************** END ************ END **************************
    
    
    //*************** START *********** START **************************
    if (cardName.equals("Behemoth Sledge"))
    {
    	final Ability equip = new Ability(card, "3")
    	{
    		public void resolve()
    		{
    			if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
    			{
	    			if (card.isEquipping())
	    			{
	    				Card crd = card.getEquipping().get(0);
	    				if (crd.equals(getTargetCard()) )
	    					return;
	    				
	    				card.unEquipCard(crd);
	    			}	
	    			card.equipCard(getTargetCard());
    			}
    		}
    		
    		public boolean canPlay()
    		{
    			return AllZone.getZone(card).is(Constant.Zone.Play) &&            
                	   AllZone.Phase.getActivePlayer().equals(card.getController()) &&
                	   (AllZone.Phase.getPhase().equals("Main1") || AllZone.Phase.getPhase().equals("Main2") );
    		}
    		
    		public boolean canPlayAI()
            {
              return getCreature().size() != 0 && !card.isEquipping();
            }
    		
    		public void chooseTargetAI()
            {
              Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
              setTargetCard(target);
            }
            CardList getCreature()
            {
              CardList list = new CardList(AllZone.Computer_Play.getCards());
              list = list.filter(new CardListFilter()
              {
                public boolean addCard(Card c)
                {
                  return c.isCreature() && (!CardFactoryUtil.AI_doesCreatureAttack(c)) && CardFactoryUtil.canTarget(card, c) && 
                  (! c.getKeyword().contains("Defender"));
                }
              });
              return list;
            }//getCreature()
    		
    	};//equip ability
    	

    	Command onEquip = new Command()
	    {    

			private static final long serialVersionUID = 8130682765214560887L;

			public void execute()
	        {
				if (card.isEquipping())
    			{
    				Card crd = card.getEquipping().get(0);
    				crd.addExtrinsicKeyword("Lifelink");
    				crd.addExtrinsicKeyword("Trample");
    				crd.addSemiPermanentAttackBoost(2);
    				crd.addSemiPermanentDefenseBoost(2);
    			}  
	        }//execute()
	    };//Command
	    

    	Command onUnEquip = new Command()
	    {    

			private static final long serialVersionUID = 5783423127748320501L;

			public void execute()
	        {
				if (card.isEquipping())
    			{
    				Card crd = card.getEquipping().get(0);
    				crd.removeExtrinsicKeyword("Lifelink");
    				crd.removeExtrinsicKeyword("Trample");
    				crd.addSemiPermanentAttackBoost(-2);
    				crd.addSemiPermanentDefenseBoost(-2);
    					
    			}
	          
	        }//execute()
	    };//Command
	    
    	
    	Input runtime = new Input()
    	{
			private static final long serialVersionUID = -6785656229070523470L;

			public void showMessage()
	          {
	            //get all creatures you control
	            CardList list = new CardList();
	            list.addAll(AllZone.Human_Play.getCards());
	            list = list.getType("Creature");
	            
	            stopSetNext(CardFactoryUtil.input_targetSpecific(equip, list, "Select target creature to equip", true));
	          }
        };//Input
	    
    	equip.setBeforePayMana(runtime);
    	
    	equip.setDescription("Equip: 3");
    	card.addSpellAbility(equip);
    	
    	card.addEquipCommand(onEquip);
    	card.addUnEquipCommand(onUnEquip);

    } //*************** END ************ END **************************
    
    
    //*************** START *********** START **************************
    if (cardName.equals("Fireshrieker"))
    {
    	final Ability equip = new Ability(card, "2")
    	{
    		public void resolve()
    		{
    			if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
    			{
	    			if (card.isEquipping())
	    			{
	    				Card crd = card.getEquipping().get(0);
	    				if (crd.equals(getTargetCard()) )
	    					return;
	    				
	    				card.unEquipCard(crd);
	    			}	
	    			card.equipCard(getTargetCard());
    			}
    		}
    		
    		public boolean canPlay()
    		{
    			return AllZone.getZone(card).is(Constant.Zone.Play) &&            
                	   AllZone.Phase.getActivePlayer().equals(card.getController()) &&
                	   (AllZone.Phase.getPhase().equals("Main1") || AllZone.Phase.getPhase().equals("Main2") );
    		}
    		
    		public boolean canPlayAI()
            {
              return getCreature().size() != 0 && !card.isEquipping();
            }
    		
    		public void chooseTargetAI()
            {
              Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
              setTargetCard(target);
            }
            CardList getCreature()
            {
              CardList list = new CardList(AllZone.Computer_Play.getCards());
              list = list.filter(new CardListFilter()
              {
                public boolean addCard(Card c)
                {
                  return c.isCreature() && (!CardFactoryUtil.AI_doesCreatureAttack(c)) && CardFactoryUtil.canTarget(card, c) && 
                  (!c.getKeyword().contains("Double Strike") )&& (! c.getKeyword().contains("Defender"));
                }
              });
              return list;
            }//getCreature()
    		
    	};//equip ability
    	

    	Command onEquip = new Command()
	    {    

			private static final long serialVersionUID = 277714373478367657L;

			public void execute()
	        {
				if (card.isEquipping())
    			{
    				Card crd = card.getEquipping().get(0);
    				crd.addExtrinsicKeyword("Double Strike");
    			}  
	        }//execute()
	    };//Command
	    

    	Command onUnEquip = new Command()
	    {    

			private static final long serialVersionUID = -3427116314295067303L;

			public void execute()
	        {
				if (card.isEquipping())
    			{
    				Card crd = card.getEquipping().get(0);
    				crd.removeExtrinsicKeyword("Double Strike");
    					
    			}
	          
	        }//execute()
	    };//Command
	    
    	
    	Input runtime = new Input()
        {
			private static final long serialVersionUID = 3195056500461797420L;

			public void showMessage()
	          {
	            //get all creatures you control
	            CardList list = new CardList();
	            list.addAll(AllZone.Human_Play.getCards());
	            list = list.getType("Creature");
	            
	            stopSetNext(CardFactoryUtil.input_targetSpecific(equip, list, "Select target creature to equip", true));
	          }
        };//Input
	    
    	equip.setBeforePayMana(runtime);
    	
    	equip.setDescription("Equip: 2");
    	card.addSpellAbility(equip);
    	
    	card.addEquipCommand(onEquip);
    	card.addUnEquipCommand(onUnEquip);

    } //*************** END ************ END **************************
    
    
    //*************** START *********** START **************************
    if (cardName.equals("Skullclamp"))
    {
    	final Ability equip = new Ability(card, "1")
    	{
    		public void resolve()
    		{
    			if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
    			{
	    			if (card.isEquipping())
	    			{
	    				Card crd = card.getEquipping().get(0);
	    				if (crd.equals(getTargetCard()) )
	    					return;
	    				
	    				card.unEquipCard(crd);
	    			}	
	    			card.equipCard(getTargetCard());
    			}
    		}
    		
    		public boolean canPlay()
    		{
    			return AllZone.getZone(card).is(Constant.Zone.Play) &&            
                	   AllZone.Phase.getActivePlayer().equals(card.getController()) &&
                	   (AllZone.Phase.getPhase().equals("Main1") || AllZone.Phase.getPhase().equals("Main2") );
    		}

    		public boolean canPlayAI()
            {
              return getCreature().size() != 0 && !card.isEquipping();
            }
    		
    		public void chooseTargetAI()
            {
              Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
              setTargetCard(target);
            }
            CardList getCreature()
            {
              CardList list = new CardList(AllZone.Computer_Play.getCards());
              list = list.filter(new CardListFilter()
              {
                public boolean addCard(Card c)
                {
                  return c.isCreature() && (!CardFactoryUtil.AI_doesCreatureAttack(c)) && CardFactoryUtil.canTarget(card, c) && 
                  (! c.getKeyword().contains("Defender"));
                }
              });
              return list;
            }//getCreature()
    		
    	};//equip ability
    	

    	Command onEquip = new Command()
	    {    
			private static final long serialVersionUID = 277714373478367657L;

			public void execute()
	        {
				if (card.isEquipping())
    			{
    				Card crd = card.getEquipping().get(0);

    				crd.addSemiPermanentAttackBoost(1);
    				crd.addSemiPermanentDefenseBoost(-1);
    			}  
	        }//execute()
	    };//Command
	    

    	Command onUnEquip = new Command()
	    {    

			private static final long serialVersionUID = 6496501799243208207L;

			public void execute()
	        {
				if (card.isEquipping())
    			{
    				Card crd = card.getEquipping().get(0);
    				
    				crd.addSemiPermanentAttackBoost(-1);
    				crd.addSemiPermanentDefenseBoost(1);
    			}
	          
	        }//execute()
	    };//Command
	    
    	
    	Input runtime = new Input()
        {
			private static final long serialVersionUID = -5844375382897176476L;

			public void showMessage()
	          {
	            //get all creatures you control
	            CardList list = new CardList();
	            list.addAll(AllZone.Human_Play.getCards());
	            list = list.getType("Creature");
	            
	            stopSetNext(CardFactoryUtil.input_targetSpecific(equip, list, "Select target creature to equip", true));
	          }
        };//Input
	    
    	equip.setBeforePayMana(runtime);
    	
    	equip.setDescription("Equip: 1");
    	card.addSpellAbility(equip);
    	
    	card.addEquipCommand(onEquip);
    	card.addUnEquipCommand(onUnEquip);

    } //*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Bonesplitter"))
    {
    	final Ability equip = new Ability(card, "1")
    	{
    		public void resolve()
    		{
    			if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
    			{
	    			if (card.isEquipping())
	    			{
	    				Card crd = card.getEquipping().get(0);
	    				if (crd.equals(getTargetCard()) )
	    					return;
	    				
	    				card.unEquipCard(crd);
	    			}
    			
	    			card.equipCard(getTargetCard());
    			}
    		}
    		
    		public boolean canPlay()
    		{
    			return AllZone.getZone(card).is(Constant.Zone.Play) &&            
                	   AllZone.Phase.getActivePlayer().equals(card.getController()) &&
                	   (AllZone.Phase.getPhase().equals("Main1") || AllZone.Phase.getPhase().equals("Main2") );
    		}

    		public boolean canPlayAI()
            {
              return getCreature().size() != 0 && !card.isEquipping();
            }
    		
    		public void chooseTargetAI()
            {
              Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
              setTargetCard(target);
            }
            CardList getCreature()
            {
              CardList list = new CardList(AllZone.Computer_Play.getCards());
              list = list.filter(new CardListFilter()
              {
                public boolean addCard(Card c)
                {
                  return c.isCreature() && (!CardFactoryUtil.AI_doesCreatureAttack(c)) && CardFactoryUtil.canTarget(card, c) && 
                  (! c.getKeyword().contains("Defender"));
                }
              });
              return list;
            }//getCreature()
    		
    	};//equip ability
    	

    	Command onEquip = new Command()
	    {    
			private static final long serialVersionUID = -6930553087037330743L;

			public void execute()
	        {
				if (card.isEquipping())
    			{
    				Card crd = card.getEquipping().get(0);
    				crd.addSemiPermanentAttackBoost(2);
    			}
	          
	        }//execute()
	    };//Command
	    

    	Command onUnEquip = new Command()
	    {    
			private static final long serialVersionUID = -3427116314295067303L;

			public void execute()
	        {
				if (card.isEquipping())
    			{
    				Card crd = card.getEquipping().get(0);
    				crd.addSemiPermanentAttackBoost(-2);
    			}
	          
	        }//execute()
	    };//Command
    	
	    Input runtime = new Input()
        {
			private static final long serialVersionUID = 5184756493874218024L;

			public void showMessage()
	          {
	            //get all creatures you control
	            CardList list = new CardList();
	            list.addAll(AllZone.Human_Play.getCards());
	            list = list.getType("Creature");
	            
	            stopSetNext(CardFactoryUtil.input_targetSpecific(equip, list, "Select target creature to equip", true));
	          }
        };//Input
	    
    	equip.setBeforePayMana(runtime);
    	
    	equip.setDescription("Equip: 1");
    	card.addSpellAbility(equip);
    	
    	card.addEquipCommand(onEquip);
    	card.addUnEquipCommand(onUnEquip);
    } //*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if (cardName.equals("Trailblazer's Boots"))
    {
       final Ability equip = new Ability(card, "2")
       {
          public void resolve()
          {
             if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
             {
                if (card.isEquipping())
                {
                   Card crd = card.getEquipping().get(0);
                   if (crd.equals(getTargetCard()) )
                      return;
                   
                   card.unEquipCard(crd);
                }   
                card.equipCard(getTargetCard());
             }
          }
          
          public boolean canPlay()
  		  {
  			return AllZone.getZone(card).is(Constant.Zone.Play) &&            
              	   AllZone.Phase.getActivePlayer().equals(card.getController()) &&
              	   (AllZone.Phase.getPhase().equals("Main1") || AllZone.Phase.getPhase().equals("Main2") );
  		  }
          
          public boolean canPlayAI()
            {
              return getCreature().size() != 0 && !card.isEquipping();
            }
         
          
          public void chooseTargetAI()
            {
              Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
              setTargetCard(target);
            }
            CardList getCreature()
            {
              CardList list = new CardList(AllZone.Computer_Play.getCards());
              list = list.filter(new CardListFilter()
              {
                public boolean addCard(Card c)
                {
                  return c.isCreature() && (!CardFactoryUtil.AI_doesCreatureAttack(c)) && CardFactoryUtil.canTarget(card, c) &&
                         (! c.getKeyword().contains("Defender"));
                }
              });
              // list.remove(card);      // if mana-only cost, allow self-target
              return list;
            }//getCreature()
          
       };//equip ability
       

       Command onEquip = new Command()
       {   

		private static final long serialVersionUID = -8783427230086868847L;

		public void execute()
           {
            if (card.isEquipping())
             {
                Card crd = card.getEquipping().get(0);
                crd.addExtrinsicKeyword("Nonbasic landwalk");
             } 
           }//execute()
       };//Command
      

       Command onUnEquip = new Command()
       {   

		private static final long serialVersionUID = 732383503612045113L;

		public void execute()
           {
            if (card.isEquipping())
             {
                Card crd = card.getEquipping().get(0);
                crd.removeExtrinsicKeyword("Nonbasic landwalk");
             }
            
           }//execute()
       };//Command
      
       
       Input runtime = new Input()
       {
    	   
		private static final long serialVersionUID = -696882688005519805L;

		public void showMessage()
             {
               //get all creatures you control
               CardList list = new CardList();
               list.addAll(AllZone.Human_Play.getCards());
               list = list.getType("Creature");
              
               stopSetNext(CardFactoryUtil.input_targetSpecific(equip, list, "Select target creature to equip", true));
             }
        };//Input
      
       equip.setBeforePayMana(runtime);
       
       equip.setDescription("Equip: 2");
       card.addSpellAbility(equip);
       
       card.addEquipCommand(onEquip);
       card.addUnEquipCommand(onUnEquip);

    } //*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Blight Sickle"))
    {
       final Ability equip = new Ability(card, "2")
       {
          public void resolve()
          {
             if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
             {
                if (card.isEquipping())
                {
                   Card crd = card.getEquipping().get(0);
                   if (crd.equals(getTargetCard()) )
                      return;
                   
                   card.unEquipCard(crd);
                }   
                card.equipCard(getTargetCard());
             }
          }
          
          public boolean canPlay()
  		  {
  			return AllZone.getZone(card).is(Constant.Zone.Play) &&            
              	   AllZone.Phase.getActivePlayer().equals(card.getController()) &&
              	   (AllZone.Phase.getPhase().equals("Main1") || AllZone.Phase.getPhase().equals("Main2") );
  		  }
          
          public boolean canPlayAI()
            {
              return getCreature().size() != 0 && !card.isEquipping();
            }
         
          
          public void chooseTargetAI()
            {
              Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
              setTargetCard(target);
            }
            CardList getCreature()
            {
              CardList list = new CardList(AllZone.Computer_Play.getCards());
              list = list.filter(new CardListFilter()
              {
                public boolean addCard(Card c)
                {
                  return c.isCreature() && (!CardFactoryUtil.AI_doesCreatureAttack(c)) && CardFactoryUtil.canTarget(card, c) &&
                         (! c.getKeyword().contains("Defender"));
                }
              });
              // list.remove(card);      // if mana-only cost, allow self-target
              return list;
            }//getCreature()
          
       };//equip ability
       

       Command onEquip = new Command()
       {   

         private static final long serialVersionUID = 8130682765214560887L;

         public void execute()
           {
            if (card.isEquipping())
             {
                Card crd = card.getEquipping().get(0);
                crd.addExtrinsicKeyword("Wither");
                crd.addSemiPermanentAttackBoost(1);
             } 
           }//execute()
       };//Command
      

       Command onUnEquip = new Command()
       {   

         private static final long serialVersionUID = 5783423127748320501L;

         public void execute()
           {
            if (card.isEquipping())
             {
                Card crd = card.getEquipping().get(0);
                crd.removeExtrinsicKeyword("Wither");
                crd.addSemiPermanentAttackBoost(-1);
                   
             }
            
           }//execute()
       };//Command
      
       
       Input runtime = new Input()
       {
         
		private static final long serialVersionUID = -8564484340029497370L;

		public void showMessage()
             {
               //get all creatures you control
               CardList list = new CardList();
               list.addAll(AllZone.Human_Play.getCards());
               list = list.getType("Creature");
              
               stopSetNext(CardFactoryUtil.input_targetSpecific(equip, list, "Select target creature to equip", true));
             }
        };//Input
      
       equip.setBeforePayMana(runtime);
       
       equip.setDescription("Equip: 2");
       card.addSpellAbility(equip);
       
       card.addEquipCommand(onEquip);
       card.addUnEquipCommand(onUnEquip);

    } //*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Spidersilk Net"))
    {
       final Ability equip = new Ability(card, "2")
       {
          public void resolve()
          {
             if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
             {
                if (card.isEquipping())
                {
                   Card crd = card.getEquipping().get(0);
                   if (crd.equals(getTargetCard()) )
                      return;
                   
                   card.unEquipCard(crd);
                }   
                card.equipCard(getTargetCard());
             }
          }
          
          public boolean canPlay()
          {
             return AllZone.getZone(card).is(Constant.Zone.Play) &&           
                      AllZone.Phase.getActivePlayer().equals(card.getController()) &&
                      (AllZone.Phase.getPhase().equals("Main1") || AllZone.Phase.getPhase().equals("Main2") );
          }
          
          public boolean canPlayAI()
            {
              return getCreature().size() != 0 && !card.isEquipping();
            }
         
          
          public void chooseTargetAI()
            {
              Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
              setTargetCard(target);
            }
            CardList getCreature()
            {
              CardList list = new CardList(AllZone.Computer_Play.getCards());
              list = list.filter(new CardListFilter()
              {
                public boolean addCard(Card c)
                {
                  return c.isCreature() && (!CardFactoryUtil.AI_doesCreatureAttack(c)) && CardFactoryUtil.canTarget(card, c) &&
                         (! c.getKeyword().contains("Flying") || !c.getKeyword().contains("Reach"));
                }
              });
              // list.remove(card);      // if mana-only cost, allow self-target
              return list;
            }//getCreature()
          
       };//equip ability
       

       Command onEquip = new Command()
       {   

		private static final long serialVersionUID = -5830699867070741036L;

		public void execute()
           {
            if (card.isEquipping())
             {
                Card crd = card.getEquipping().get(0);
                crd.addExtrinsicKeyword("Reach");
                crd.addSemiPermanentDefenseBoost(2);
             } 
           }//execute()
       };//Command
      

       Command onUnEquip = new Command()
       {   

		private static final long serialVersionUID = -4098923908462881875L;

		public void execute()
           {
            if (card.isEquipping())
             {
                Card crd = card.getEquipping().get(0);
                crd.removeExtrinsicKeyword("Reach");
                crd.addSemiPermanentDefenseBoost(-2);
                   
             }
            
           }//execute()
       };//Command
      
       
       Input runtime = new Input()
       {

			private static final long serialVersionUID = 5068745895084312024L;
	
			public void showMessage()
	        {
	               //get all creatures you control
	               CardList list = new CardList();
	               list.addAll(AllZone.Human_Play.getCards());
	               list = list.getType("Creature");
	              
	               stopSetNext(CardFactoryUtil.input_targetSpecific(equip, list, "Select target creature to equip", true));
	        }
        };//Input
      
       equip.setBeforePayMana(runtime);
       
       equip.setDescription("Equip: 2");
       card.addSpellAbility(equip);
       
       card.addEquipCommand(onEquip);
       card.addUnEquipCommand(onUnEquip);

    } //*************** END ************ END **************************

    
  //*************** START *********** START **************************
    if (cardName.equals("Whispersilk Cloak"))
    {
       final Ability equip = new Ability(card, "2")
       {
          public void resolve()
          {
             if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
             {
                if (card.isEquipping())
                {
                   Card crd = card.getEquipping().get(0);
                   if (crd.equals(getTargetCard()) )
                      return;
                   
                   card.unEquipCard(crd);
                }   
                card.equipCard(getTargetCard());
             }
          }
          
          public boolean canPlay()
          {
             return AllZone.getZone(card).is(Constant.Zone.Play) &&           
                      AllZone.Phase.getActivePlayer().equals(card.getController()) &&
                      (AllZone.Phase.getPhase().equals("Main1") || AllZone.Phase.getPhase().equals("Main2") );
          }
          
          public boolean canPlayAI()
            {
              return getCreature().size() != 0 && !card.isEquipping();
            }
         
          
          public void chooseTargetAI()
            {
              Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
              setTargetCard(target);
            }
            CardList getCreature()
            {
              CardList list = new CardList(AllZone.Computer_Play.getCards());
              list = list.filter(new CardListFilter()
              {
                public boolean addCard(Card c)
                {
                  return c.isCreature() && (!CardFactoryUtil.AI_doesCreatureAttack(c)) && CardFactoryUtil.canTarget(card, c) &&
                         (! c.getKeyword().contains("Defender"));
                }
              });
              // list.remove(card);      // if mana-only cost, allow self-target
              return list;
            }//getCreature()
          
       };//equip ability
       

       Command onEquip = new Command()
       {   

		private static final long serialVersionUID = -1829389094046225543L;

		public void execute()
           {
            if (card.isEquipping())
             {
                Card crd = card.getEquipping().get(0);
                crd.addExtrinsicKeyword("Unblockable");
                crd.addExtrinsicKeyword("Shroud");
                
             } 
           }//execute()
       };//Command
      

       Command onUnEquip = new Command()
       {   

		private static final long serialVersionUID = 110426811459225458L;

		public void execute()
           {
            if (card.isEquipping())
             {
                Card crd = card.getEquipping().get(0);
                crd.removeExtrinsicKeyword("Unblockable");
                crd.removeExtrinsicKeyword("Shroud");
             }
            
           }//execute()
       };//Command
      
       
       Input runtime = new Input()
       {
         
		private static final long serialVersionUID = 2399248271613089612L;

		public void showMessage()
             {
               //get all creatures you control
               CardList list = new CardList();
               list.addAll(AllZone.Human_Play.getCards());
               list = list.getType("Creature");
              
               stopSetNext(CardFactoryUtil.input_targetSpecific(equip, list, "Select target creature to equip", true));
             }
        };//Input
      
       equip.setBeforePayMana(runtime);
       
       equip.setDescription("Equip: 2");
       card.addSpellAbility(equip);
       
       card.addEquipCommand(onEquip);
       card.addUnEquipCommand(onUnEquip);

    } //*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if (cardName.equals("Trusty Machete"))
    {
       final Ability equip = new Ability(card, "2")
       {
          public void resolve()
          {
             if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
             {
                if (card.isEquipping())
                {
                   Card crd = card.getEquipping().get(0);
                   if (crd.equals(getTargetCard()) )
                      return;
                   
                   card.unEquipCard(crd);
                }   
                card.equipCard(getTargetCard());
             }
          }
          
          public boolean canPlay()
  		  {
  			return AllZone.getZone(card).is(Constant.Zone.Play) &&            
              	   AllZone.Phase.getActivePlayer().equals(card.getController()) &&
              	   (AllZone.Phase.getPhase().equals("Main1") || AllZone.Phase.getPhase().equals("Main2") );
  		  }
          
          public boolean canPlayAI()
            {
              return getCreature().size() != 0 && !card.isEquipping();
            }
         
          
          public void chooseTargetAI()
            {
              Card target = CardFactoryUtil.AI_getBestCreature(getCreature());
              setTargetCard(target);
            }
            CardList getCreature()
            {
              CardList list = new CardList(AllZone.Computer_Play.getCards());
              list = list.filter(new CardListFilter()
              {
                public boolean addCard(Card c)
                {
                  return c.isCreature() && (!CardFactoryUtil.AI_doesCreatureAttack(c)) && CardFactoryUtil.canTarget(card, c) &&
                         (! c.getKeyword().contains("Defender"));
                }
              });
              // list.remove(card);      // if mana-only cost, allow self-target
              return list;
            }//getCreature()
          
       };//equip ability
       

       Command onEquip = new Command()
       {   

		private static final long serialVersionUID = -6434466688054628650L;

		public void execute()
           {
            if (card.isEquipping())
             {
                Card crd = card.getEquipping().get(0);
                crd.addSemiPermanentAttackBoost(2);
                crd.addSemiPermanentDefenseBoost(1);
             } 
           }//execute()
       };//Command
      

       Command onUnEquip = new Command()
       {   

		private static final long serialVersionUID = -5297369538913528146L;

		public void execute()
           {
            if (card.isEquipping())
             {
                Card crd = card.getEquipping().get(0);
                crd.addSemiPermanentAttackBoost(-2);
                crd.addSemiPermanentDefenseBoost(-1);
                   
             }
            
           }//execute()
       };//Command
      
       
       Input runtime = new Input()
       {
		private static final long serialVersionUID = -1425693231661483469L;

		public void showMessage()
             {
               //get all creatures you control
               CardList list = new CardList();
               list.addAll(AllZone.Human_Play.getCards());
               list = list.getType("Creature");
              
               stopSetNext(CardFactoryUtil.input_targetSpecific(equip, list, "Select target creature to equip", true));
             }
        };//Input
      
       equip.setBeforePayMana(runtime);
       
       equip.setDescription("Equip: 2");
       card.addSpellAbility(equip);
       
       card.addEquipCommand(onEquip);
       card.addUnEquipCommand(onUnEquip);

    } //*************** END ************ END **************************
    
    //*************** START *********** START **************************
    if (cardName.equals("Umbral Mantle"))
    {
       final Ability equip = new Ability(card, "0")
       {
          public void resolve()
          {
             if (AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()) )
             {
                if (card.isEquipping())
                {
                   Card crd = card.getEquipping().get(0);
                   if (crd.equals(getTargetCard()) )
                      return;
                   
                   card.unEquipCard(crd);
                }
             
                card.equipCard(getTargetCard());
             }
          }
          
          public boolean canPlay()
          {
             return AllZone.getZone(card).is(Constant.Zone.Play) &&           
                      AllZone.Phase.getActivePlayer().equals(card.getController()) &&
                      !AllZone.Phase.getPhase().equals("End of Turn") &&
                   !AllZone.Phase.getPhase().equals(Constant.Phase.Combat_Declare_Blockers_InstantAbility);
          }
          

          public boolean canPlayAI()
            {
              return false;
            }
       };//equip ability

       equip.setType("Extrinsic");
       
       final Ability untapboost = new Ability (card, "3")
      {
          public void resolve(){
            getSourceCard().addTempAttackBoost(2);
            getSourceCard().addTempDefenseBoost(2);
            getSourceCard().untap();
         }
         public boolean canPlay(){return (getSourceCard().isTapped() && !getSourceCard().hasSickness() && super.canPlay());}
      };//equiped creature's ability
      
       Command onEquip = new Command()
       {   
         private static final long serialVersionUID = 1L;

         public void execute()
           {
            if (card.isEquipping())
             {
               Card crd=card.getEquipping().get(0);
               untapboost.setDescription("3, Untap:"+crd+" gets +2/+2 until end of turn");
                untapboost.setStackDescription(crd+ " - +2/+2 until EOT");
               
               crd.addSpellAbility(untapboost);
             }
           }//execute()
       };//Command
      

       Command onUnEquip = new Command()
       {   
         private static final long serialVersionUID = -3427116314295067303L;

         public void execute()
           {
            if (card.isEquipping())
             {
                Card crd = card.getEquipping().get(0);
                crd.removeSpellAbility(untapboost);
             }
            
           }//execute()
       };//Command
       
       equip.setBeforePayMana(CardFactoryUtil.input_targetCreature(equip));
       
       equip.setDescription("Equip: 1");
       card.addSpellAbility(equip);
       
       card.addEquipCommand(onEquip);
       card.addUnEquipCommand(onUnEquip);
    } //*************** END ************ END **************************  
    
    
  //*************** START *********** START **************************
    if(cardName.equals("Cursed Land"))
    {
      
      final SpellAbility spell = new Spell(card)
      {

		private static final long serialVersionUID = 5394181222737344498L;
		public boolean canPlayAI()
        {
          CardList list = new CardList(AllZone.Human_Play.getCards());
          list = list.getType("Land");

          if(list.isEmpty())
           return false;

          setTargetCard(list.get(0));
          return true;
        }//canPlayAI()
        public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(card);
          
          Card c = getTargetCard();
          
          if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
        	  card.enchantCard(c);

        }//resolve()
      };//SpellAbility
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      
       Command onLeavesPlay = new Command()
       {

		private static final long serialVersionUID = 1395122135234314967L;

		public void execute()
    	{
    		   if (card.isEnchanting())
    		   {
    			   Card crd = card.getEnchanting().get(0);
    			   card.unEnchantCard(crd);
    		   }
    	   }
       };
      card.addLeavesPlayCommand(onLeavesPlay);
      
      Input runtime = new Input()
      {

		private static final long serialVersionUID = -6237279587146079880L;

		public void showMessage()
        {
    	  PlayerZone comp = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
    	  PlayerZone hum = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
          CardList land = new CardList();
          land.addAll(comp.getCards());
          land.addAll(hum.getCards());
          land = land.filter(new CardListFilter()
          {
              public boolean addCard(Card c)
              {
            	  return c.isLand();
              }
          });
          
          stopSetNext(CardFactoryUtil.input_targetSpecific(spell, land, "Select target land", true));
        }
      };
      spell.setBeforePayMana(runtime);
    }//*************** END ************ END **************************
    
  //*************** START *********** START **************************
    if(cardName.equals("Caribou Range"))
    {
      
      final SpellAbility spell = new Spell(card)
      {

		private static final long serialVersionUID = 5394181222737344498L;
		public boolean canPlayAI()
        {
          CardList list = new CardList(AllZone.Computer_Play.getCards());
          list = list.getType("Land");

          if(list.isEmpty())
           return false;

          setTargetCard(list.get(0));
          return true;
        }//canPlayAI()
        public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(card);
          
          Card c = getTargetCard();
          
          if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
        	  card.enchantCard(c);

        }//resolve()
      };//SpellAbility
      spell.setType("Extrinsic");
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      
      final SpellAbility produceCaribou = new Ability_Tap(spell.getTargetCard(), "W W")
      {

		private static final long serialVersionUID = 1358032097310954750L;
		public void resolve()
        {	
          makeToken();
        }
        void makeToken()
        {
          Card c = new Card();
          Card crd = spell.getTargetCard();
          
          c.setName("Caribou");
          c.setImageName("W 0 1 Caribou");

          c.setOwner(crd.getController());
          c.setController(crd.getController());

          c.setManaCost("W");
          c.setToken(true);             
          
          c.addType("Creature");
          c.addType("Caribou");
          c.setBaseAttack(0);
          c.setBaseDefense(1);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//makeToken()
      };//SpellAbility
      
      produceCaribou.setDescription("W W, Tap: Put a 0/1 white Caribou creature token onto the battlefield.");
      produceCaribou.setStackDescription("Put a 0/1 white Caribou creature token onto the battlefield.");
      
      Command onEnchant = new Command()
      {    

		private static final long serialVersionUID = -4394447413814077965L;

		public void execute()
        {
    			if (card.isEnchanting())
    			{
    				Card crd = card.getEnchanting().get(0);
    				//crd.clearSpellAbility();
    				crd.addSpellAbility(produceCaribou);
    				
    			}  
          }//execute()
      };//Command
      

      Command onUnEnchant = new Command()
      {    

			private static final long serialVersionUID = -1492886212745680573L;
	
			public void execute()
			{
				if (card.isEnchanting())
				{
					
					Card crd = card.getEnchanting().get(0);
					crd.removeSpellAbility(produceCaribou);
				}
			}//execute()
       };//Command
       
       Command onLeavesPlay = new Command()
       {

		private static final long serialVersionUID = 8067313131085909766L;

		public void execute()
    	{
    		   if (card.isEnchanting())
    		   {
    			   Card crd = card.getEnchanting().get(0);
    			   card.unEnchantCard(crd);
    		   }
    	   }
       };
       
       final SpellAbility a2 = new Ability(card, "0")
	   {
 	    	public void chooseTargetAI()
 	    	{
 	    		PlayerZone play = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
	        	CardList saps = new CardList(play.getCards());
	        	saps = saps.filter(new CardListFilter()
	        	{

					public boolean addCard(Card c) {
						if((c.getType().contains("Caribou") || c.getKeyword().contains("Changeling")) &&
							AllZone.GameAction.isCardInPlay(c) && c.isToken() )
							return true;
						return false;
					}
	        	
	        	});
	        	
	        	if (saps.size() != 0)
	        		setTargetCard(saps.getCard(0));
 	    	}
	        public void resolve()
	        {
	          //get all saprolings:
	          Card c = getTargetCard();
	          if(c == null )
	        	  return;
	          
	          if (!AllZone.GameAction.isCardInPlay(c))
	        	  return;
	          
	          if(AllZone.GameAction.isCardInPlay(c))
	          {
	            //AllZone.getZone(c).remove(c);
	        	AllZone.GameAction.sacrifice(c);
	        	  
	        	PlayerLife life = AllZone.GameAction.getPlayerLife(c.getController());
	        	life.addLife(1);
	          }
	        }//resolve
	        public boolean canPlayAI()
	        {
	        	PlayerZone play = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
	        	CardList cars = new CardList(play.getCards());
	        	cars = cars.filter(new CardListFilter()
	        	{

					public boolean addCard(Card c) {
						if(c.getType().contains("Caribou") || c.getKeyword().contains("Changeling") &&
							AllZone.GameAction.isCardInPlay(c))
							return true;
						return false;
					}
	        	
	        	});
	        	if(AllZone.Computer_Life.getLife() < 4 && cars.size() > 0)
	        		return true;
	        	else
	        		return false;
	        }
	      };//SpellAbility
	      
	      Input runtime = new Input()
	      {

			private static final long serialVersionUID = 1408675899387720506L;

			public void showMessage()
	        {
	          CardList cars = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
	          cars = cars.getType("Caribou");
	          
	          stopSetNext(CardFactoryUtil.input_targetSpecific(a2, cars, "Select a Caribou to sacrifice.", false));
	        }
	      };  
	      
	  card.addSpellAbility(a2);
	  a2.setDescription("Sacrifice a Caribou: You gain 1 life.");
	  a2.setStackDescription(card.getController() + " gains 1 life.");
	  a2.setBeforePayMana(runtime);
       
      
      card.addEnchantCommand(onEnchant);
      card.addUnEnchantCommand(onUnEnchant);
      card.addLeavesPlayCommand(onLeavesPlay);
      
      Input runtime2 = new Input()
      {

		private static final long serialVersionUID = -6674543815905055287L;

		public void showMessage()
        {
    	  PlayerZone hum = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
          CardList land = new CardList();
          land.addAll(hum.getCards());
          land = land.filter(new CardListFilter()
          {
              public boolean addCard(Card c)
              {
            	  return c.isLand();
              }
          });
          
          stopSetNext(CardFactoryUtil.input_targetSpecific(spell, land, "Select target land you control", true));
        }
      };
      spell.setBeforePayMana(runtime2);
    }//*************** END ************ END **************************  
    
    
    
  //*************** START *********** START **************************
    if(cardName.equals("Leafdrake Roost"))
    {
      
      final SpellAbility spell = new Spell(card)
      {

		private static final long serialVersionUID = -4695012002471107694L;
		public boolean canPlayAI()
        {
          CardList list = new CardList(AllZone.Computer_Play.getCards());
          list = list.getType("Land");

          if(list.isEmpty())
           return false;

          setTargetCard(list.get(0));
          return true;
        }//canPlayAI()
        public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(card);
          
          Card c = getTargetCard();
          
          if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
        	  card.enchantCard(c);

        }//resolve()
      };//SpellAbility
      spell.setType("Extrinsic");
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      
      final SpellAbility produceDrakes = new Ability_Tap(spell.getTargetCard(), "G U")
      {

		private static final long serialVersionUID = -3849765771560556442L;
		public void resolve()
        {	
          makeToken();
        }
        void makeToken()
        {
          Card c = new Card();
          Card crd = spell.getTargetCard();
          
          c.setName("Drake");
          c.setImageName("G U 2 2 Drake");

          c.setOwner(crd.getController());
          c.setController(crd.getController());

          c.setManaCost("G U");
          c.setToken(true);             
          
          c.addType("Creature");
          c.addType("Drake");
          c.setBaseAttack(2);
          c.setBaseDefense(2);
          c.addIntrinsicKeyword("Flying");

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//makeToken()
      };//SpellAbility
      
      produceDrakes.setDescription("G U, Tap: Put a 2/2 green and blue Drake creature token with flying onto the battlefield.");
      produceDrakes.setStackDescription("Put a 2/2 green and blue Drake creature token with flying onto the battlefield.");
      
      Command onEnchant = new Command()
      {    

		private static final long serialVersionUID = -5501311059855861341L;

		public void execute()
        {
    			if (card.isEnchanting())
    			{
    				Card crd = card.getEnchanting().get(0);
    				//crd.clearSpellAbility();
    				crd.addSpellAbility(produceDrakes);
    				
    			}  
          }//execute()
      };//Command
      

      Command onUnEnchant = new Command()
      {    

    	  private static final long serialVersionUID = 3589766088284055294L;

			public void execute()
    		{
    			if (card.isEnchanting())
    			{
    				
    				Card crd = card.getEnchanting().get(0);
    				crd.removeSpellAbility(produceDrakes);
    				
    			}
    	    
    		}//execute()
       };//Command
       
       Command onLeavesPlay = new Command()
       {

		private static final long serialVersionUID = -3747590484749776557L;

		public void execute()
    	{
    		   if (card.isEnchanting())
    		   {
    			   Card crd = card.getEnchanting().get(0);
    			   card.unEnchantCard(crd);
    		   }
    	   }
       };
      
      card.addEnchantCommand(onEnchant);
      card.addUnEnchantCommand(onUnEnchant);
      card.addLeavesPlayCommand(onLeavesPlay);
      
      Input runtime = new Input()
      {

    	private static final long serialVersionUID = 967525396666242309L;

    	public void showMessage()
        {
    	  PlayerZone comp = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
    	  PlayerZone hum = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
          CardList land = new CardList();
          land.addAll(comp.getCards());
          land.addAll(hum.getCards());
          land = land.filter(new CardListFilter()
          {
              public boolean addCard(Card c)
              {
            	  return c.isLand();
              }
          });
          
          stopSetNext(CardFactoryUtil.input_targetSpecific(spell, land, "Select target land", true));
        }
      };
      spell.setBeforePayMana(runtime);
    }//*************** END ************ END **************************
    
    
  //*************** START *********** START **************************
    if(cardName.equals("Squirrel Nest"))
    {
      
      final SpellAbility spell = new Spell(card)
      {

		private static final long serialVersionUID = 6115713202262504968L;
		public boolean canPlayAI()
        {
          CardList list = new CardList(AllZone.Computer_Play.getCards());
          list = list.getType("Land");

          if(list.isEmpty())
           return false;

          setTargetCard(list.get(0));
          return true;
        }//canPlayAI()
        public void resolve()
        {
          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(card);
          
          Card c = getTargetCard();
          
          if(AllZone.GameAction.isCardInPlay(c)  && CardFactoryUtil.canTarget(card, c) )
        	  card.enchantCard(c);

        }//resolve()
      };//SpellAbility
      spell.setType("Extrinsic");
      
      card.clearSpellAbility();
      card.addSpellAbility(spell);
      
      final SpellAbility produceSquirrels = new Ability_Tap(spell.getTargetCard())
      {
    	private static final long serialVersionUID = -4800170026789001271L;
    	public void resolve()
        {	
          makeToken();
        }
        void makeToken()
        {
          Card c = new Card();
          Card crd = spell.getTargetCard();
                    
          c.setName("Squirrel");
          c.setImageName("G 1 1 Squirrel");

          c.setOwner(crd.getController());
          c.setController(crd.getController());

          c.setManaCost("G");
          c.setToken(true);             
          
          c.addType("Creature");
          c.addType("Squirrel");
          c.setBaseAttack(1);
          c.setBaseDefense(1);

          PlayerZone play = AllZone.getZone(Constant.Zone.Play, card.getController());
          play.add(c);
        }//makeToken()
      };//SpellAbility
      
      produceSquirrels.setDescription("Tap: Put a 1/1 green Squirrel creature token into play.");
      produceSquirrels.setStackDescription("Put a 1/1 green Squirrel creature token into play.");
      
      Command onEnchant = new Command()
      {    

    	
    	private static final long serialVersionUID = 3528675502863241126L;

    	public void execute()
        {
    			if (card.isEnchanting())
    			{
    				Card crd = card.getEnchanting().get(0);
    				//crd.clearSpellAbility();
    				crd.addSpellAbility(produceSquirrels);
    				
    			}  
          }//execute()
      };//Command
      

      Command onUnEnchant = new Command()
      {    
    	    private static final long serialVersionUID = -2021446345291180334L;

    		public void execute()
    		{
    			if (card.isEnchanting())
    			{
    				
    				Card crd = card.getEnchanting().get(0);
    				crd.removeSpellAbility(produceSquirrels);
    				
    			}
    	    
    		}//execute()
       };//Command
       
       Command onLeavesPlay = new Command()
       {

    	private static final long serialVersionUID = -4543302260602460839L;

    	public void execute()
    	{
    		   if (card.isEnchanting())
    		   {
    			   Card crd = card.getEnchanting().get(0);
    			   card.unEnchantCard(crd);
    		   }
    	   }
       };
      
      card.addEnchantCommand(onEnchant);
      card.addUnEnchantCommand(onUnEnchant);
      card.addLeavesPlayCommand(onLeavesPlay);
      
      Input runtime = new Input()
      {

    	private static final long serialVersionUID = 967525396666242309L;

    	public void showMessage()
        {
    	  PlayerZone comp = AllZone.getZone(Constant.Zone.Play, Constant.Player.Computer);
    	  PlayerZone hum = AllZone.getZone(Constant.Zone.Play, Constant.Player.Human);
          CardList land = new CardList();
          land.addAll(comp.getCards());
          land.addAll(hum.getCards());
          land = land.filter(new CardListFilter()
          {
              public boolean addCard(Card c)
              {
            	  return c.isLand();
              }
          });
          
          stopSetNext(CardFactoryUtil.input_targetSpecific(spell, land, "Select target land", true));
        }
      };
      spell.setBeforePayMana(runtime);
    }//*************** END ************ END **************************
    //*************** START ************ START **************************
    if (cardName.equals("Ashnod's Transmogrant"))
    {
    	final Ability_Tap ability = new Ability_Tap(card)
    	{
			private static final long serialVersionUID = -401631574059431293L;
			public void resolve()
    		{
				if (card.getController().equals(Constant.Player.Computer))
					AllZone.GameAction.sacrifice(card);
    			if(getTargetCard() == null || !getTargetCard().isCreature())
    				return;
    			Card crd = getTargetCard();
    			crd.addCounter(Counters.P1P1, 1);
    			if(!crd.getType().contains("Artifact"))
    				crd.addType("Artifact");
    		}
    		public boolean canPlayAI()
    		{
    			CardList list = new CardList(AllZone.Computer_Play.getCards()).filter(
    					new CardListFilter(){public boolean addCard(Card c){ return !c.isArtifact() && c.isCreature(); }});
    			Card crd = CardFactoryUtil.AI_getBestCreature(list);
    			if (crd != null)
    				setTargetCard(crd);
    			return (getTargetCard() != null);
    		}
    	};
    	Input runtime = new Input()
        {
    		  private static final long serialVersionUID = 141164423096887945L;
    		  
    		  public void showMessage()
    	      {
    	        AllZone.Display.showMessage("Select target creature for " +card);
    	        ButtonUtil.enableOnlyCancel();
    	      }
    	      public void selectButtonCancel() {stop();}
    	      public void selectCard(Card c, PlayerZone zone)
    	      {
    	    	if (!CardFactoryUtil.canTarget(ability, c))
    	    	{
    	    		 AllZone.Display.showMessage("Cannot target this card (Shroud? Protection?).");
    	    	}
    	    	else if(c.isCreature() && !c.isArtifact() && zone.is(Constant.Zone.Play))
    	        {
    	          ability.setTargetCard(c);
    	          AllZone.GameAction.sacrifice(card);
    	          stopSetNext(new Input_NoCost_TapAbility(ability));
    	          }
    	      }
    	    };
    	ability.setBeforePayMana(runtime);
    	ability.setDescription("T, Sacrifice Ashnod's Transmogrant: put a +1/+1 counter on target nonartifact creature. That creature becomes an artifact in addition to its other types.");
    	card.addSpellAbility(ability);
    }//*************** END ************ END **************************
    
    //*************** START ************ START **************************
    if (cardName.equals("Gemstone Array"))
    {
    	final Ability store = new Ability(card, "2"){
    		public void resolve(){card.addCounter(Counters.CHARGE, 1);}
    		public boolean canPlayAI(){ return AllZone.Phase.is(Constant.Phase.Main2, Constant.Player.Computer);}
    	};
    	store.setDescription("2: Put a charge counter on Gemstone Array.");
    	store.setStackDescription("Put a charge counter on Gemstone Array");
    	card.addSpellAbility(store);
    	
    	final Ability_Mana retrieve = new Ability_Mana(card, "Remove a charge counter from Gemstone Array: Add one mana of any color to your mana pool.")
    	{
			private static final long serialVersionUID = -2938965362221626028L;
			
			@SuppressWarnings("unused")
    		boolean undoable = true;
    		public void undo() {card.addCounter(Counters.CHARGE, 1);}
    		public String Mana() {return this.choices_made[0].toString();}
    		public boolean canPlay() {return super.canPlay() && card.getCounters(Counters.CHARGE) > 0;}
    		public void resolve(){card.subtractCounter(Counters.CHARGE, 1); super.resolve();}
    	};
    	retrieve.choices_made = new String[1];
		retrieve.setBeforePayMana(new Input(){
    		/**
			 * 
			 */
			private static final long serialVersionUID = 376497609786542558L;

			public void showMessage()
    		{
    			retrieve.choices_made[0] = Input_PayManaCostUtil.getColor2((String)AllZone.Display.getChoiceOptional("Select a Color", Constant.Color.onlyColors));
    			if(retrieve.choices_made[0] == null)
    				retrieve.choices_made[0] = "1";
    			AllZone.Stack.add(retrieve);
    			stop();
    		}
    	});
    	card.addSpellAbility(retrieve);
    }//*************** END ************ END **************************
    
    //*************** START ************ START **************************
    if (cardName.equals("Rats of Rath"))
    {
    	final Ability ability = new Ability(card,"B")
    	{
    		public boolean canPlayAI(){return false;};
    		public void resolve(){AllZone.GameAction.destroy(getTargetCard());};
    	};
    	ability.setBeforePayMana(new Input(){
			private static final long serialVersionUID = 7691864588170864421L;

			public void showMessage()
    		{
    			CardList choices = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
    			choices.filter(new CardListFilter(){public boolean addCard(Card c){
    				return c.isArtifact() || c.isCreature() || c.isLand();}});
    			stopSetNext(CardFactoryUtil.input_targetSpecific(ability, choices, "Select an artifact, creature, or land you control", true));}
    		});
    	ability.setDescription("B: Destroy target artifact, creature, or land you control.");
    	card.addSpellAbility(ability);
    }
    //*************** END ************ END **************************
    
    //*************** START ************ START **************************
    if (cardName.equals("Goblin Grenade"))
    {
    	final SpellAbility DamageCP =  new Spell(card)
    	{
			private static final long serialVersionUID = -4289150611689144985L;
			Card check;
    	     
    		  public boolean canPlay()
    		  {
    			  CardList gobs = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
	    	      gobs = gobs.getType("Goblin");
	    	      
	    	      return gobs.size()>0;
    		  }
    		  
    	      public boolean canPlayAI()
    	      {
    	          if(AllZone.Human_Life.getLife() <= 5)
    	            return true;
    	            
    	          PlayerZone compHand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
    	          CardList hand = new CardList(compHand.getCards());
    	               
    	           if (hand.size() >= 8)
    	            return true;
    	         
    	          check = getFlying();
    	          return check != null;
    	      }
    	          
    	      public void chooseTargetAI()
    	      {
    	          if(AllZone.Human_Life.getLife() <= 5)
    	          {
    	            setTargetPlayer(Constant.Player.Human);
    	            return;
    	          }
    	            
    	          PlayerZone compHand = AllZone.getZone(Constant.Zone.Hand, Constant.Player.Computer);
    	           CardList hand = new CardList(compHand.getCards());
    	            
    	          if(getFlying() == null && hand.size() >= 7 ) //not 8, since it becomes 7 when getting cast
    	          {
    	              setTargetPlayer(Constant.Player.Human);
    	              return;
    	          }
    	         
    	          Card c = getFlying();
    	          
    	          if (check == null &&  c != null)
    	        	  System.out.println("Check equals null");
    	          else if((c == null) || (! check.equals(c)))
    	            throw new RuntimeException(card +" error in chooseTargetAI() - Card c is " +c +",  Card check is " +check);
    	         
    	          if (c != null)
    	        	  setTargetCard(c);
    	          else
    	        	  setTargetPlayer(Constant.Player.Human);
    	      }//chooseTargetAI()
    	         
    	         //uses "damage" variable
    	      Card getFlying()
    	      {
    	    	  CardList flying = CardFactoryUtil.AI_getHumanCreature("Flying", card, true);
    	          for(int i = 0; i < flying.size(); i++)
    	        	  if(flying.get(i).getNetDefense() <= 5){
    	        		  System.out.println("getFlying() returns " + flying.get(i).getName());
    	        		  return flying.get(i);
    	        	  }
    	          
    	        System.out.println("getFlying() returned null");
    	        return null;
    	      }
    	      public void resolve()
    	      {
    	    	  if (card.getController().equals(Constant.Player.Computer))
    	    	  {
    	    		  CardList gobs = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
    	    	      gobs = gobs.getType("Goblin");
    	    	      
    	    	      if (gobs.size()>0)
    	    	      {
    	    	    	  CardListUtil.sortAttackLowFirst(gobs);
    	    	    	  AllZone.GameAction.sacrifice(gobs.get(0));
    	    	      }
    	    	      //TODO, if AI can't sack, break out of this
    	    	  }
    	              
    	          if(getTargetCard() != null)
    	          {
    	            if(AllZone.GameAction.isCardInPlay(getTargetCard()) && CardFactoryUtil.canTarget(card, getTargetCard()))
    	            {
    	                Card c = getTargetCard();
    	                //c.addDamage(damage);
    	                AllZone.GameAction.addDamage(c, 5);
    	            }
    	          }
    	          else
    	            AllZone.GameAction.getPlayerLife(getTargetPlayer()).subtractLife(5);
    	          //resolve()
    	      }
    	   }; //spellAbility
    	   DamageCP.setDescription(card.getName() + " deals 5 damage to target creature or player.");
    	   //DamageCP.setStackDescription(card.getName() +" deals 5 damage.");
    	   
    	   Input target = new Input()
    	   {
			private static final long serialVersionUID = 1843037500197925110L;
			public void showMessage()
    	      {
    	        AllZone.Display.showMessage("Select target Creature, Player, or Planeswalker");
    	        ButtonUtil.enableOnlyCancel();
    	      }
    	      public void selectButtonCancel() {stop();}
    	      public void selectCard(Card crd, PlayerZone zone)
    	      {
    	        if((crd.isCreature() || crd.isPlaneswalker() ) && zone.is(Constant.Zone.Play) && CardFactoryUtil.canTarget(DamageCP, crd) )
    	        {
    	          DamageCP.setTargetCard(crd);
    	          done();
    	        }
    	      }//selectCard()
    	      public void selectPlayer(String player)
    	      {
    	        DamageCP.setTargetPlayer(player);
    	        done();
    	      }
    	      void done()
    	      {
    	          AllZone.Stack.add(DamageCP);
    	          stop();
    	      }
    	   };
    	   
    	   Input targetSac = new Input()
    	    {
    		  
			private static final long serialVersionUID = -6102143961778874295L;
			public void showMessage()
    	      {
    	        AllZone.Display.showMessage("Select a Goblin to sacrifice.");
    	        ButtonUtil.enableOnlyCancel();
    	      }
    	      public void selectButtonCancel() {stop();}
    	      public void selectCard(Card crd, PlayerZone zone)
    	      {
    	    	CardList choices = new CardList(AllZone.getZone(Constant.Zone.Play, card.getController()).getCards());
    	        choices = choices.getType("Goblin");
    	    	
    	    	if(choices.contains(crd))
    	        {
    	    	  AllZone.GameAction.sacrifice(crd);
    	    	  //DamageCP.setTargetCard(crd);
    	          if(DamageCP instanceof Ability_Tap && DamageCP.getManaCost().equals("0"))
    	             stopSetNext(new Input_NoCost_TapAbility((Ability_Tap)DamageCP));
    	          else if(DamageCP.getManaCost().equals("0"))
    	          {
    	            //AllZone.Stack.add(DamageCP);
    	            stop();
    	          }
    	          else
    	            stopSetNext(new Input_PayManaCost(DamageCP));
    	        }
    	      }//selectCard()
    	   };

    	   DamageCP.setBeforePayMana(targetSac);
    	   DamageCP.setAfterPayMana(target);
    	   card.clearSpellAbility();
    	   card.addSpellAbility(DamageCP);
    }//*************** END ************ END **************************
    
    
    // Cards with Cycling abilities
    // -1 means keyword "Cycling" not found
    if (shouldCycle(card) != -1)
    {
      int n = shouldCycle(card);
      if (n != -1)
      {
        String parse = card.getKeyword().get(n).toString();
        card.removeIntrinsicKeyword(parse);

        String k[] = parse.split(":");
        final String manacost = k[1];

        card.addSpellAbility(CardFactoryUtil.ability_cycle(card, manacost));
      }
    }//Cycling


    return card;
  }//getCard2
	
    

	// copies stats like attack, defense, etc..
	private Card copyStats(Object o) {
		Card sim = (Card) o;
		Card c = new Card();

		c.setBaseAttack(sim.getBaseAttack());
		c.setBaseDefense(sim.getBaseDefense());
		c.setIntrinsicKeyword(sim.getKeyword());
		c.setName(sim.getName());
		c.setType(sim.getType());
		c.setText(sim.getSpellText());
		c.setManaCost(sim.getManaCost());

		return c;
	}// copyStats()

	public static void main(String[] args) {
		CardFactory f = new CardFactory("cards.txt");
		Card c = f.getCard("Arc-Slogger", "d");
		System.out.println(c.getOwner());
	}
}